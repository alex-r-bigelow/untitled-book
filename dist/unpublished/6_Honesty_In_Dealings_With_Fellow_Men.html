<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d647a49693fe64647a7bfad3ea1fe15c0fec007c1129b6b44f82f48464babe2a83c870e9ed103870e241c5307201eeb711f591b11eb907b9f6cac4181eaf758333ad7cb80576191290b0600eb9416daa8006970f396c26f1be826159459474d772c6cfe0afa9d6a4e4f0cbf1190707db2659cf84cc371934e7fa0ab6de24009497e6c67da905139d70fd024c6fda389f98ccb07ae437796f8a64ef1690044cc1d83aecaeec2a08d2277c97e64ef0780845705bae979ec97b10ceb3c6ac3e13e42f6a06030ee34ceec67de066cfa9d4ed6232b0da561b87f2fc857adfbba536ce3799c8a2c903a312ed1a492ccab83a9b097235533b6135108782dcd416fe3e39b6205253958cad3a78cb800359a91758662eae603a93b5ec72f3a633ba8f6ddf4fdcece7093744d2e65c62bba86546c2ba7b6a45b27f5f29e0fe86c13bdcefacf069feff0890ecc8bea2f2e21aef22801c5e403224e23c9bfa31a10307e4934339b1ac548c47f236e181c1bfc98b3b1909066f48f59a1c37469391ca4ed6c8968a7d7008908a8bb27678aad879de12d49292408309ddcf61a6f509dff6a001225d04419b59229cab2b9c92f5b7ab2e97bdcdf90fac09cd6567d1cd46d62846772727c052018ddfae865760f57a22d3f051aabfb868f96b2a89da5a71b2d79832f3015f74fc7a0fa182dda2f4597b6de81199ba4082d5a4f0096353ce3eb6a01bd6d644233ae5853ab05e0584041356632d5ea15ea6e9470028ffff812a54495bd9d8002a8096d1b5c2cc4fcbe69d13e81461b103928b0c6396a600d322b73f8aba9dda814febd1495fa87b6e80eec81e982d8463e9b77fefd214b4696dc29427ca1a63a917ad3bed6996b2c3d06970e88424377fd026696edcad9417821e0dd0dcff6855a94ab5d932a1064675d0f1aadd593bd5a56f2ad8b7eecb350f71e1f987e1925ce1cadaccdc9718cd72118a7697c4719438d6bff58e548fefe7d77a8636ef9ab41c7c136d87b016591c37a82d38301db3fec3a51e5f22c47408a5eed059492b37a8d72b18ca3de46615fea177cce419890df47e942ad37c8c84db85f99f6c98d409f5fc453dd1bf4f7a2391095c677e74866ed4541ca11ac5c7462e731fd7fb1052b3f32a21ef4c82ba6d41d562e5ab6b851b350b627fe190ee9eeb1b6d59fa9218ff703309481eb8c4b9a603ab20bf0243f83b38ebe9a87da28827af193b2eb524d3c613528cbab222bceb883c7c434dac6d8577ae59a4385ce7010700355ba27a631dafa3f453af992aec526e419c6674e4e278f47e3eb02802a9143d413ce8d1ed03efc866a4d48b01da799746e2efacf33de70b2aa178855a853f42c8aa72b037a74822b1d5abdb5714c3b1dbfc1aca99bf876259ca87b2fecf4c657041622a2122a0b3a56d8240353103366f9fb8cdca7c653ce1886f39610c51cf03d829600175f4543d05c70bfad7189a2697d38cbc7cd250ce147ee4f05b0d942157a4340aa4af2683b3d501542584c66ad20caf09c8f282fe48835f25dbb2ee0d85248d99b7f6ea347cdc513b1ab6d5df6606602e1d3d82b0b39952dfa2fb8d0d178cdf9cdec35d5a5f4d6ba2e59bc0f0874c1e824d75be773bfbfde2e6491c4fccba1da25607dc3f802bf6812560ed6f6ddeb9bb04edbe6e3510dddbb959f906090426c12f227462a5e0bfb02bbb9126aca65b431c8914ba5ec0d341856f2e0333eb119842dc08aa35c392a3ed4acb97f7200e79a6b7597fe7d74e646d345f21dc813f7ec811760b57dfd56e326e0199e84c8a470165ec2fd7a5dcbf456a0f1017e4e7501e56fd94f845c5e532a785cad8a5caded613fab5aa124451b0c7e62650d6493341ba41fbc9daeae4ec319a260129a05e256d1046231dbf86b83c5f40f4ae10a0f398f6e28344bd93f0de69953ed9ae0e2338e082af884950d62ff43c1c3e6d9e25a570cf1cc9ab4e81d6c6813d18adb7c920150657d0d3ad41f0d861f1b2ea2b14c70500d18bfc5a6feba5e5fdb0ddc3555915014cfe9116addca71ede4ef9570ead858cd2b4e3b85a194da65f7b24512f0403ea593d8e8bfaeee369eefa3c4818ac1663d4b5d47476a97dc69a0dc2813b02a050ca462c440341d8c58285d0f7101482abde46965bacc36da92822b2636cd7512e532fd3d17cc2be73d7d0b43e1bb79bb38be863d9d721cab8ffea42900a47169b3b576f506732f2779d24204466518fa515ab4da31ff66f18eb90c9478519f52bf178797520bc8ae41c905cf90de3ae2a824fefe96a2ead90fbcb1348132619493f453ff54b6afa476bbbfa62c973ff1007ce538f8574ce0584b13527c40829db6ba4b9b9b05a1eec791e6800a11619dbb572e420285c001a50e0908f4b6c2bca5989ed391791af8847027ea218d94a1e77ba294d6f3ddda690b2bca38725818d0b99dfb35810dd2b2b80dd2bffcd2adee7cd613b23584825e11632faaa57ca4a8807b661e9c36608c2f84bbf9553266011fcb237dc7331c2e1117694bf52b87a4621d9423fd51a145dfd54752691ba5c801069f52db5b6a49b80ab00ccf9546073055f4a5a4fb7fc5adb02ad15869dfad7726f1e85d65c471c4584caf66379d1c4168f5f5a73c49e0b0c0d98ed986d69150a4931ce42d49ecf84aad288f504603aa5b75077bebdeb9eeef161f9e890861aa0e28f12c7c3b20762b09845b7f2056347ccaacebdf692ce4907bc9266b27f2b35d6c3aaf0840a3135688a773282bd8e2d6fe29dbed7c0906efea2b4d762634dabdd74020461e2acc5236f557a054def3074863ace1e9b43f51f5015b6051e0a4f7f6ebfc622ccca94db2b944a620fabe4b7e3ef2729361335d8cf2b85035dd2ec3869a77629cd2f311aea19ab01c5f58dbc047bc5201671e0fcab6deaaa08b9e84c313a670481e06d7277272cb9c05e65343aa3fed75864489dde7fea110bcad6d62dbe203308200ac95ce74f543b71a12eb4637ec9be9fa130259c3afede912f52474edc20fdfbbe089f4589c3476e87a95b62c7598496c9fd792cfcc4a25accc4ff60f321b7a240fc9e1514518043d44895ec6cf87ca0793e7178352c070e53e37f1901eaa1cf2dffabd8e580c5d11cf56af895157ed838e0a0a5177628da8d8257bf719b68df37187f8b4638ecba868e0a37a05c2f9fe071bb6adc1bf79f8d23aed1b08ef98b7e11b135ae754e1eabbe967468d57ae9bbd6d5b1dd076a8ab649dae3164608fe2002deb03d4f53e288de82f09f72440f2d8998a72640eb4bdee2fc5e6268fa985657c76fde8257df885cfa810ae0ededdd18c9c4fd84aeb10f759aa8f5be25639bb255e66eeb5a124481b30073bf64ce18456c85bcc16bae296a0c4d349ae81d7aa70185172ddd9e51aec1705a40c0b2a74e23d65e8cceb699ee30eb0d25a5e94e16ca7303ac173beaa282231a4cde376094af93eea29dea2b16d01e139df6cb9ba24687e50a04654f3bd789fe7e0e5520bf3a974faeb1f3d5244d3fd8a81120ffffa3aeaff93db7ee82e0e2a80db176eac79c0a253500b46dae4c38b5d7e95d963eedfbfde39a8c44f0eaa2abbd43f76c8873abcfb689052513cd6aa709bc32468c80c5471f8cfa471a78f9e7f2281151dee3f6edf252ea0c5092232439757ed81983b14e580152ce5201d8b09e99f4a2fa069c6c40e553048fe75e16422ac27b92a2c8f3f0dc4ee682d2e171a569c07e6a7d0ad6aeb028a0cd28c8f9d16107a2a1e051f2de027e404f8b30faa8713d9ca204c8db5babcdf6e84ed59ecad2a8fa2236b5a3b164801654151cab53448106c807c9cb8641a5bd571c377f36897f23bf30229cc5b83cb547f69307275d4a24d56c9d17d8b470be15c56178d722c4ec39312436574b21d256b8ca85c2874531c1a412e79750d30e47e74fe0799d8c3f596755f78e4e5a3413987bf4fd44227b1ef0b1656416f406c4f2937faad50d6d49d24bba0f4e6f90584f72736e74eb5954ad91dfbb8ee6b1d27b9cf99a887d27562c5cf85e97430bad40ed4e46d5730eb0e97d75fd7b6eb3a486171e491aeab3f21f21fed1f03d73ce36f7dad1c02ca8a437d7d35610b185821b71c97c9af514e7db0ba9a58ac51b573154964e987bd07dc3149ff248733d221f07fc5ff73bb8d81b0df1592496cbe171cedbc872c3bf110446b95f3fd21e49f8fc91985fa90ccc909d489e498d905db01ae65d10c0742d467d7134225abf8c108bc80f2b35685eadf2dceb49d764c81253dd2621e0a801cae381c6b5a5af8e36466e4bb3ecb03a825644d7f74bd53538b140729718750f62d83aa3006021ea15547a6858d033347ddd5c0a5ad46473fc03a24a9820850f290190a4cc31f7b0029875fcceea86ebdcba800bfe271e2f869cdab15a68028ede676f8214bd48be7c7d65290441247a6c853c9c39b6c46d241a60cfa26164b9ea2b34b4fa9f935e8d3619d728d10f44040b18e1d308ea756c8143580f8ad5d420d2e5e0639a58278132a291aac5bdf34a451ea12e9bb8af7b01b3239f628811d66d6fb9ef982f49c0719204aa576e5ea320d646e2c83175c6f69c76c4b673a72c77e3d4f812bb357ce29f602b4fb04b5147bd4d8be3338376751fda05255eab9b221b2bf866e2062803cb8c401484d804d86a239b4c85cb2faa766a30d5b354d08b5edf71d82f058179c70039c6ef3fae31add435c9146ba19c849eeb7502b3504f443975ca0880498b80bba77ca7b2f54ec3d9e72c726344f0cede4f1bcb98ccffcad3a023bdb716b030845fce51bc136eb8cffe7fa5854aba1423e5cc0171b5240cc75907d384fb28a0770870bf15cc7d1bc83bdf25317689a4a134858511692a8be6194cc0d4351c194d43916242bdc5b7e51d4046b4cb79348d9d1e36ef9200cc3f33dd1b8dcfd513449bf56801d509ff466170722a6fa8e79b9c6514dce19832d09df93f0cd1c8522fae30213a497e64c933100e8dd94b221f07dee02ed8e9cdfee32ba9032ec1db2766a96f84ea456e0d515630e5811a8453a5ae647d0697e421b0ebe8a86e33e96a058aaecf2b7e0dd8e5b3aedbb4072f1a6a9481fce2f43c55cefb5cdff61699d0131a5a70dc84a6be3a06fb0c195dcb617f3cce3d76c9583ad0fa9dd58b5a898fa7c779d8b16af1f64c285a2a650140ddf0c5e1442a35f0fb9cfea63246032cf32f15f561f6969dfaa14e7686f79fd429e2c3076bed17c5191b3fb47bd6998f3fdf96373f574b3b8116557fc5c27c02e097e5908bd22c2f49b5908c57b2fbb99cc0bdff59bdbfa17571087959067687f061c81cdf1b828f4f2b04e222accba3335255c64066752e8c65677972ed5da5a4bc0ace274213cf8fefa41c18368fdaddfe654888d7273bcbd22d31c4d4e047bb74c12c88cb7529a8fd4b29e5f7eb0042cb9ef31a40f3528bceb5ff29e2955621941f24a60f45dbd53507f11eb2f0b0058882658335f9a931fcae5dcd6317aae39bf2a6050f3193c9cea6d5d62ddea8b38625d32eed8c1128a25b79739d38049656d0f9eeb256fc3afccb9b802220b10e4900dbaee010d842b16aab9b0a134a13e79e9c8d9d8cc5172addbcf6353c93265ff79bd89ac18599573508f8b1b014683e43638d726db11d3b81b035963dcf8588c1aac21ec9f6255d2dd9a959ec6e5bb3afd4c65725a4836703afb707697c8f58cd85b711fe7725d68184de83d7d481043d505b2a8430ebf0aec5ac41e61df6b2d5335b77a022e59e1236d8342eb117423880b2ff3e7a2b540b259389826e7a11f42bb40a0c4f9e8276d1f35c10821e25a955ff6853f3e5148ab259799307b715a2c2e771e35c6052c491be36467d1788946585e1ed2befe41ca66fb4bdc5bf5e417275de771e60bd1badb9b9bb07d4f92f27b76ae81e6b8a63de21f351a53fc8544dfe450dce1476a2c18b4f01d64ad0ce2eb430664931236932494af1f559bee7698eb4bd6a0b654df0cf37e2ecc4a5676e0775e6a97bb5df3d7418e26f1425c8c961039cd61f5432eb35c468d95c10e1d02140522946a936bb4d5c119c7c0960637eb4a2d365f9b0127ee2d2160ed284aea3b13048a0e2fc53513b0cebe9cc82ae414b13ea70f1749e5658df66e8df7d72c00a2ca0e173b71d65a068b8844d8696d4ecbdca939666cd5f3af710941cbdb283421268058e6ec4809402aabae5cb7b6a46c072503049b4d138b778f0096cd5e13268b39ef5ccd123a73edaac81071eca921fba5b99e9bd1594497f11b90c195356d2ee4b93fb422d480b7b55198774e6ea3e41a3df3dd1c7c732f38f19f2e2fb7613013530de480f82d723c3bb73ba52c2339d9c74c932495b6ff8f4bb8a1f59661b53cefd4bbef67e1ad15fac07b33c4a7289b4c4150002659f9ddeb916be6c99a0f1e266a7c5dddf83e896e472cdd4949af5b442e785201aafdd9ea4aee4831e2edac535bd6f04136ea7fde3d1ddc847e1752675f8b39a5ef3531bec54d77cfc91bf4672ef136ae29b8319404c7c550981075a141bb295f6cb5d214a5554b943358f0a9cf3b3c48ba775a10d3c8bbd078569d396e63c397ff310e34fc287b875dc698e879941543d7f890cb37922a4ab818c721141faa8504a6f46dab63f44fe9ec97f141de17efbc61e88449bd19df2cc3327bad4a40b19e541eccccebcf28c876983c69d9c5bb61754063e2d7e36e22a8babdd11f1ac2334bda174fb280d8aea4ad87c0706153cb7f720a8e011abedef7dcddf27efa09ae39a96c97dc608d3010c6e494aabf2ec86d0793dea73de11c8eaba76227a862e8ee3b199befceeb9fb18a455bd536043b0da538243730affd0ae31cb82036d2d4f00aa4490d24664b43dd452579ef9b8e4432e082ed9430a00acf572033325a053054029fccba2dc26f3e60e91007b0270074c1df3273d7aa39c00e5c431d668fbfe03f96ebca2ea1472bab89f4622b9c32e33880efc127fb27b9a2a92e1047a9838588c9f37a89318437962e8777fc75f9cb9ecd45e4f7b449c44e9d0e9c52dc5f2b37d86c87f121fc98c6b2c8fe3ba0760638687dacb4a8cc605aab13282f3852faa7a65f999678abb1d47d7cb8a3e1f3305afe933ebbd372de34b49a2615fd9c4884266ae39710311662eac0abe7e125c4a4bfe82da3b975eb2eb06a89a709ac1b928f3d00bcffd00d82005a483d66b50841f35729ea34116c8df80e7112931d87de915f92e37686f456bcf61f5bb5ff3efffe17519583b1cb7b433f4ef6f2865671a0b6eab422d50ac47f7541158b8f9d00bfbb94deb7e8dc46d58a72ff6190bab3acedda1585921c0bd7b6804c3f6fb0b3d42b834c8c0867c87c9a72ad255bc40c89e05ce9b89e5c6ec486c63ff25590527f14e001feffecaf41a769d005e9830ac597b44f971b54bc1fbc46803d06db6786c962c910d03cf54b68ab52017ca50be794b2cd6165582921b1b20593eb24bd66e63f10c97c6c54038d10f57ded1df142deffeabea00595be8f78a28f2c08bb3096d626c4adeffd18fa0f3423f06fa4044887c6dbe57c8f04352c53e22f4e2eeee221c81c674170240e4bd48df74d5049fbf2e25df5df952990db39a7f76a2fd2e9f7f603bede176735ad7f04c45680a662abbaeb7ceb751c18bcf9c4be3c1d21d4a41f2de85e3af99ebba2b150fd63e11636ecb95e299b24dfae4e276b11244759007e3799d5bbfbf547eae5b2a019009c6579903858911c70cb56cef515378d5379a6d82addd525c2d5da09af1ce435ca5c68c1ecbb085df0f1e26b6953d0b75ccfa9715ed3549d01986e30dfad8999da2ce1864df629aea0eb585834d72e6f997dd142999fb4c17418a241f0646be3922ea20dedc68ef648470755d6a0db2c12b9753c25a4277a95737a1f6f14927e8e2c42c91b06fdaa6432f180386d97fb2f46395da9035c599ee03cd5d29e5b40736913b440af51141f06f47b443f7244c8bd0bd27491ba5d5e2516b48796058c14e85e75b602cb664ca8bd8b40887f02a4e79e9683a7985cb218c51cf8940a4670ed94f9f41d888e1ed3b28499df8ca05eeea4aee18c2f9943d9f1783395c5c7a2eb1097bffa74d052d6df7bb9cf7ee28929f2ffa3b0ed5a245d942d3d5f6382a929984a05af5146bdff0f49cb5f547056a1061a35e76bd192187bd7cf3bf46b267d10ebe19609b07b23c6e051bcb5c97547e3da5a5451e7b2a029261e72349a5c1853fcd602536e731e7926bc914f1813540b5c7a96bd188edbafe9a07fd033f79432fe078139bad33a4650dfe2076033af6ad671972cdb0c97f2467b028ece410d0a97da101325bb91de3e39726fb757b8683545c42fc79d9bd0f4c5ab5f2461abdc92b99d783edaaca680bdde337b4272e7b20022005acdc7cd140d229d19a42512f1fd1a88c5821ea3d881e0c88c6055fd110b5baeb85c66bddaa04a17bab90cde1eb8dfb6062096e5c88a50524cf8754c95b593177a086961ed93054a05d673577e8c1fe9416255e695facaf2ba6d7217543491be22cfae431cdddc5042a43d97234b69d9a2e5982d821f00ec448e554ccf00002e143e9f0fbc2497cb0330f683c1d2584024ce9ffefaf3f096f8e77fd8b542d7deef3bc71cbcaf7058c0156903b607fcbc8959d53af15061d05a89fc7a2151b3aed066201080b8d82f8221cb01425feaae195bd4e62edb68deda37c6489d0fbe1a978e149db7f56120d4295e34cec8c95dc7030e4881944fc5f3104cc113ce6f38f4e00b38c7235860b221334050bb873105ada066bcad91a95b97d4d77340ad68acaf9afe7f656147fca721ea2ce0afd4f5ffed7f14782ac671a767c7ec09a44a84f50b526ecf15df76d5ed808acbcc8e1bacb4b0f7f0f53f303f72f4576312b59009f6b5aa325772bab04e7000b8de64887e8cccaf8fac0f7479e1397c5f38120130dabf03b1f8ef2d36b2a8d25c45883a7f6c264b8b1f91ca86376d03e9639ed15ba40a04baa78b0f469f8d2cadd496fbd944a88eb985c6301fc4d0c8209638610f389608ee6244ddb4173606ee6d27f000c10f898ff92396b0c14c23e05e6a71048e584fbb1f95f82744560a0049fd9c6e990e125b1fe9ced368b0d2a4bf5f4a0c45673187582a7b0e3960eda98276285abb440b982354999bb9cc068d7272b981e7ce50e9158eb3b5d37edfcc4e2fc408c55f36e1633b2edfab140193dd39b17512f56b915d1e3d37d9b52fb519056cd8aaca0e2c88f17f7fa04830cbc50c9477f0314b66527d67fed559c34edf6aa8f06c779c8961ff1aaf7dd1e10b4c0d866aac30805947575e3deaba5c503e065680b454fdc8f8b3787a2a01a938254d78ebb81880ff7614b9952bd65aa03f6174db01d4b4df55afe6e93924ea6811408d4b155924b661428e56991557f6fd667b0136dd5cd9b9714624df7e134d0e2eb9e4d35bf89a805905d9d90bbf8d3b9eff85550b05164a94e438f0dae956ec2f627dddea9ae0b7a896b0f8fb1d0080e8776f4073f12cb8bd70baca9ccc585dd3d8b33ba7e5c11e857956fdb47e589e9d8a3aaf9b0aa57ccc2ae213c86e9760231ba5b50a40d8e5f0b787e9c50e8a85e4fccac0833203572720f0cd270938f47ebfae88dacc9846a972ffe353f393c56095203882f58247565fc0a1f6b4453018e1a9349a418ade72cf51fe0b073b0e71b1d88fae4511d58d10f6510c1f59195ad26250cd01a16e69ddbc5cb5527f1a7b112c8ba3b1dcc8d54b84d10d51075f0b4a90274f9bacde5da11b916094ac1989d12d8804080ad40ed692b4399c47a5c5007a9ff45abfac776f54a9a85adee2e080eb7dc7c62b6da4aee91ffaef229665b1dfc904d5e2b588448a7ad2c7701d7cc99fbeef429d735c0662c68871151e99c968cc5eb1d2c788226eac6c303d8704d5ec5f91809126c8f9a6ac2c8a07870512aa835a0dffeb41bd3566e2bcd42d223dc39e9f9c5e90a7b2346cc369df61c507895b3831921d049b7438566ac94467b6661a1e1096ff008309efcd785eecad78abdc2fc5dc775aa3f333f9e8dfda26252f5742c578fdcac47a41ee4b51843732cb128de0b3307efb1fd4b875639186abfeb89c93b423186df1693dda6d848b9f73a730bdeed3d136cc12652fc1ca426f15bc4acfa615c7a500975382d14c79b210a8422f0685b875296634b37163cdcc0f2e9acbb3fa2968093f7c8dbc83c9a914c3ff3e0b744a9b5ec43cc9a7719e6b16ddd6b78fd10ef7deddbd1ff8eb4f292a8ad29799dd511445c70b514117959ddcbc9cfd7e92f39ce9a3bfe4e46ff7026ff1f886ba342a33593a86e6147c36e1c5b7c6a22b509beeb2f587af8d417ec3bddd2d49937a2a15871a42b02713ee677df9f54def1a218a709db27207d550cc23ed7c6fe9211b0dce73038a530f8fa27d1e032a8b3a6bb46ac9075ba83da3b88ea914b92765aced5d74e2ce56c4d7990d667fd43dfc3f1130e640a027bf36c026e352358471fd9c37461f902652627427838eeb5f2440466c9d189cffcf8eb883f5d12cf16b04bb1c8b1cbc122c3afc851fba519c0a78a72dd09537c36d3e4835d58b6a5a135801caf513cffb429ea15f908fbb145e9c86dcf6f2d8a0eacde22d212af42f27341e6479b5026d0fcab1ced92ee98827fd280900f348d72ff7090eaa20d88bd46f97ff8a25b650df8fb191a88f2ce14a80ea2f861c46ccdab530ce58a45389747069ca48185accee013b2f452ab5743c9ff5c2c7e215111d59756380242a486be293d2768b745a0fa9709789e3e9dc91e10f8920cdaa691956efda9c8e1e60b198ff1fa3ec8c14626684ceaa4010b9991133c93136092cd62baaf60c6f1c2d7b8033f14a3f83ae058dd5367f3762a0c8f80df8428b2ccfac5a7d659ebe6b29865b8615603f1d34efc7177e4b9e1d0785c103e24661f5d7558a695fc573bdee0681c35d73e867a9d71349fdb888fb8489b3d7c02e965c1348d92378ba30fa5ba380acfe8cff12cad4a40c8f3c04424a79e7c1ee20483aa0e062bb6ec868a6d598d2767718890b7994e514927581c9425b74333e7d68132b8e81125cd01ca871fdba5db82dd278286b82e0b60a15f2d68d8ea3bd95ffa5f1171be7845125d28ba3d0b3b917ec2e50f907381f7672a0eaff799a21ff6e660f969e324bdea25c74557edcb2eb1c9cee459fd6582235754985b2d1c855ad15546f411b1d0b1a695977f99ef1bedfde4cfc9599d988950b597fda31abf5d925557a9b4a67f326b23bfcf538349723fbd0ce0fb6904bf2a01485b97283f155ce1fde2fa73e8521c9d08527cef00099a29d33e554936787101f194e6ebeeaeb1fb775bbf017858ad0941139912c4b75d185a4bb9eac02350fa0656a245316f9189fbd78d5ae0411f0dde5bd929ce8709bbca94d26c1e57c1344c21df96520eb0b064fc4359fc51421c71258edece726229a47a6b973d54cfa0473311c75e3d6eeaf293fd9ce722b840214223e50f17e8f48d7b94c2c6a17659897b89ea269b5ebb1dc35c8405d033adddaaad806e081b3e6525d44e5db7e7b051fae99465914b058b5203b01fa85be3e9e637043dc7bb9bf2a744419332a5fcf6724b52de357b7299c30d0912b896447","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
