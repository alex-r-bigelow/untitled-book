<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eadaa38545c2115f6ff16b72050724a863fdab4b0b04b4c90ad7834369a11af186199ac13aee0f0361c736dcb79f3ef4fcdef2e078f5fc245f81eb0c69b3cf2c63d251937449e1427b0e9aff87dabcdc04e8b56195e6cb2bd8aef30d5f079fae9e5d44380e8d2c1e6cee12998040508d9774cf9e5e7d86a2928c9febaf08cd14eaff29f27297e847f8c7c7adf31a417b3bb11faa08aca6ccc3108f44802ce4176f4604ab1bfdf0196d6125b4030b4dd0828bc538a4467263ab89374b3190ef6ea1e3f32cf6b417f7598a3e0d57d42ce895beb93ef894bae4bc39a2e3ccdb0020601927e5086c3de32affde69d6f6275fb3c2c4cbef9b9b1b748f6ca07bf57c1f33d1dca2a199aea59744491792aaab8a87d965ae1b3465e81e3a84f0d5de3aa76acf38439cd4fb77269640a3300086722bdfbd8bbe10fa32cc00796d567e795f91a4513cb9df6da9704189d4a6e270292f38118a23bceea67cfbd5bbfae21f89b6dcc1a963a4190e9eb3757161aa3b2b5ee95b2c9d23f9a42d349edccf6f8ecc0d12983298208c2000b8d64eb110cf2d2ec515ea3d655c8ff2da80654fd29a2eb7a17ca206b890d27bd7638d5f6e13fa7d41335e3d89721f6d15ac6280135775a82d2e8d0e6ac0175e4b2698fff540535f3da241c705705ec35ead1e270ddef61a4df42d1c17b5e71c32d36ea1f021bec3ea6baf107b1daebb8f6efe6505c2d021e721f78e8d83262a32706b558f9f1758c5ec548375066f42f400667c843453c5668791034925f8657aaa79579ce84e5f6cf3807b116019e0fad10fada21f4df77a6aca960d9030412a66b8c3ff3f6ce4a912c6c064fa0d13e3ef6c416992396a70aaf476354f9d2e7304a24e9b21236f31faf6a8fb8eba14f8dfedd70bbc8f123fbc9a141a890562c05cd86904a5eb2a1c71abdac1b90d98f4c4f47f94d19c615a174cd0f3e541c2591b6116c8fa1444a08d79c52b9c2acc58f21d85ed4e1971cda57b9d69b5f714d2f8db11ce1bb49c67dc0827c80f33e15ac2784e9b9565e0f537d6c987317bc211d5c7837851af49718bf40b5d789e6542f0ec815955704b1f367a05a8d69202c33b9edcedc91ab411bd4377a7809e8e03655589f50a066ad96803d0161675fef5855c99545ac1c644c182f9ab39e5ba7f2d3c404c963f15534e7003fd9b363a55bba72c7fc951596816a5fab62189bb21884c569b10abcd0a8978e38cb50571758900144aa12f191052d12daddab4f88c70d9b3801db8083d9aae33e69bfa20da09e6ff1865767f81c07878f4ddbb797e1db29edb69bf4d78c2903ef16028239bea68ccb4595d17d993e3cdeaa642b28d9274c7aa12894c1e20bbe3adb0246bc4fa464625e2c3f19ef1ea8b2d8cc512cc82983177951f8724f8cecbcbd82f5a3d06915695cd248eda63d16d124a98a1b3875259192396ea53d000935feba2907667ebe497ff575c96e30730e3d78cb9c9891f04f51913cdc5bed9ae7333c44a78fcedbd1701de3f20276d42ffd62eb6f53e965b3bc607dd9bb9044134a8525d51a457c992b7333f75fa74361917153a431a27542c00e5e8065a69be593cc86e23a0081715d8def75501147a30b93966dd82aa2ff85aac9a45198019f032e7d17b9783d3d1fb5fa449fb01170b0a14f8fb36425997c29ec4e401d5204b77417f0edc7b1206575a1a0e73c58146e4f98ed1c6f10b1a47ddfbebdd784e10d3a61d2d396585dd5459e6b94bbff928bde99eda9e8bc74e2a5d795d808f1f7bb52d975b9173604dd7dfcae324f19f9bbb0de0eb484b422bd58febb310ee72f3130a18d28b019931baac0554acd712c3d0e740a60fd1ab4ac31afe9b495cdf934070555e2247da66c4e99c349a57fde620407c7407e66d8279f6832a4ebee349df43de369aff046fb57fe4be4d5d757fc98fd1b99974ddbb14c813ab258656004627807a1af00c6d846ef7ce0c62a0b621355e6d10d1a8529644874b27c8f14170affd955c7dde35004c7802bbca9ed636bd91dc2bfdfc282f3de0b9147194bba8529ad03e43437b2078140a2f43d8d41eae8d5719dc4ce927378a1ede5344e2fe09082b3dfeeec9de1c58d3e85e97935ee912c0523b93920713eb373819ddf6c707ae2b96e97d70dbb3cbf1075c4864d490858412248d91f00415b465b2b0e3af39e18ff3025173532b5e269cb79d9fe66c037ac832a347a1f593a6b800992988eed4bf1b2e2d6d3438e850c8b8d6c9d859e6439f562a4a068d511e09b34066d2d81c8ab79fad38632037fd4549c8d86abf1d8417859ed4f7d8ef0a3b91bc407069f43fe1d43fdfb5dab85b2557de81eb1f8d16467f0ce96e4caeb66078f181377f4ac10bff8fb3fdbbdda4d7aafb852fdec3b9016415a2bf8a7fe075c8def38810ba5e8059e23c9add176d45766bdca2170637f20803ff8dcc3c3918a80d360b69697878197263ee383115a41b8bf93148ca0138f9e7f38be46758e35c75b0182533caf8b25d666057093507472ce1cc5403d53f665f5d0173e07b7e95b456a54d6b42ee81c1661cc8faf016ea1c86d6d7282ea5e7d6e40ee0859ed0f78edc52a262f382f124751c76180a02ed874fbfce55c0fde9c0679b01aca597d395a1ba129a0d434c6c3473216ff0e56383ca5a0cead6bae84b2da8b1c2d836db3b4bdd04048faca2a58cc2925101fe23a170d0b8f29fe768ea2af5ac2d90d095f21680d7466f902c190b58668812d4a2ba03e1d14429d772d510580fe807f9a823b1ef0079559166d42a1b7b60806fb10b39fd44d60f8178fc56e38c732acfd3ed14765cbd35e43bab01f76fbcf5b8a3648040f94aa4173ca314ff05510ff4a30eeef8e1eff78904e036a61d442d439fee5f0718f9528332692fa1d638e925b9dbf9d7acac63dbc9afb419d188f81732c2533f70f7228ea53e4b353b8c2f1f0af3e54241d3ce4fbc741c744bb209c516d80925a3ee7c295e0e76f92f1dbadf8c839ebbe8b91a9c45638d076d7a7ea3591b8bc915cb7659b758bd7ac1adce5c3b78b820fdfae5c9bcfaddecfce5f6945a4aff27c388e4f3641f10ad700d08a44b6dfe4add4be0e21ada7e96f18bc21bcf6116600152f932e1ecfe86b4b756461216aadfa09d8734373554d20469aa1782f757d5d87e243b3e4f9f7cb8416a5bf3f1e2e80e0fe472ca90e7a6bab669c7073c8f4f9057c0f09a00b06393e51d81a01a8cbc4451aefe0593bbcb660db8ecfd126a100f9e152e53a547d82998c8962249cd495257a2c48e01e3ae7cfad6e17bb4e711a9a07d98006cca92fa4f00c5433a6eb82d6f05f4965c8412b2c5855b9950448fd0a502d981cb0e26bcb037102b0f769fdb7e6fcb44ce2e8ddbc9389ba83f1ceab7b9c8acf46950044fe3554ef795b21eb5b0db52a843891664a91a415e20162bd23657e53f52e0c4189066da3542db7492ccf3a37540f54ff4f260a9ff1bc09e4e2037b1cb828250a9b9744dc47187a2e49e22c4722e14a8ad858bdb9b547d6c62354cd310bbef7a51ff5308341ea0fcb993ee3f673714c00699ebc584291668af8ffafca8066696f352d8c411fe2dd5ee79a53981a255ee45cc964da66355de8b849091854b8d106302bda45127b70999fcfcb76d0cc8033193f6faee7137b5eb670602c86e3fb696bfddf4c79bbbbd324efa2d9feded5c70071fe85adfad8ddfc32ac34d71cc5a7418014ff570ed29d84bdda3e27bfcd39a1eef0662a9fd20472551ce0b1eb40fe7226eb206972da8d83ebcda2fdc86deaf09d057a47689b081df96d3b58d4bab423e52963bb76addbe328bc41ef2757d20f66f3ca8dee7b28791c70e2af3beabd9b0c23ffa7f49b0b1f7722da22875ba249c3662e7bbc93f856c8065991e602da9dc21e5e059fdd259d1c1a268403bdf4dd52538a544b7418530c04fd17b396d4b7f452b71ddeb4866134b749a069413f8dd0274ad0ebb074a90ba31968289535dcd12bfc5359c05933e0028a1f6bb3da3431e72877ecdf14d02e9b09994fa9bd8ba43c910de9830b28bf3caf05e95d306aaf35ec1362e9d97d4d95cc63e66a1178e5cd2cdd96f19ebc1955fd4762149167a5328718f48680d9fea4268a06e7b32cfd97658179651718c1566a885ef2941cf2aa65522af2c7b1857e08e4435404df5f0c48e3d75160a303a9e598cc72eb393561ff1dcc27f00f6b2a4bbb0bdddb95407d9af69be5660155afa2b5e48e00d64992f0b75fd2dce3af84968b391a47125d97764526e312752b108aa173afe9780b0187dbaadbe69ad2ae65bfe2844688575f9b3281132ac98df0c7273c1d70a73d221bfd05444f411e2747089fb011bd1a78dfed04d3d8b002f1d48b051c2d6adbe5b0b66a37403d6904f72aab60e86f09448c17a437ecd635c3374eef8843a282c27d52c642cd0190d02752d92f0e915af6e20fef13f7529361a137e6a87cea2c0916443d7b43a9b578380ccb34ad95e631d9186bcc05d2dae3ca855e10d871522ae94ff4463b229b43c35ce9fa39587bd198cbb20ffb43688884033353e4a69144ab02967d8e00d862608f87b882403daec5f584757689c3f476866a17422f4e10de0bb538b82b796a0dc0446a1f7322c8576a18563c515b536ad340d4fae3edf6cda4a1fe2e46621fd6ec2c539e4a88dc4de0bf9ac1d56dd8c4396dcf76562f0a1679cd00cbe737adfdb20d94515abb2b0d1900b469ef64c96f0d3de212ce2d1bc04ecc30fad4445fb115f83b78790f7e2c0212298df7cc77887e3127b4e5f054cd368f6c2d9534f797f8b931c7d9990cb619ccf3a07d429cbe320462dc45a48ebe840925351eae35bf853f2367f78aae0fad41e3bc918ca36ee42959263ebf31ae4a9980a82fc167f2df20adcaaa355c77566d9b7591462462a74b18e944729545e3bfc3e274acacd2592c02caba19b9c93ecfb56b55837d1054b11697f8af62c706ddac0ab6e1c9ca6ece996d349a16af5e1978d7ee7506043efc07d411130eed84a33d9a967de291c088603303619905f093f28ac17b0740be1c721cd447480ab4a9bffde2cc134eed327f641498e9ea0e2d13109d5723ccfa04cf425025bf671a6fa51129b99e78a9cea44b45e1a84c785d7f588b3f9bbbf16faa99c41b431397be775f94ff2b18ff4cb97f4227ddc243f7af4631e5de0fabadc1cfcbf388261d258b91085e85dcfff0756d27cccc27bb7aa0c8d7bca3a7dbf8f212711cb929d2322c93b33e52e412aa9b773fccd5d6b31b43b75b1bf5b6e6cce2f699a9da94c80248fb17ac14699adc3780fb375735157253af87f2dfcfb4eae99a1af1f49e412a1532a8a4b8e3aafcbd8c8ea66b37a3fd999100292d5a8f944ed6722dc87a14baef45b84e26628a729856c6f713f83b3aec081e07ecbcf1115ed3c1fd6d6524e079bcfd38f1997595cf549deb4374c5ad30db0ae5ef765e133f3c9804f864b5648c37d72888e1c67bf54a295103996fe6da83804e5996cab2bc4f2ee95974c0b80f5f9a7571181765e1ae29e2f22efc5b59a15031c4a9558db646468e81393d34a7e80ca41c624bacfbf1d6a00331900eb3ba74ff88ecd5431fdeceb414d287f2f2ae245285107f0ebbe440245218657e872c0fa1a9f0516e992cb4724127c06953fde186e21b1e6ba92e8b93044d67fb45f5fb06313a0c41846bcb9c166f245ae2b53308fc5d8275bf3dc1880b9c51fdbc2074a8025e64aa2d9b8e8fd99efe27f8205be25971eff04e84279fa0c46d6c54b03c25f134fdec103608497c6692ea8fd3a9250817078e326a9613f6c30a82d144bec8b582c9dbe9d5dfce55b8c0d5570c62ef2916db24cfa4b945dc7eceda99c760b29c6cb1261da096018c56c188715f11a95b85b9c3afb8fcc8ace6351c8f14ddd6bc2d9a4eccbece6758cf0a14f8e5d03d2a1c6755652e23ff33afdd0eb07dc3050c9eb7102ec34d86953dac3a7df4d9dee972dbb679a619143955c494cdc0a75c2d1b2f98aa57f957d1c3326dc0297ef43985ed491d0ee74bee21f082cb67ff0a5ea1d9109613986f8c20393c4a2f02f2b8f060c6136185d95ab678c7d3389df2893c27390a7cddd16b7dc4f6e75a3df603d2f3c027e3c7a4579a6f26d37b1b0cce11cd83e443e8fb720ddd519cb0ded94cd13c1b29046bb9e39d44c71ffab2b18c9f9556cf4fc0aa1b3644a95ce2ae5160c99cb36f1ade7c7f810d7554a4ed99427c4d5dbc4f7f577bb58f32eda803f641195b0386c4fe7ae90cf0eb9ec51b6e15b64fabf2dbd12dfdb27d38813986802cdee6d956db9a7337b19d2490958272e503d4639c555fa7d2111807ecb1c1b1d679c2e32122eddef06df590a3a666f032158d1d50265e5a1bfb8771daf9314569b50821940115be76c5555197ced71ad178c0465ddc803a74e96cf9a3a892c9fbb9b811a9cbba26257b5eb0071bd6faa95621e97e156d20fca2a5209a8e6a1f131f8ed82237363ab097191dc3646f463b97ce46be44a11b606bc5611b99a2ce150b1c2ef66dfd9fbd9013b056f7be0763f99bf11686005a8a2c83a1a355aadca80a05228476287088057aff6cb8bcc38d908afaa5206b65f82e85759fdf4739ef3168d99c0fbdcbae6149a10f77f11812752a03ed58f327b03f3e32400783a05b5e2204cfacfc16a4f545607d92b52e7e808da04fe9f9b8361b99590b9b55c5de08ef42aa6a37c916c75dd134a781bf2ed35f4bb5f95a87b5a33404fc1ab5041951eea34f552bcb7efc8ce1c366d23016e76dcff663b560646e8fd4f8a78235c8f29b0714f5a4102b7cc792c27d9fa5ba66dee550d4e79e41af3af2b7abcfc2bc7b7c44714010936a3018500cae8a533876b96c5e043a137f8708e51ffea92e6cd3d0d415a2349095888f8dbd37a1be68a3c13835c4edc21d3e7f2d84afabcb027f0eef179ef5ad9e5956973f8f86b360f5b3a9e12e59e6d4bcfef6cfae6df57914d95359fea485464c43ebff24c04e86cfbc1f306e9de13aa06db2744f5dcf8f4b7d2b28fe1537848d781fd7be52ae373680f3b2d9f6618c762a83a2d2ffa26adc216cd1c83f518c78e1e91029630548abe1b05e01b199eacc7ac07c921329a580ca81b93a184e82c693f3754a3960675794b32039df79da01f6766098954b50e87b45e51b9d48cf86ad86b8f4abb3c76c997384a40a9359c0c40d9ea82bc955eef8f336985165f6c13a69515108627a07fc92a602af0d250b1268856f832e1851398e20bbba0c6cab18d56f54a15d20fab13c50e4d2570d26b343842e5a5a4ec4abb1f313f6dbe7618d817c2c004500868a4093be6d8952bb1f20244da96b086be804f89eaef9df0f3bd5058225238d3e26b9c1e364ea3e83927c3241b489c1a6502536a2c157e77e21cc9a7949a990f45491b605c98ca6f5631c993088bff723f19dd65a2eac8a8673543e77a2461e72bd0979bc372e8f894df4c6ff8ab05cc7e0eec15b41416affecdb739ca5c96c9b220a2c14dde91efeaf049bb37276825362d5cdae15b50b97d788484555291a6519d71ae29bf80879deba8567dffe00ecd98251af13bd841b9df8ef509edf88fe3ab4893aa0b0de23893e7587c980c50b4f63047e26e4301a9ea35744f72c352c3fbbee677176e5b4071a583729afb690b1d237de210e4aff9c0db6d61cd5c714c6f806b0f94be537b60b6367a06d234c924129ee9c8f28aef992818304ffa0726c25bc24e38d86c2ca17f9480703e72c0c0bc2e0a56abf335e6fd6e8769d2126af5368627eba11ae5a8f8fa5990f461b667be23566b2cdeefba7bd60a3830be4d5075bebfe7caf6d8362c7dc221681f593b33cc7b9e45c832f1a502d5f0e0721d8bb52f4bf167e26dbd80a066e725d9f6cc6651cc426b07998b844b223b3765f557d5a914cfb38a25f4800ee0ea66ea7ccef799c5e821cfb1925342b5a1323edc0dbe5711242758b6238b8fb9dc855cb4604be18b0eb25c747a971a9d5097c2f04019f112dd63ee97c356dca6ff5cd87ecca68387eb8d8c288b76cb39bf66545cb1c7cee884e1f16d71118c8d826f63c56160a023d05ccd05437e0414f768a22bba27a2f194c2062eb0f4fe98a94c5d2ac900cbc21a18c2ca0aa2a56e282f41bed07e9f63e3fbe4361db90637fa77273727c8811a37fee9dc7fbf7f8c317b8ca5f37d6302410c04e3e59b3db183b87314597db326b8c64a6b48d277e0c179dfd3d091a9537d89c0a9c15827cb704fba6edaa43664e01325f658e4d7b0f5f372c0a49031a9f0c5395811c6fb7487034327dd464a3ea125399e05229658b105c905f2faa6d4f85a765e1a6adf930e6ab2f3de8e3a2a1c0a2c40248f07d4cf27a73343df152b2554a80af1189463297ccc2ec9feeb74364b4a9aedc674795e8fdb5868904275e0fa4650386f71e5195e2a62841887052aef3d54dbcae581d00f6a2b0a6f507176b5660d2852fd1cfe0dce8e9fc70a01bb8b23b9e6260d8872315da62745ccc9b14cb67250f6b3ca3162f7ff05c3f11d09815a41a9fb5c2d71b67e418fde348b9d2edb1e7de14653a322033ab2090da2fb2d9deb1c49519fccae5134e15f27c1c1ad2a67aab28aceaa4e26f40333eacfcdc21e0c314c7f898c0f8242040cde704c7d07c078d350045a437f310e40b5747a135f3818c25bfb3896d60bc8480d8d4eaf57b57eea97b2fe20ad774d6b9d631c9b7090d7a8661d9af045f7c58bce4d4984f815da538d9bb43a3f15fc05c07b7805dbf4a0d47cd7bd051a097f1f050588906c123f123e01e50810c55f806ffa9b3ec36990ad7a45e619ba349e18905d937aad07e9f54e2785dc60d8f773dad41f6b322d9271d779280802af741a46e3fd1a238b71ba87bcf9101558d076e298c7c99997ed23e9668d2c0e58ced45935c6dac71dae025f3424dbdde41a6ecab26c45a633e19cb12b0b7eb98d2af7ea1c4c320adfb01722fd05792e045604478c8b3ca70ca19d6d212a83e81654efd0703e651263e2e76d3d6916a436c22d61cc358e13a6504f47eb79dcc3957cf376e6065898bf48c3a6c46d54b99ee8bd97bc0fd8b5ffbbaa1c4f7e03b6d4df3791492f306e93ac2866c13572551dff3cf207bd8753a03affce93f82ca72245b2b9586037f668bf9554fe8320b0d09444fb8e9edcc38a74491ca1ee0b08b3de8f3729fd21e472d0e926adffb50eba6ab43c293ac957a1eefc2115fbb628b69fc943eff825b1d1498f0ed05980741b3505ddc15a1bf1a5ff029643b1ff129ca95059035323578ee77f12bef1a60ba39b22ab782c3885ba801ae23ca5b5f90daf87e72d3c9a024d599feb74233fea6535bb04d19e88a42f0e6440821f1373d57389115a8868287c1c7280fd87b9301cb9ce808ae5a9338b65fbd3abdf2e1c28016aabd937ec0f9cbd75648993a6fdb6fa4d3b760cab9fe8ca18240a55e3f6378f71d67bd73d1e3ede7bf09972dc5055e89de5973c9ae7ade3ff108aec22541714b59f17df95cab023178350a52e902d3cad6be693e4d6acfad75814df278c46d3115d91cfe3047170a6b8785d483764e70471ea4c48f61d83021451f1c12cb339360f520391d8b9c681db55cbd4199e93dbe04969af4f546f44c8475cfa5cd80f5b9d3686b063320b2e38754729995cd6ba7de6232adf9bbd7f7b2dcc7f63ba1d14542720a57f6b6330404b0e0a0a2bbf0933da056b5d516c43e4f79cfac9234ed37566c492b1de19694c818541d2be82ef1df212e60ffd7bb92b5d01035b86e9bd2550dd9bf273507ca7fa79e99aeb686e9791786a9941d5cd5c814e8e278bbd096f66f04e63401429224389cfe6bef1f362330162e7dff8bf5d5e2c1da96e5748d271bf38792ec6aa4ab6cfd2fe1bb1288885edb17a465829179a2daaa7c55b09070bf4c04f5dd7405c6e45d4056e8f00111a2ac25a9496d3b4ab8d095cb5af47690ed9f6990d5a739117ee492c6f424a76d62edf4a4c8d8fde0aeb2f7ed22cd399a2ef1d9015d594e26b155eae0a78eebdab20386d7f64f14a34caaf461a1d649fc15d183733f543786e09c5fad1284e85f75e72ce69713a64ea1f6008809509978dabc2cb7d135e2c910bd66151d2e1f76d63b9ca6eba747aff4d2f1f515a7f7a62e5afc4de6dbcc8d207fad45de68be89a72e674eb2da0caaeea57c3a14989368605352f23a9179ce3d9ce4040739e87ee449f45201336065defe2ebb64d48fd9b56ceb61c94acdb0ade0af62c8d372db4fe9d69399ea9635131746033dfed8528d0b4bdeedc813ffced982bc1c2867322c24cb77f0fcdd179af4209ae55577d59f9ae5979865d46001e40f94b4b588c3987ac0160ceeccd8e009c3fb7d3cf6408367159a33ecb9db74fb8e4cb8e2bd2fbfda1f6c3ca6fd89b1043c20826f604bdd2d0f1ff968c4f8ea9ca06c022779c92356387449b39a14ef9c305adb77f3298fbfcfda7351925a565b1b9ad353bb913826b6b67d81c0181e7e479b4dd1fbd79d3990b3842aff9880ac9f3c16fd091debe4fe4454ed18c068cd88436a8756770c7b290c18af8558089b49ff91ca4b590666ea140e33a6c45bbeb5e9b6116902a05585084083094ff0681c039b2734dc1f8cd6f09cf06d6ab41c84fb3f50eca57f9d354ce7c94194db3ac5d29de9dae1b943d7b974090c1d738df4da46f62ebaf0630679127101e2608bae0e29ab48757bf824c4c496c6f392b592e6152a2ddf03325afbf0771f7fed355451fd8d7ddf4f865389d745840dc1257bc510517a45bb2238149553ccde2c1f19f8b267f3252ba7f24f002ca33ce39867ecbc93070086f9637886796ac178775e2dd77412f19bb3e9f96f0d1c5f751f9bf07cddbbf355c1523bc823a872e1edecf5a68ef822669a84e615b2fc96fa1fedd938cf9ef9cc983c9259242a65ab162159b7f2016d806e16802baed9c3bef52a215b9475f06550e31ea9597a49590a6f74df6c7063a885d0f0adbc9dea2b43c7aacdea8fedab60436123813cd906dbf5548df83161f967d76f9f31a072a0c401885d95d670c27fc1ebb505cfb1dc5da5bce96a0fcc90ad0b0f48db80e7af8450b28ec58e735d8a6b52f2140f5089d55731dfb970a57ecef108538926443c519403ea68b82550eb4f377c1cbdbbc7cfdf49a3b87039799807d0a16cbde2b0e7ecff6f5021c2bd43e2f77703be439288ea8ec197b2cffb5e83cef8708dd521148de35d831a3a25ca2a608ce790b4214b6cbb4054d260578a61a5a81415873809fa60dcdf7d75e206aaed7dabab13cc880c7c51eff78da851e888c5bf9255a5fd894cf992bbf420f119f067cc420693afae6af1ad3d10da9b2817a10bd6af36ce7cb2aabc2e09a47cf3750446323cc13a1e1b209bae05baf2a218075e75dc721350892fa71ebaba37191b43a859805576bcf88871e31bf84d24968369e9e902b0617a778b585c769a79ba69eaa88ad2e901876f24b8ef6d0ec83be02c13729c6337838198848fa1c7d04cdf21dca602e8dd03ff37ad266a1fddc02a5b3885c3f183cadb8d05867af1b2a5ae191107ebeff4b5fb4447ba1d638c3c8a0ee543af34c409967fed2811eb44fd02f266e40bc1277a650384cd1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
