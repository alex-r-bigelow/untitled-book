<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8689738c0369cb900bf0a8ac78a86758413bb2e938c6068f9aa82f3e70add3b9941e05b846864271a61c93d96f35aa91d2fefac4d450aacb8f0d2779575e8dae4986b19e321322b6e0955f5dda78bc394b6e521402a4404808869519421ef009dc15df580b5d740ca08f827e8de78ec8ec9ac81c2bf1292680d358e3a0a326c6f38f68216fc2938fece95bc1b8b6cdb6198960f298bdcf7014c296e500f49c9785983a12359463acb0e9cc4c6c416b4361500e8fa00682e9f861ec8ef95b1760cc1f10c093789d212cfc590b3d91a124cccdcdfd302e9a8c9010eee94001fb0b114a3380639ffd97c76f0cd1bd55d5a791848bdc945122e1659f633fadcf61f9de4723638682042e996c3d693298ce08d482925792d0a23a5e5fe5a7aa005a6a763757ef580d59ebc346b5212976f0272b00b297ba654273f1914801e5b5eddc6ee90793a5a42e282daab336e48eca0d9b9e5adaeaa1265b8612de8915fdae6a95a5c8a0167df4af25e7c29eff804d31ba48cb336252ddd6c53b68c3f499e39d20d2ba6da6106fd5e504b7e3c6293b435b2d388917d166545d2329a7395e25a46ad09ee0400dbec9cb6751db98e4a6493ff8a7253ad30da70e976f61823d2649652728744a60e84988e06a1e3a5fc0de4b6693341f9e508f7fabdb4047c201b9245d0be00206475a6bbcfc787525c2f52103d74d57b41e3fded09f42084a23b25a490c3b29a095c05eed79996af10ab1bd86dfae958f5672bcc4511eca0178141eb21bda3f663d858bbf3b9e36a6be6a3b3fa670cd980a4d4ad812751863988f9f0d709e2b62e67556b0cd5d9576b7caabdad08767c0c84e9930e74cdece9e744a9d9730ed1b1f057e57a2416a0826cf12989615a5e17861ce860fb9a9aca459b21e83eae5484f44ac54cd8de5ece659c97330c7575a5d4aea087e407590a39b451a87d6cea0dd017d14fde731a57d3e16afb0ea0d5d68d52b42d683950f962947ecadb786f21593bcd7b7742341063dfaeb100633a7c1cd516d586d620d639f09d87429039824f5eb3162f9fa1f83f764cc0264661cf890aa87e8a1e889d3f7ff5236e5aeac765bd573046762aca748caa06fb33985cdce15a5622ab21c93786769ebe11ea060abbeecd989e6827b8d44e900012c8cda1e20f095e1fd7f6834746f3e0304b9e5c9024cbcfcdfc84024a2f3ada636dbb44b54873dd87a49744795e478a2253cf654c71c6604d164c3914d61265003988c517861ab6a1ab0782a9a5a0ed4a0268136e566cde9fc85ad47e221ab7f16a2413a65bc4e7d38cbdbf8631166148939aec5858803d065c4bb2a6730f3f55fcbb74436b972ed31e1f1e972d3a9b64ca29db16a12a5373b693a65672e726a78d07b867ccc8f79a87a075929718c56ef917945aeabe648847968d97ad13e35ca1de0af99a5f3ecad323ed9f2e139c0c413aceaad3b97efb56280782eaab1ecf43d5f70ccc2c71e7a0cb85f63ce5d6f5d76e116d50c95dc8c9996a26cf2b1832fab0d5a9c00fc35dba6c5b99d826f29a38c5d091843e0847e04cf042f58625ec02962db319912d7af31f7889ed22f051780b774157b8ec57aba022d0cf60356f6838562d24c073cee12372cebbcfbfc477315ed0c4d21aa1e761101e08cda2ea8fcf565aa09510791c7ec761ebafac86bc3cd4ddd8b55895377fff934edac603e5deebc32046eed2bab8a4784394b7c888fe57bf9f685d2e35342c668abf70acfb24562608c8302c227183b82cae50eb2449910192c5e985b1faa8cb542ad527fa6b25b3cbf39ae9a258ae16877e457fbadc7ba6eeba889569189de6c850fabda1d685d7afdc03fbe1753cea2afa4e9d0efcaef21125d10c364b10abcda8172839958cacb372c9929b511ae1c80e101d3631a8a96f991ef0113ca312bd62780bd1f160924efceb8367c5acfe47eb34de8078700fe80b1f7222c7571ed002a9295cae7d36762158d45ba1160f52c3cee696fe891b140587133449772122d8108ae4a778b08808270e2c6659dd58f835e9afcc6084401de543016995e9b2c6a1f338450ee36cda03906195c2c62b4ea39a41f120b1c1d4615055a257cbc7c035e5ecbb3fcd4c0cff6b801e586ba0b4c961ab51b4b3307d66bd94bad4540a2e61e6c9fdfdad0764fdad707f5c729c57e774e29f41cd0fec5b45920b9dc85b75cf99f360f402d67b5f5b4fee4781a8616e224b5e66bb2b0efad96a41ebfdea1d6ade8ae6c936ecbaede71cfbc732974cfc135683520780c67a75f99e8a9d55a9fcde26c05f467d24fd517b9994b1a0c420c6958ef09af4fb27972cd5c5ff68d0b1d6c17b43eb0eff636b51857efedc8ffda7770d4fca9fb8d1b99f15a328ce84909cc4bf541f8d8873179b9b6d6a98341b884951d1f2fd3f3ac32dac60f3a401371616608bdb8a57dbbe95571fbae3a06192e83f0a190da97c4a85b0956eb4905b58cf871335d8574ae3daf33757c17df135c9761545c797ff7a5ca4c8b3f60c6c95f52d7353fcfb09e82ce806b7544923dfffec68290b4e913bb0e93a20fb85d3616948c027eb8e39b1d9987a23267795a2bb3ed262e320e7b15fe5b8ddfd29a6bff0ab825a787d5ef704e5f271000cac5e8d95c35fadfdbdfdeb9db7a6719d997f5a3cad122e7da56b34129bc50dd7e79c197c5b8269f4c46e435c0d0303366d516cdf046e78f2f006a106f795029e46c2d064edbf5fd309d566b2fca5878f687da63bb3a05311ff6fea19e93953d4bd2d5017cedf5654aec4f74a74049be791b8e25842d211500af44c35f7459ce46708198c83b0a7ab01bab03dd4ccc5f35cb9f79bbd1d71c0a91292bfc423d0b02ec708984c1f85962a75a5c525d24ce55dce47f165dd77e483c3c804ad6515dead6f7214cb2b78f062596c378066eb8e3e1c32f992bdb6b1df6460045240c6b2f84b291fa50d1bfa0482c20cee44ec813f43e97ac3b006bef0364093d1e334e352269a30359414ca9aa87837a0eeaff3b31362ca9d381089d44f7c6fcef87ec35815f18c2414a1089e76d0e2c0952f585b02c58cb703242740ed6e37391c8fb9118b0f5e0d4da324fefde1d7bcbe0594327cf0d5c35c308798c800a57fb3df185cbd7f49ea85bfdc92e06dd259fcc393406363e51b0f9ddc2cceeb0cffb0fcdf99e0aa2ee240ef9778c960b4f6351e88fde2ee0ce95e5b815d4df2299b507329bac396b9bc1e5d0117f4674c3615982f90692724e4c10978f736cf6bf01961add8b8af9219f104c556300b654fc773e779228d32f5ad285e9a37d4173614f81056c92c5c05b51ccaeacd52ed5a52533cf0fc43789738000014390f30c2032564aaf70598c977879a2d2e0f6802277e864230180a720ebb07d48cb4aab42f51d675bcf965826785c1c543bdd20d727c682242f7eb4877a6abed2f06d12570757d4169c270ec84a569efa43b919bfa1a2f325ebb3324d4e5d8d3ba1cf83a277cb5cdff61d47d854ef7c1fea575abbdcc1333480963d2a9aaf6c6f6cc013da766898b0d4a3bb81316258fd2e2f7e23192fd93b2d604ccd7a292ac3c1b690b48d8501b3bfbbdc50396e586f68592dcd8428227c7915073ad5217a93a505b6bc13ddd4762972808892e8c3b41a358b59863299742bf9e89c2d9a6f347e0bd7937132fe45ecbb78f80a75e20043dfbc0bad7b1bb588e6719d2241dbd94573d6e9bb4ce8a510f77e39ff0ed8a3e1b3288e90d8ee80bca331ae087f6d2b4eccc33cb8531b2d2e45c775cccfc88b738d3fd46d33407579108f148cf49db186231e01f76d9afcbf719818c1d141a60c5e05045556232f39e0728427ee964db66390debad09f39181b49f832fc6db44da97b6213b7485105cd269bf5fd260947838b60688c27fb566c0e847440d99bb144e025dde8fda6ec9657c5f45c9e829058ede42f0b7c907cc43337440201377929e7a41b2f0c0eb93b27cbd543f3aa8140f89f59762443b77a2001566f2fb14dd96b7a65bd265c610ff880a02bc6949fd710b7ccbbeb1bc50611f25feec861d96a5c96a5bebf964302758da7628931c73174cc7ee3e6c8f8686e62da0ffc1ad85ccc0d18ad5b13eeec77cfab5266cf11798f74bd300a9c8b9965c91c57156cc2bbcc833f5d9872a77ee8e7f0eefe3c6bc7b2a3f710a9d576d7bcdc889456312f9e296ee900a0ddc7639b39a20e7c4460eb5984d4048ef4eb6625b248e67efa3118954399a774c599341a35c5516fdfa1c6514184b216a6d20fcde48aae66c524fecf3fd1e650f33a7c6aa4dbe5dbb7b70c215b840607b415df99b404e9424b8549d66e9d4e070d45bacaa88e779fc6b2810d7a721f21cfbebb35c9ec8f6ae5cdc1a58c1b544d265d4093e3766bedb050214ac0f6d328125a95a33c9efa314fdbe1d702ec77d735a0c652d89cd953ae72f9d0cac0988693f022bb9b9e1a3f093819317d37b34eee5df63b5beb67abab13437f1bef5f46cd4ba9db5bb79b5f12ec577d048a25ce9e7aa5ff06e5762eb6850795441191bd8bc4882a146e7bdfa63e72938c38214298654b2d65e7fbf68c5edf6bffb52e6fd9b7af17f8fae6d4ea5f2d734ae19fabb144df0ea84ae1b5b1e75fd3a58e11d07d93c4b0d3ceefab963bc47346b6b60856c634b37f4fae04b4c49bf5b17d834e365ecb41225bb62d0715ae5fac0634879ac29cd0eed467a558bd90b290740b989cc0b27994b83d73eb8a7b819a7a00a87a341c70f283002ade19b4dac4aff325bc8a201bfe8d846200f325b0bf4855bd27bda85bc14684843245a55772febf22646df4480fa812ec7a73da747f1be1280ba6723d42f25cc4d647c403351043f889f82445cadaa329148a14436943dd0f9fea9060d4f3cb41c306350e7283f4df2029dea0e52d4c0fdc646ffd880854b50370e548eaadcb4e4a23ecf33ef5d589e1f09b9ae9982d089e4d42598a99a80d1973d161eba743fb30a86e3cf70e7ec04596075efb3ce7cda2f0e26558f01a6294461b77aff60c032eea765797d39c8da0241982084f7795db736345a696605a5c6d9ba37049602b2dde3c83693601e318b32d5b77fb9d098d51b4e3fe6efceb3860031aa5dd780113081b27e73aa1aa804adfc35561fdae37f8980383a7a8e3ff592818c90a9eecfbc1aaa71e1a96c97af1113ef75cb9cc4dc0263228b779e3fe6e54bcb4c896f9946c8272b4a07adf8d61af8d638ff74c48ddf821ad7ba7d060335e271f25babc3edd07222b840ee4ffcc8876d38dd047d6bc5f60cd8567426850c61ac4202b02383eb24525be1c3eb3d74f1eb96a6d32d0114dc68ee0c6128ee352ddfc36741ee8efa578d7a6c776e75aad7a13d005abec34820a9653a339a38e085a61c7e1544e471c8be7feeaa449930b103e20f53f33efadc7a81056d4ea1dddfe56428e3acf915cf3ea93f737b328922f09a903cab8af5784b56a8e896526ff2e5644c5912a4d2a7330754ba059efa5d68a98c5a46191e117909a3216900f2a1d7a8653e80a9338786e4cf780ce87a2beda04d218c63aaad1b908b9ce960b75bcd9846d470546020046d345b5a9f725baf6ff418f4c6e1648aa317cd59a38f500ef10412cb335cf59f7a38e02e21c2b147855d5d1eb3c3442548085fdb5b43cc4b631fba59b036ad90e7636bbeea915290d16e5f33948324b607cfcbcbe7952119d47d7fa996276aa4791a471113f794bdc5f38ec35871c734480ad5ec65d9a81783624f35efb150933c559434c1844f5ad57b92d50d3cc6033c961fe4722b0e1c9f8aed866e0e3fc8e3ec3e0b03f2a5c6ba7b8d53d3582c52b2fe6a79073c9ae2832907054cd6df20b1071ecaaefaa14ef826f0ec556bc7e651ec16fd0595164e23db48f9a65f5c03b016c6ed8f575db7a1fe4b002ab0e619b9566b86aed5bb56bb75508e1eab04236c9e2dc8396688b53c2d2043c4bf567572b3df6e244d745f1d78a268e076f896059228cee297f1e3f49127a731316e4cd7358e1e0390892311e8412fb25b6b00378d6a9ea07bc52c2c4c93aff232bf7732e30540f8fda2510eea7f5a834a18ce25e5e77492b844f1457e9e3fde3e7bc30595a6b555b7bbe3f6cc7ca6b15eb20bbb159b40816374f808b734bd6efbcdd1fbb96579009ce51376bef6ad9f6b919f076690bb8806077d85300c6520cd05ac843250e22c6b275cb6239eb69c7658bd0755442e703233281348d86413841b621ecccd2549ce52205d902695cb804b86623f3697a8c95fc6eb4a4d22fe278845b6d5c0d89b0de914ae8f0a5f2ea5437299a6a66d028385686927bc8c9b0bd3f698d574d353cc4cb4be07e0c2ebac7164f33725905f8017ec5221e7f7b3643960913e87f3ea51180e432e39d115b606ebc41ec77ed8804eb2a6fbcd6aa22b3141b0542d3452c407eb3eafa6e19e44f1fada13f2eba5844dcd7ad953beec9205a6a933be325ce3a822cb8dcd29532e2d87fd3122ab455c4199d6831111455c282875e7780ff742c3ab08d276ba7ca9adb1a11677231a761d4b7a769cd58df08d32f610d0a9865156137195426c052709256a34da68deb5cc5dbbcb518a82190b35c0ea3108836fbf131abaa3d88ebb0e232fc48cfb2e9412208f22fe5e5018850665dcf0ecac92fecf9ec45c1ef7f87461d2445e519b74509c93c52e735540a00e7e830a64acbbbd59ed774bd2c2db8a3c81bdb55e7bcee3ca43561990ee89892cd1781333f87be24fc8d7a6f61723c63ddb14e7b19165b8e577bce8d20c86b61d65c1fbb3275a59e62072a9bbf5f7bce6c0308b6f99967fcdee354ad5e763f640d5adfb97e25c3bf6e1e435b03dea2f62a5a58ca6fc53b97572a5823614d5cef690400c109b6bc5c96fd11944fd8e5bfd5585f1cec31f6f3f190631582df613464891e913ec4024a8fe78dbf81cff8b237cb1c8e67d0b7b0c606103973c40902a793e2affc0a24f67b33a238150e19b85fa52dcb0ab7b730daaefa91cf61a5a041ea882620c4b2c8393c53330456945362eb6afa3e743a53035eebe3d6350457db212484572b68b60e14d4b931a8eb9b6313da975be340ed625f9711d1f42cf9cfe739b79b45b83b50d324daa1c33cc3d9401f8961a9d8915a7bbeb190b72cf119b5705c3ed3261533b653fac43eb04e33e472bd57c3aea21886e5ff1ecf0152b3c5b5f3b8947bc7c18b15001e0e522134066bcbaa5b37b8d64ab64429910565b2b5fe56aff30e9db426fe3d74b73463f43fc8021c5d24445d02ef46a0cfe74b5117cd89b99d668ad2b77f2ed8c909527f1dda96660c2d4fea5e7096d34d1ec25eea7a6cf1061fb986f2ea9f3b71c48483e3c12794e2f286156474a2dd255513536c736e34bdab08d4d0f61f84d39326854bc7b3e73ab3a4a57aca016df9dd6f6ba2eb6f7a69681ea38e49ff8ce1e9e7edb671232056eb91ba1b56bc9bbb2a144c84d57208d57722ed98170cca0c51a4703c6d4721d807b9606600725136b5fe1c89e0a3a9f8d17952975621b0fbda1739ea2fa917f770128fe1207b25266b601cf3194d9195eeb41629f466844d3fa6b9f139014875f7fa47165a5d04eefae29e443c18b463e78273eee9caf566cae939b8e849755ab2b9f71671ab3b7a00817fb6719f863ba3f59df6bff514c4a8e6880913742872a087c897c42a5ac44d37d34b73119865c63cdba2481572098f73af9561420afd24b06f06208bf4ea81da5f7d26b2a8f74e92527e90b83f1c36a494c94bfa3153cf051ffd16271276d0a6d463b2b3816b0678bd207262ea1b26d82b518626678202d971f24b2fae00d70d2cb7589c1f6ac71830a86202bb61962a7559d7f9c64ecea207f8e10320435c334253d076e696ef4274bc960d0937cb05ba89c188cd44354a5e6686cd6d7673cdd47012777da3b628bd41dd3cf6e8f12e68e795b17b22839af5cbd0f8b2d09fee36051fe96e202645f24ec64be21300eca45aab2b510b6fa36cb0ce18470b583cd229ccc1d6c36556bae0536609cd863e4ad479f272c9217ebe633ac1d2c1473ee73e980c6db99a624421357e0eb210f329f27ead9fc7351cb801dbe300f605e65cacd39ffb3efe053679124ae1c9b6d994068e4cceace959ea590369c2bf1349c1d86bd02174a4e6a6560f355f0beefce53939846d1952ff5a3a1eeae801a3e8b9d653f919bde875a826d02c154219a1384a1c7c187881f9a0d739456081c229e3bcc67f922af538035810313361c6d961ab0e22546d08be3e2343021ab41f59519c1b4872762524ed9719a833121565150751c525afedd64c2e5d2e69a879811f96c82867794dc5914e6ea25cdf6a9e281def60ef9453ce425e758f293330f123d86ef4a882a7884eaf5df1707cf59964d389a6b6bd925cc918b1ceb2d1d81920f7d64356d38b72696002aade63cf569737b6fd3a147670fa6560446e80a01a47bd2e11b886188d1d4ac4f71d3ab9f8f92b25c4357eee230a1278efa7a70dbe9bb2b234f94d7a3865653713dfb2411da96e8cbc80f09d921d18afb475b4a4acb2f15c4a64e6f1d51d52035fde5713c9cd1e1360d323320d6ef560069f27034bf80cf8ed21d06678516c642517c502779171245d0364260649cbe15daed62a32345b83e6ef2164501c03e0cf49dbb40d6c22763d2b54ea6b92b3d6da302207fca380360e841753a7be6d86f3466a2e052f91eb6ef121de3af66cee65d0924df734f54dc5e91df679cb33baf8f6dab6b50e5e3d47d0d742d809e770a73346dc24fc59d0bcf1baa41926b1c096a13ab60d7a66419bc24764720d0a9477f75a7b2f1d03263138a2ed8198a8cf2c4ab79fa95a80c06c51fde4780ac0ece2093449239a12777f95a560b1229abbb9a0a01bde7640387cfd068d55626ad120dc4c1812d04ef8703df4d62b3092bc1c8c7dd94aa43470781844993b9304fee06f8817be0da02d48706aec4252797f2d3d01fa197c88190b95ef351ed65addaa42ee065da569d7bdef40b67dc7f987907a18d42c92ed42106068fe27697f4499bcdd170caf783ae2776c5041f6378c5e7f9324dfc02c864ab239a6849f714cb72d9a7a6784ee4abd7bfe7b3d605f88fbc22992700a1280701e8f219a8635fb55e6f357dcc7debff6b46629e00a74e856e1889e0a639eb3a9a2ed86d1b5ed64f77b379b1612a9b8344544b2c3a9a1bac4e94e2e1554805974761fe06d8fae700ae74bf0afe2415790ae039f9a41aed8a6750f315b3825e3dae53dd8ad196d88b6e8c6a5fa148b553c944e90713ca89d45cefd90a6b554232c7a62318553ab532541bfa1b6f807b42c5abc29e7254d37787c3e5c9e4fd2cb7c948bc689a25b2328e2431e8eaa911da92452def130b4af61dd3a031b8bf87810a761a45ad3d36aac59ff06f90879f2a4a88eb52483a33bebd8315a8638289bac3acaf406acd2b11226cce1fb92d3af464f536cf1aae85143e7aeaae05309ed1ae42c7c50849a64f1335d6d1c62633c6e0ff0e1307a6c3f2a55ff473c41374c8ea6f180615dff9f259403096aeb5a4787edfa94213b0ab9cf15eeaec65e60c5590ca411f8766e124b1dc64bc859b46750b2e97ba70b7657e930788ed25ee0f5fa4196ae0b89e8b8d78a9e2774b076c851b8554941c19cba3d7aab098f2627f56e8767160b27d0f0ea787348469de0d74b4a131c2359941aaf80c08ea919b1d9c371702a4bc85ee7b01bbaf34bdcbc15b63996e7d3d85bd5f01f93490baebdb780af1b230393269720d97fb5f0913a5a9614ab12a72f34b73d6315600ddd8becaf2fc2372aa919037707b5c3052e7db48d0a78b5326fcb5a481558a821f4c2473cb791de5cca4c5a347cbaf9e67406467cb2e73b2fb0305dadd2e2e7eb297c6ec21a05b5faffa6a97e760630efc7ad502f852a5055e9dec25441c5e00eed881434be440b4853bdb480b45f13963b6a1e29bf09f23fc723ebf9cb7061bffe74bcd906fa27bdb24258c0ba8c6db48ec008b70b50ed559464d2b33967de32422fd4e26f8718c325cb4a41c151d8d89aec3c229a8a49762612f13ebfcbc4f4ad8b1f00a2bcfdeeff3bb86a9ae10da910cb01fd9021070c5105db53fb618301a9958db1c9b702959e2071eccfc2c371ba5d782f9596e2d271daf4c785b6f31090277acae4047c4a88d0788165b8ebfb6503832f238aada37f63b055d89bb231a7107ae919c49d7d2f7a744f01078a8ad8fab10d6e839f1262e15dbd3ff41bb9dfe1ff5563ad77dd1f30e44eb1765778835abf0e7c808bfcc8155e5f6431688867753c4719b3307fa0984c9c46623051d17eb1ead77230e64503bc0793ab38056faa01c31db6f950607af26041ca88d786bcfa11b3e72638d26a39ac95f8ff8e8c077c8316412824e91ecab5a373114d795e1bda8f9334509397397ac3d3194621813c064d081ca13d66b3e620edc215167576add0c14593d863bb99577170d07b2da25a48e4129b87b793aca8c8529ca7d75b5a2feaa384c707a92e44cca374f48e6c9c0d6b7e9a399615da4fd7ff44c9ee3f74de8f23056df383fc66ba7b35280ceb86c96544ebc389e38e4b00c060e72d2852ce132c8dab9e8fc945fc0ff49bc61796a91e6c6135ffcf6670f52f89034004637b400159ac317d6408543e0ded45696d8c65900ad546e0cc27b47988df6dd48ce223530dd66a8d2aba341b530c1aa9215df0ac8cd8c91b7580d94db1fabe87c42a76c28db15ede84a380485651522920ea0e4bdd821df5232323e46f742a69156f8c0525da6e9234f959ea08ce602ae1a06b4ca4328a3049a20d8923f298741b300306aa3c1f1e09f92108e9712c35da31e70994f3c0ea8d4a21cf69302d635a51556e63cfc213f15ec10827baf00f859431b4b6054c7f99a6fa98f7c02cf452f60c14e5e1f3b1f21f440ff7e1cb77adfeadf7ae10f2841a65e01389d4a211c0f034b2bb2274041c6eb3a5cbb7fe8c86c3dc3128a5830589bcb03d1df4d04dd2cccceeacba4e50db89cf3dba922a173557257417826c0738a13340ba6ad00833682ed00e98dc3aeca5f75566927ff1a91d688c620464722b89accca4cabfd03daf093091925177e6f3132f5bc24e972b2fbedf02b09aa0c7559f9593445c301934cb261f635370200c21ec13c33455ef44790a6ca898c9e337ca3205438c3bf7736a55325d418c4cdec053d6a8a0db43a464fc87b7ab9c9edd11422acf042c30f3ac9973e94bbae0b98938382e0e136b3b01c3c23aa94081311d31cf8bc14f3030edf9f84c19301e3202558c66757079c6d45380a8bd10478095d131447dae6d20fa56e540ef0194e6d7be02cb55a10b7a1b1e466ae28b8de17e837063e0d142b15eb579c0ecd79e1b2436fa99a0f12ca9dc140e7dab7904a1ff44d8d4e2a4f1c3ac4354c6dc7e41290b182b4e65445e16f5d002e9e0bbfc8c73eb47e74bfe7c488b8e0165282fbd023201e524cc4729123a1286b3f192fde9bbb72c43aabb89ad858fee109c85cc8f8f0eff9258903299ed179f6668367a505ce80e681cb502dfa8af62b98207646d18788aa4f977d6a921099518a0bf48ebd25bf9407284ba05d297ec4d1448a14a240929dd921597f1d410debf44d6c6b297ee60094d19b9b5d385e4a7d30b922444d15dcb5ebb144b00bbb73f4e9ceb2b6b7d4723007c0b6e7981288ec8d91698fe55eb51a5c05c31b34a6d183a914bc04fe4d955d84c8135770882e31961e4dd477ee4e26373cb768119389db53f294b33b6c1619ebb367eb49585c2edaa5d618221eb02f3e500a23483b2aacaa702f940f93ecad16ceec6d6db4ca4b4b24fc465a7d49046b97b05694aa86db5e598183792a4e52564605ab6976ca87b4eb5ecd0185d911548d3a8e9608d31a6b601906497dccaf9b48d872d696eb6069ae97a743c54aa390fad0a9ca6a6bfb0a457f5363d3dbd0b5e447a04bf3a3f224c9d0d51f2a8078abd40769876a8f9548cdb28b8c6d0f9b09a48dc2012891293f78706768ab3ff7a881f6dff90497b7d87f60fbe11490fb1150b94790e805474bd3af417123a725cece8342c2084344bd90d2f4150b323fa2ef9cfb4e7c587f713370d9292353cd2e75e383724674a62dfc09a8e1f7be8451123dde908e1a0aaeba3c8444dde3dcd74db33170bd203ac57b81cf5acee15b8eff70181d8c96e6338c876860a3f97ad251bb3ae383882074a0faba88988ddf8dbf05127e88edfccd7fcb2459d773b7119836b7540d509195352b004549bfb150b441f986a549982cc5e98fbee23f4c1645078ee791edddc7bc345c66aeb8118ab985bc30b542c18beba9eb7db9191ef16c8243f89a50eba14860953e13297648de55178fa6dc27a7396202b3a80764909e46453634d564db9143062f09fe865ad2767d90904cc6959bc6be75150bcebef738b119e2145232b05954248d558196e343b8b48496b39ad45edad7487adf606f32f1716f0ec01ac17574043cf8d4250ffd557cf84b6cc0e9ee51adbb51116deb27a5932c47954130d00d47aebf32a331e077e523f7adbc2d3394d5bab7869f81f68164ed80dbf6cead60ffe83b693b861e1e942079cabe4f5bf24a09c3e6daa2efd84fdf6bf37c732634e6f1a3196087c93453e0708fa5dbba1d5d9062af12a2ae860d3cbda74f2805477c9367148dfe59d1b2aa4a16a680360d3c09e4a6311c54e57b569dab3ca7d6384d2a721cb1068a157f5114d497e8333679dd10e1e39a18364e2b60389106e81b5ed7ed4fe196e872d8c902aa4e3388dc6bcc90344a10a37e187e3bb7cb8d225a87bcf7fa55cd1c52184ae139d9111f9f788b3eb66e2797db9c99309ff3dbeb2b51bd1f3dcb9912f018d63c57a4e6982294a2c6fc535657247a03a25797139876d08d4a846bcdf91ce39fe4327cf53ca5e2a6d1f1212b656eafe274f0700ef6a9f4668824e4e236bf180a90812ea6ac492b1c482985d99ae132ec230f5b4b4a8b2dfd88f9520ebe61a279b909685e1d8d84776218f4885732c233d8cc01ae7e4e160f031da70951108cfc5c5550e07f21d5c89990334ea6737d74cfb09da5a685a8b2623f308011a68c288d447578b209e74ffaf4e1e0b37812c34458810065c3cd1ffdf2c197aaebd52d29f6d1a9628c7d07b7ccbfa1b24e6481320daa00df19c647423bbee5a215bc69d83acaa22eedca80606ad76cfac1a17e10dbaab6638a607bfd1f9921db5ef301d051841d950b299049f3186e9caa26e29bcd5f99fc5adccbd0e4737b05c8849dd17509f2904e7280309d01d45c2c4dc201b1abe9bf0b9ee4822b304afad4e110c12bbbf60427e7e50cd71e9a290a3fce51e6f223eced1b755390b1ee86be8c4615604fc939a10d8d75d60c5c508b293d02a9626176d14115005a77e45be413ebc803d783fb44aee4bdc2a7bf0843016b402549346e5ac3cfdbdfda2b131248e29615aa6bb55dbf0a1de1e071426b403c389dcd360b69461dce56e3b29d3ba2f9ffd0604a7cb87a34bfc3b30020d1e3c1eac8e61223011b5d576d4007c72fde322ac837bad17a819d2ac6f1f9b30786d2804239afee3648ebb1942d0c24c1750aae529591d9579080a6ea246e6959efb2edc7e95c5bfd36e00b016618883ec732044e58330ea5ad7b6975b236c32ec8fa07464ecf6e7a18615dd760a27cc090d850bb3940cb18facc5c46952bcaf11f1cc09b848238a2b9296fd81d59d9b20d15a222830ae192a20dccbececcc0f8a37236165b9482d48fcfd6ea55218760953859025a72ecb305afde454ff4fd82adf2ca0e7b380749c53dcecc1996dc3dbb4edb62ea28bdcdaba94fa7172026791b55d4db8d1857261203e00758d71c6546fb355cc427890cdfb84b372157b28f9b23870e8827fe642b9b5068c44766f6c184b20cf1cbc3505fb0285703568646e4375a1157ed808838cc84c352fb5a71e354280feed36fc64d3bac4e762b66ac995423e122c7cbedcf26d5c5d44ef9ce5e9644fd6860c0c1ed44220572f6eaad18a2877e5ec18bc9f2a3e97e640b31a8de77fff4f623bac1fc71ca50030c4beebd20df568344af79c68aa6a7a16f1abdd44a38b3780d11a2827120e874b2198e2f38a0250d3b2d76fbd5c728794ba2a21009a3e97623bf140eac59121ddc13be45eff7eb3536b4ca0f45ecc264bb84407172556d195c5bc17ffa3b15d4eb1f389931f24fc87056a071e7bcc54c3cd1745251ddf203ebb5c0f65f0cef0c31fa11982cf598f0284959a61167bcee4087c4fa299aab918949f646e92093eec3d0086a89394df896214565fdf549a222249a2bb15d1fc0603dc01918a9a717d5f106d30966947986b9878f96d9cd2fefb6c9cacdc0afa3dc31d9c7d0e0e98878c797142d5b9018863ff7c619ab30ad896f70b7c38121ffcc7a3ed6ae7d12180e5e4f06f7863ba675e15b81993ed326cfb0d5fa5c9654254d38934c80e0adfa19a072cdc780f3c032d84867a5ab57aa7a962d6cc68726ab0e25cfad56f52f4ef608111968579e5da41375b2acf66a5db34ead02d32e824914b95f26b6bfff3b514bc79e53fc0b43320fea930732b547b95bc03836fac3cee45746ecd2469801437ecff9178293f86783b121d557a0fbe932baa7fcfeb764655c9b19b471cf41ad84a4ab3fe892da4801d917b973513252e478414925a293b98f0d135e4b50a7e8209780b62f1a99d7be1f4291b0f8c0205061658f253a752640fa60f4a3be7bbeeabe11a2347817b5657043caa9bc14525e16e5ff139dabcf9a4fd8c32ca2feb180393dd96f84f43901165720e0381875ffca87dac4544e30f4bf7c8a69fd8010355333e1e9a9bef12743cbb32e51cd799eb887c8c71d8e3f6d441d0aa03240375bdbb2847decca6f04d4f9f03f72959d861994b9a4cf3f93fe8e19ef84adf965093a17298d9dfbf17050c397a197cd7f499aa0918af118902a0d9a24d7e236e9d35e70721ce1a6cb745225845031b0d4d46cc4fa072b500e14e8d2ed733a4706c59e7ff284a15da7f87631ab20b71b9b346626012c18bfb1f0f7b31ea16c23895415d14de1750cbead8c1e1e53b314d4945e9d6eefb49bc610c8f6db3ba73389bc1e1192663e1d27418c7231237d190bad01424c7c878af3cc6f3356a626eb553d3ecf1458549c10f49b7d60b5deaec601cb3ff714527a8b0b5158ecec0f17ce86d5276d9212199b9b3fe605c81d9c97f0461b716a723b76d964390b73f5aacfe6d1c1a0295bef6cfd7841713a560fae3ad45ef08e1c5a95ea78bad71f4abf6c6de3af4ad96f227e22d9f228a191940204506af4f7d6acde4617d338d91ae518c09818a916a19ceec4bc68c579b8821bc4a29dda0d7e398a6004020713d25888392db711822d82e1b818637b16aa2650236a707541735d5de360f62a3b4e35ea64efd8f7f8cfc459d692b602da0ad9c1dc7ca76a4a0a67c6c3decca946f04575d53cc6297a19701f2f5f52bcdf256c83a5af9d6fa87f0b2c4d7148decd18fb8b11826b872192a6a3c9ee5085f100b86014f0dd5dd7ae628981c4f5fea9e0334d070fd3d2bbbf7c65e02c203a00dd27a288a0fbf1a38db9376eb0f0ec417c84af66094d0e577b4d068822a98f688e989b1d00d123ed6e0bf045d242f901ba1e5227ff55de23bc684713968073f4f0daba0dd18c0fbf6e6c7d5705cd87673c36dc87db6034fdf24cbb14efc8acf8525f9957a4a68b137afb1a832636c5cb6e234c8316d061cd6b31f70f54eca6afbfdfea175d502bc8d60ccf49aeb3c5003b9582f4cee0a2a34ba48d570f907d746ea1ede2e76a0a158da67b36463f1b6554aa1dec7f8818d47b79e55105ba7df9308e9d234db84dbffd1d856323ea6e53f896c82b66ad4268f050da6daa475b8925e66394dd9ed4a83277f011d04ba1bc6b374c349b7e582e29894f6a02ecee21a092646c6ce1d1c2f0f0dcd9e031f1a6405b069b2ffa5a71bac977aa40210919d7b39dbb25618ce42a498cc976fa1b891aa824b3f8d65b007e4652375bada0df77c18126ad2e6dca54ee86396bb8076423d73a89a5d9219b1d8de416babc11dd1e0c2c986048dbb73e7ac6928892c728eb952ba781128107b32c87a3e603bd6ea94064c7cbe740760be73fe48d1dcb133034056734c0d9d60e48b2113d13dd34234a75085b3c53aa7fb193c2ad738a62984a12b4b1dc3470bb5cd30d3ec386f3c516f69e1519dc658ded97406b007db8b9ff499042ffc1dede762a98ef17579b9f1fbfbe4d70fd6a5600df831c0dc1ad69e7f3e54b32bd7198ac8d13ac663a2ea95757de50b331112c2ce84e1f993555e7c1cda64169ad732b3b24011856a486fc8f7f9b278c579a9f780ec0259de08e3fe2ffd31fcbaabce9e60fbf7bba2500d3c17157ec2b64667e7d7f4537066b5fd738a225921b405c79c6114b9cca7869d06cbad06795759732d83376e01778a08960b2ceb60835f07a4caafe129b863f026829f29c7e666e8080d896e6ead33c53feafba0a5ecd00f8507090f9966bbc57e774682d21d347fd63d6255a6a5a9bedfb0a250db08a013fb2dfa6ceee7d63ed6405d73751354c0257f28c3d55516f1cf3f22af58d0842c18b9caf435c56a0768acde9190b409da6cdb8758cd2462964f0c82c03c25ba161e286824d13c0969c05df4d31bada3b20d2c833f012a154262ff824e01fb53b93426795336449b77cc271be03762932419d5f20dc6ab5c15efe4e35a279cc91ea7be50d0b1d0e6975cb9b921f1c6479f6e1aebdc8bb388c74d9d6a19ea7b5590693bf99511db3e7e16200849507923cab7e614652f740f3f53941ef0edb31ba4d342332150170d51b59b482776bc3163ba4bb6df76f5942f58cafab817ae1cb65031df3e7634c091e4913f6c8ba036bb939d13184bcc83f879ef84ac915d9d8d0f8df3550ea2902295c302e06592edfda9532b55fc38edf9250e6caf05403a24562f46b91a3871c4ba67e305cefd515ec17e29c27dafffb678fbf2ac370daf6bd3cf51c2495ff6cf09cf61d30d11c3fa1b0fe6ee8ddfed05feff3fe55ac068ea69938468d5ff641060e35cdc5f58d91f534f4cf7f0c9226a45822fe73b5cdc0be22e18869dd4db381d2345d65d379b5d383a141783126cf5082f1cf7fa0d25069a6a0b771bb529a34cd639bae71bf3b41df1d97ef88ddd541fd78d8086efc7f10d76dda781a572051523bf8782ebdffd721246c57dc02d5d9c2da55ccb6cca78fab70b0988b85f4bfc11b32fd9005a66eabd563537308156f82c13fb9d8e8dc12be858dc4a89ad2dd74243e9040ef037bcecc9018a89f1fa7604b4b7efb900351f19626db7d813b7c8bf90d6486a518ddba5aff4159b0ea424f4416318a17292ef074f7383e063aefb186e984ffb28e67654db56cce0da35cd1b6da8459e4942bcb5a2c3d70e9659f8a339ddd9544e71841767006bf67ab5d50eedcf664e59de607bb6ba41a9fd35143247a195c10f4f2d15857670319bffe95abf7e1f970663ed5926238d87f43b4d3a8545f971a4b227208951680273da0fd6bb331211f76b95138030b24cbe2d3454886ef9e6bef6c561e66559e9b6cef3f3ac204898d6cc79cb6481a988d34e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
