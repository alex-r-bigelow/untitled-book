<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ceba42d49f8717829fad70cee7f0a28350ce605baae5de63bb97f7bad2477e11eda9037bd9535b2bfd2f47f112f78ce19ce3171bf42df21f40adae12051bf2bfa09434e54aade214010a9ff431c7a77a0555859c863689f3856ebaf023ac9fb6020e60510c7ab559a43a2be6458ff29cb018e87e4d05a1fb34e7a579c457c3b2dd122bcf7d3414a73e5a634b3416872f38878ae9c99051c6e828318085598daceb66246fa908958de6fad1e2fb652dc981ce98dc9bdcf9c6ea3e9c1af2e051d0e61e5b8332b905cfb9d35cb95f9de615ab3ed8e717d5ed946b550004362f6a16a5afe03e23e566e3d19571541aa7612464b6148a39bede8c99f6fe5d4da4f879e051898423ff2520439e803d6b3b351517e917cb193d8a0cf22f9a08e80c86ad4b0c93d2f587b8a95cd356f1edbfe6e5c707f5ed188fa0752135871984ac4fa9f020c682be0b3de135d7c6f8dba4f3a9c9244234648e37a16df9ccbf458785ab6576c9d3f36f742571ab4262b85f1e9cadad18f734b4910da533a32399a499c81e798697f8b858112b96ca7dba58a4abf942507ccb42f8206b25723d83a55994189c57f92bcdebac5d6ad9d9550ac289e92f7952551d3f891a7b646a90653a670ffead20fe2b12f4eb7d7e8686bb4c2699954e6a4f4a6c6c7c92bebcffc2a78ff88291b8cbc02bd771235bb1409e3946e192d70427b015a117769e1177779527046e7aa47ed16cb30b29f20c9c2e540deaa2a624843ea9c5ca379eebc9bfcdeaac6b8a58c9c75c3dde2726a72ba98b5da5051250ec7fe56f148442a68e7a53cba4709e4146d25422b6ba05a5344ea95cfba66b80a79500b60bd649d78e293e4923078de122657e38483de8441f47a4c73cf6f74dec2a37bb70e769a59374244929497d9dc4b3347fe00f43e783cc80e358b014fd70ce1ca217f0ce6fcbb54db38932388dbfc5e51eecef163e2b12bddff5d83f823fdc8ac37f891d007f3a6480dd1329047ed17fe528a92c9a3f852cfdaa9b40c47258a1c816f02a0fa4557d449ad8dbf946d068a6a64e1269058732a14dccc2d17077cc8000f0d4f721cbd570a4157f7c13b50c0d8e5f7adfbb806932f26605c14e6a1586df3d13c8d3bee03d51b4dcae80ad24b8d4f9993e9296b9c7ed5f841cdb6935994b2ebf3ed87b4daafb281f6ef3b0e342168776b0fb91c121052620b2113f18e7d9215e0723e42a48b564914becd560e012a6c02c1fed74ceeac19000d3b6dd2c03c5bd2977d9f74ee9c258673258ca5db6791dda3430cb83e92dcbe32ed7c91645095e4f57fba48fcea0254b892fcaebb28a5e355db60f91cece85e3d1755a9c4ebdd48e516f2463adfba85db6cafac0a233e0e009609ee10e53aa0412ee3ab6286193d54ce257291f6b14ca10e4a6fb8f269379501f393ef2411f2b8af7cc69d2c295fa00b2028b85fed779a27d61949328f5909f172285f485be36ac5cd39d9cc5ab3a4d3f8ac643a33c693ce9243145a14a0aeee3d9b131a23f6a4e66884357c7935980409c97fc539de09902591cd19f532501ab7ee57e7c1dec742447db5841acb6ce102fd1a1d22ce6fc8e38fc710fe4f65fc91b15f1d87af15c7d696905fc243224f8741c1a6b00cf77792f0a5128d257c3cb0971398755d8fb70f5ceaa0ed7496cea2cbd1596f56e66994b4f1c065698174de8ff17d206e5a0898945f1490d22921def004c46433c76b23ab89fd42f01e6b2e9cef79be323f68be2dfad8586d3f90c1e137e60a19068eef60f5859a3d8d0ab104650bc8b9102e960f813fa32bc77ad7312c29db7d570e422ed8a21128dea3035fee431187fd172f70fef8ad346507652a44a3970684547859ee070f91a62e7799bd6c11f9e1b9f93072ce6ef57a08e6b09a6b75e17f7bc78d9111e68f25d432e82f9c46c70017c9e30aa90a897380e430bda965869772d8bd366d10c94e3f922277f3ac53bda3bc4dc92aceda416f1bcdf47021bac506c61849b95808cd042bf16747b092bfb1d18cf536ca7ab12f9e8973c28cca6ffaa73c1c3002dae4a352491448ffa0aecddaf2493a595b928e04de814f5b48582c8eaa54adc37bf30642540f04f732cabb5ab381eedfbe513463881628b207860b130d0c7b9cff0e6cee93d15a04b74bc37c3c5411b3f1b72ccf06a30a5f9abc5573890a65c16fd57d67223a1cc293bc97272bd1ad5af8e302162524d751050e09092397d0fe649cd908cc9165a0a48ff0dbcf4258f5add8ad681432fd50d66606716e6d456f8ac441b715b463b6cecea37089d036870dae35be260deeb709e2f2962c20b70620a5e10df1a2804840e925618c77ecee1e1e5213e8c57ba872953d427b5f45e296f1ef2cb8bb54bd524c3f2358c4718c705528fcc01c131bafa06d65c8f29333725f8ab43d4d3b7444763b6a446ab04be857e01c1507f481d494079b6411adf264715470b4a9aad8b3627f21284833418739bf0718c5e78b5ce3ad0f6c0943f71e2f40f685d105ea4f97f565036cdc39d53fd6e3ba0c9522b4fe77f5396dfde1dd754f00f2deab97a00d707ba5ff4fc13a0dcce0f111d2834ce327a49b5107ce7ed48414e103559d4efb3f175c44ed24ac426182d3b59bc7e585371ab5ee1ccc90da6151b7ff514999b61721901e083acecac57d64a27955aea5deca0a65c9899c14749fdfd7fe194035141e6ea85fd2f85b0165f7e5a8316f4bbe238bfe736e5c13b9e0664d3f0014a3b96ef106635d38a7f38ec0f1cb44f045d73a77927529c0f0720185d64a933754708fa31f2c8584d9f64cba276b818fffce1ad6f68fbe8938882f1bf4fee4b87ff3e9904b62176809d24bcd0f47bf47d98b347230dc64983d14bda25e1734bb14ea63ee42d678773ad6a56322b088a682b8903922f89f2a7a617966618d10b31693ed1d13d2edc55cb9c241afb16015eab23ce28232333b9ff2b175414590cd44f2448ecc8d93909f97eba1fa00ad8f3d4cb2ac23333fbe358226c623f505599bc24b7eebcc6fd3f3232734f498b7910ad395a980c734da85cca20c2bcf11c50d9d0af4bab861f3d0b327d092f2249d798a02728dbf8a616e31ebc827b29816b32ece6210b0fb4b2338335e056d2612990a20d0455d3457c07a3b3ed940185db69d4600759e53b13ce7771ddd4a4a313a91046d1e3d68da04e789187d34a4b8098a2eebb5270334f2f4e17e3df49da91ead78ddd20623df0a85b80183144b40d2cbe8918b0f6e2afe5e186ddda3aac40790c7aa095f83e7bc68e6dbf4a14cb85d1215260981aae12efd64bf3d3d1e24ea7bbd9accd8a5127ad06d5147d1165d1a392d85bd9264ec071707ecb84ed26e3832472012847a9db5262ec6678b22c6cf296ad54f3852a2749aa526bbd0323ccffcc4fab87456ed03e3713784a704e7ffe17a99dbd14efa55bd78a7f18a4447275a45e8d3954ee9c3a86535086e36f09120248ad5963e5c44c3b9fa51fa199306158ea300e0e3e6b1a3c1006e5ed1386cc695eb6b6ddfb109c855353339129a18fa95692f120576b1ca5e863d4864d1a42a8d1de88d4b2b929640c2ec7ad227336833411bfde47d1e8158fe8c1ba641928a85481ad461a9230bb2ec3137c72b6338161412c9811a6f4aa429ff64790079a6ebb390db8e1f9dfe97aa42e0ffed657db44a9de59fbba0a4d5173f8e40aa2a232496c6bfa6579ecea2acc4f89b1fe0bfa98e68144802ac06df1832ce8e5eaa5325836fc9c9672dba7efbfab66acf93d52798aa546eaa1430b0b39eee37aa6362d14174968a71eb242f85167fe805424e6473d55b62a10d58f22b954be2f3f2d3f2b75dbfe8f23ea25806e2ea4cf3785cbf5c998c96070b57bd8c555641539d8e4abd40294d959978a70674843683425853d2829860c3dcdd7772db7b3de8de88592929dd976700a099e273c9b7b548e090a70e664b0b2d6f29f484051dde44c37509d2507e9cd6918b3815045bb8528f9b8303e925f1ffdb80f85e944d384bc404d3598fb39230b0c91d2ac0d0ed1ece1546f74bacff73df6f36c33d27a0eea49eb7d274e6da7b9f7b2984077ee77d8b47ae033d22dcd346085ea84e058a45beb12acbc63f12c558316086bd9a8334f0b1439b4ae3004da9ad552fd12a612a1806f760da4cd8f83e50a143eee931bebb17a586296f35d851fd6f6d1f8681b6d9931a8ddc581ce6b6bddb9301b31b362216941374b025602d07af3e3083c2eb0097ed87dff7a35b8bf53741b279aa02d611798b6e9b4b2c4645431cf35aa44c36e9c35fb30b9525f3a8fe593f9984f0ce6fde7fa181c233ef29c901dc8fe566a2e087acc672ab90eb7dccdf5782ec6e2dca8487a12e254dae7a149a43b7952d9fa279d0c7e2e56b7eb29890c5e3fa5a92ecc3eeeceebd769b8ef8c7793c8912153c04645fae8d455ba272d0d8961cc8e6ff178be9aea7080906684d00e8ce4e1f122569c4185550a27a9fdcef653423d378540b5724c4f2226629be23070c20db0ea10e5058aac73d774e6b4ccf41e5df3d20f4f0e3931b4aafa9fce3ef10da0212e75a65813916a42db60fe1514ef04ab5add597c27e13182b93b04c63d7bec3359e0afe98c6ed283496e866cdbd8ac74af0fbbdc3a622081a0aefedd6f0940d58e0c6ecf0480161dfba68c7c3feed127cc9e0f3ff4d09022ff13c8067b92acaf7985b771cccaf122a8344f98548f740a30dea975b49a7879cca45a7b68ec6eb0c835eb56e02ec9283080a83ead66234563c1a12784e05d1040f9747a2244561862275521f0174c9fa8e69f744e8f778452a1eb2eecabdac2870a8bf60e28e6f891d835a00da614142a90e485ffe7cf6c9acb506b510838a995ca00c7008f90d7bc67ee0d6621733a333f321a890907efdedcd76bf2985e97e3a9712dfcc97b74ff025f58ffae67bcab7f89b586c41c80cae5c25319597431a325f6a7f65ee6d7e6f94d7d244d8479a57b8f1c5a416973e0de117b12254b23ff69752b76c692eea4f9c1a7687430a8c4c9e4399ad230f70b8d9e6e9509a29e8a9f22b2fc18c59c3e8f9ae1c3cb52f7e1d818eb3c454c3ba2c8d06a8a3e7d57bc99e8fd4e0b99012f30743b2927504ed55af8b2df2ae95a141e9905dc9c4b992dc16f31cd8908ab14574cd5e4f727fe806abe4f23e2999fce8b8a108d17e1aaf62f0be3e53d57abb2875b5637d04b2fa7f292ab16d4662867d5178fb8f094d643945916fafd27bd03fb815267ba6e7aab206b05ca6f9822f7c0897e661f73d940fd58d7eec064990eef986dd7d6f90686d3a85a4d7623c502ef10b088720bb21ee922ef116481d52308467898a6a8967afc80f62b147a8dedcf41a47b828ab8f5ad3e172b0205121ccf91d3d2bf68fd4c99c1382360c00cf5e9bd28eca5c8768acdc4e162ee8e31a777c0ee90c3167cdd1ec3e02789c46556da223dd2d0182690335080aa7f233591ad726484e41e7f290568ac1d5f70b8aad0e77c864e9e148aa77c1bf8a2b5b8e6f4bc59bbdf5e355f1679abb72b79cfb1e78d8726154169c985ecf6d08384b5eb37d3ed73541eb810848317bd7df862e299e8b71b38cb6178ba95e43feec5027da97195d48aafa77404a147dde475913834629226cd99505cc83ffa7bb88bff7a965ce377788e7b20aa9c4a37e69f1a6386414854f6c6abf090466d1267cf25ee64274cfa707db2d42bc074a63192be2f395e01321fd5b99346342a608049934b74c8daae55438ca244e98c4f70e14863c5bea4def29f32cb74ec18c0863145bc017472b32fcf9d53ad664222af9d054cc747db2b012cc29a88caa237902f6708e53c5cc8828b5814dd6c7b2dbb8b069c5e036698d21610b63e5d1f6adc71a8ed3fa33a89f20b0fc63a8470a086a665001404173c762444b132e41a1d6845d462b6956a1e6cd4e886d2ec1ecd5892449a8752842e8037bddeeb54eb0b68042a47170afeb147bc4b6995b1b771fce40ffcf8d7c58c6b67c03c2f959615e6ab90106a909908e7eda048dde8277fae4b05e63e8ca127f3fee6281960700b6330c483b3825c87b85d0b6e8cf93bd1bf8fb6dde01d92450e01628a4a2d5eb1b1688a476303456584ece0355aabf14de8e293d8da688ee2e7f59fb8a9962dff0b8e88809af3541d3ac5bcfd083f00d557b5d28aa771055b7382e5f414f9e6b27c66e62b28d7e556bb0ed1eab88cc12c834aaa3f4a9853dbdd8fba42410efa01488da36205bd70fdbdffafc2f259e6b00446ffdc70359542353eccaca8f92fd150bf3bd27ead780059ab98561ceb8a94b4376ff037d186567bc001f68d8e9f23baf16093ff8aa581e75ce5d5625783d723db02b49554a34de994343c1edcb33565a5f70a3dae2a06566969308f670f486fd4744b877148c6e26454ba4031814f1a7927210300e01b53789023ede0961242ce3fe8de7d1766bcb90c2f36771c500d2cc02295271585c7390ab023dd9187111ca5eaf111f5c3951cd7f793e032b2b5925a84be9be18d79602129b1e052566eb827d80aaf6bbb14cea316ebfda1af508e53f49f84541407716cecca5049fc1f61571d22d989cc52b5edcffb3198128dd7c10b9d335d66a7955f1aee8c793a8f3ac526992b260a9e5028c064c2e0332debf476553d560eca49635c794bd4cedd8f8384a28a151f68df4a82c51ab34a3ac26470fb5c24467d7243f5cefdd49735344cc19817e2817cd9c262301121605f36cc6878460763179b1faac176e0783401fec83368024293ab99b50446a905afb14bda3f7546ab622f68335f51a28b8069adf29186f8a4ba1531a4d96d81ba40d170699463fe8d23b0fcb387dc8431d9ae38b0a783baafff957863fd1a08d26f27dad596a89b3c2b61e8421d615d533569991f9bb06b5708b0b2c7bc2227338822fbbff63b132de5a9a195273457fe8a577f3d0435d6f41e1100091ee94d9e82433f2c236d75e02218ff9fc6c6e2e0d86f8fd81492a687ae0347f35b3fe2c251e71c8a0a06c8154be2c5d811dffa30c6993134dac2d940653837a1bf1388eb1ed10e6d786d4ed0c43d5de4f2126a2e9f29fee990e84a76ad8cf619adb5371976c6bcf567989c89f7605d23094fc14d46b80f13becbd5e0feb4c7f38ff9f36db4d06a1a6b087fc2d4bce4f0b3a6f67ed6c6d56d0a39bf8467f3672e0fc8ff62229ec02c9f0271bcc8e986fc57bb2d62a2d26e8935ddbc5855cb3234186a1db10446b18a1ceaf666ea619a8425730dea9e1a339a419e917553699192bf95e81f5c21e5e529aeb962aa1c490bef458244317628282d41e906b3b3489232b1f91f74e72a3627a7a21e86face101683ff8ce523c1b02d09bd39d92fe7e56b48649f2a1e36f4473fe8f1a786cc5ab3d2e3a19fcb06fdd53f7020710dd8b7c48e18beb97c76b726303226d81d029c075405d427a691306e755d01ec1852d7b240640868c2d10950b8e866cbad54d12c112a28ae3ef0895cbba14beb9018234f8dbab1aedbea76630b5dc936ebe18e36b905aab5880fa87981ce8b99d027e9b4fdeb3e7fcf14b51b2593ab29102d5392b41d1b8698c90e9f1715f92514994ee9b1ffa22cc085ec77aa06513b8c96adae0c0f22eca1e3cbab73252e7985bb6e1c230b86fe0456824a2388a79b347a997f6acb81230c943d28590a0c544d7a5b309b3659c59e8c49f7a9022924b6cd1127e0045d2bf87e9079205af68783d2293f6a7a7c5304f140540e498e3ed75e86e5921165b59767fcd81df0ef23804180284977e06493722742cfb252fb3545e0b154954ecd3d96bd87f614bc895d2dea2beeec6ed7a7d30266960528d01c6618c94585b673c4d077cdea9f1d12b9fe1e0b076b9100276afa46b7aa0104ed2d48cb116fed310fa00eea0303e45825e40e1b47c6d578d1c5bc999f5ce2fb38ae3ddf4dfb9d5d032d105ae6df0eacd208b13b621299150ac2f1ace25d313b171de78962609bcb48f9b04abad77880c5599b04ad5d5138080864c30acd9d46dceb9bb6c4863f3b9df852221ee0b4d574e5d8f7d652288691131f6e997464675bd0f2e4e68449955a782a312a1d9d227881003a96e046d3d3bba33b0bb00658352bbf8df698745fb3ce8659addb74f90e7d8a3e83509f58d1d744ccbf3d816acb26995940661805793da33f085c992db24a16201a49b6b81529bc298a9faf70752628b7d256d859a33e307cff6677e98abd7395e1f9feee5103c38eda0538b9aa3c612c44ddf0ed031de6becb2bf32320c44432ce33c9cd69300558dd9816bbfb47723d393e69765dde4b013100b5a190e4010edf871294d248d0b73623a811b7656635f5e62aeb544f75273e82c7af9da93ffdfcae222606cc5cd48fbb5ff7f01154f3f1ef01ed5fa9f14a0ee08ce421b0758f6eacdc40107bf8949f158b745b9d750a9f5795add9851b77ac3309d3b38fd84b3a2cd50aabd5dcddf4b1e6a500d41578294169f65d58a5337286a425d5f6721087ef2dc5406422eb0aaa48127b62958001454fa91c79512e87f00c875cdf0866721f8763c55ccf30122c41f1500b68e8bbf1d01c6192909636184aa499964353f51f94f354b76ea53751659ab5d5e3e6a1f63ea0778e304a0edc67e24aec4b1d23d0c373822fc24cf700dcf83dec7cc23e688d11ae0bb372370325d1740cbcc36b3b822e79991f003fa59f3a67c6db75800b2a6e24cacbf63af7eb2a4d3ec6186f0efd24b3619ee6ba096acc9e8895a16738a1a50a7a912cdb1dd852f90ecc564e90abd9ffc6e955938c7c023570282d08925744276a2d9b1f2449332f62e14df1936a03cdf06529f68d862aee736657ad2a3f2fe8649b7208534b6c2b56954a0666a27373116b9b8f78a8320b9921303d466a04a5613ad54c37ee731887a9ed2117f1780e8d100ab392b9eb105da4f665ca570a50b1d39fbb35e5de3b0ce159bcd085dec79433b56ab11aa6a406de4c66f2785bd55dd27e5ae78fe8e0b0cd2c5f8cec63bd024eec82201764b1add5c5ad42c1ffd446d6846e390ac1387ef34ea4bb549a6d0483aee102489bd8fe35d87b8b80e03e0120fc7153ce26aa53c713aeaaed3234d3c6740df061aa14fce990004f9de95f9f73b80fe7c6822975cfd8149ee00b9a4a3acd35729f2cca5c892440cc6cbfbe923233eb32bb2082328ed9baf56b506ef10ab1d0e90db6c55189c83ebad1bbc7c4c228bd9b6b373423150ea3df476f467429be1089f75b9f5dc0176e45a3b0f87c6bd72f88b2dca51e78288a7644050247ea4eb1058528bda1f37d75bc43c970c9b288da256093e82ac5eee88108e1db818030ad09c456c2f33aed637d9f667a308b166f2540cc6069cf491ad48b5e675461d7e50cd08e7692ae7e27fc0c2c1ef2c7bec38c7a468bbdf6ec39e5a158ea69374af89c5547e3cba7ed2cd8a86916be1456f71c8bb2f8b7bac9e696a5895a4fc87a36da689a6e99fd035c858dd104d7786bd2092e903a0001459482f7c3400c069fcaabc5f7874ca1f4676ccefacaa5e6e6aa5717896670bf82f1e0db936c4dc7adc25effa2ff9f9ef7f11f580b08ac367af294e471ed0cea2faf073d45e4659b001dcb5a0e72619532bc2cedff33b7ef51f7a1acf2202db80ffb8f7a792f48e6b312214ba7814aa8a4f4e8a2403c4612908224e513beab87cc5d38718768823e0a0827c7b6f14f0e4f7b96957afceaa94e2c002eead82045ac0d4d552f6da7fdcbbb2f4699b903fa222231bd0b4d6e681ee7673492db8945584cbc52ecc659e4dc1b2041d0d1c339e9d3e6430b4074a07784d2f1e2d33123969222b6885945eb83ee63c5bd02eae26d3823da36e9fbef0b94a2914708c108e380d7afc7bed4cfc071ee8f413565c92c70e92117f22892881518c818345faca5b2f63d0b41cef9846ad8482388399545d0783700254f92787ea5ae3661f754bf6b025c2d9f881d23cb2071d69046cadd11c22b4c6b9de62f560f46e08118c771df69b6f2a9b2b7a8b520c2f656d9528fce1aa6f742aa8452b20ef80992760a6968c25ebfcda7659dca4a9f60c86c2939df44771b6aaa6716f20ced086bb8dd2e32ee2df7cf80d06ddc851975bde4717e2e8d448e3d8f688bd5583fc1d516de1d41176eef778a5ccc824d8f9aa5e3b7c89108c888e0e033ae77b2d47e97e015020c6bfaaa0ad72c47866f9c120f12793a5150a776601d3ed2e801874eb3f30e7a9b2633c2d6fe4b87c13bd49f6f0c8f7b0f8b9c3768f2c1849f96f79dc2cf96d68dd8baf4b49a932a8d6eac30446881a4cb2d269a4aa9bd1ff4dc3edf593f730ba38ec68f11cc2c8768c00d4ba32132cee26fdbcc96fa74f62bae4647ae308c74bc617785117baf38467690aa1614b6871e0f3a00104e9c2d3fd6054b2cc67036ab0ed80b064b907cf0ca6a49d49f25e2368e58f9181da99f74d6d7594a9f0db0842695bde5eac0c2ec4dd19312ac75f92ca9600328957a4acababf03347f3ad15880c7cd0d1ad9ab46cb28fbc59bc2269e900905ded8d20f075445258529d4966fdd6a6ecc11f878810904b983fb6a0668300f4bd2f1c1cb75d0fb33c18f0b7ad5f85709ec988c0e402f44200b5a1ef10060076f12e9adf90c5ea74396e9a4a44f7b98f8a80ed83d1cb8442a02174659202bc11643beb0bd551dfd69ae3aef70e801e4e3ab96fd7fa8ec06f42d0d37629fc86bcadc51210754a30c6e835e7b501d75c2efcec9a86e8f1ec52caa422b89ec62e008f075838d8280cb03aaa8f672fac954d2e6998b4c559ca30119a500c977d87f3bfc526c2a5edd34b9787fb06c80461a957c8bc3c1414eb471fccc48d5dbde0a8ae7ded93747e440741b6a26deae50be605e12b1fbac1853436222c2b19808abb83e730394adb61003b1f8c93abce2771a7d75e6a3cc2d62138f545546b85683e8c676d5fefae157fcf9d057ede0a2c12df753ce4263c81567d64f7511ada219ffe1cf361359c800ecf8da65f94e66c2470023027e49e628ce991b7256bcdf5e53e1f94437ea61f7cf718b1d0ad5329cf2538cc127f41b05692e9f581473935bcd7e7e68db25e810b5c58520220443960b825d60c40afb7b4b7a9e09752f5726e001aaa155a75545e881d0140e60b01c680ce6f6164889b1a6a7ac467ea05f9da97ee15d8dc7c7c6b6d650ee68ebed3a8dcc43d57569c8f17c2af9a069e7629012443fe8cf2e067c2bebe4e6225de488c0da179b1eb12327e07ff15c5064cb1ead0e13156f2b31eb472944530ab45b1fbd068f52e7d3783c01233571ced5935878ec8a2b023c277d4fe84c2596723db29a4c62d976309eb35a52e195f271563a4da184982bb0c697f10c312d4ecd776b1955ccc1bed381da750decdc7710347f3ad3a86fca766c6f9a4fd812bf1f320c1e56a73fed6d27abb19d87cb943ff8c8d0246bda017048bac875ab05e5b5dc258fc3d0b758c9bea441ec0b062535de0f95115889a61c3c1c6690ff132040d4453bd1522d0627400cb6632b8e1f38e1a22661901e46ea785b3a0e9f94c5f13124ac2746bf1b1de85493e3d3e83c8ae0491a60f7ae1a35eeeddb205e1a9c48ccfe55468f2bc59b6cfff4f8c72050bd6f71d0d1432837b769a71ccebd4ee2e9a8a4acec6f00798754b6c040b671a6518159a6821e5c3ab4b0173852a3e6e40e606d7c4dd1cbab5cf1bbd16d50a842947976de1e5d17390a60a577d4ad8220c17149327e8b2bccecd2250d9c460adfd53c72a416dde8367d512a671d3bf79c25263f17933f7d1eed385d3d50c16e9d1618b1bc8344999be488d76cfc8f0aef64e487e4bd3f56be32e6d85fddfe60e991e9741dcff387026aadf1c6cbdda38647ad122fb7f9577499c7a2b8a2eb64b7f621b7781f90eec22ae3f141eae36aa33841cd6864ef4477d02502f048e2643754cc7217ad1416bf42e34ae9bf453d94ea298d3adf0a576acf7b69d2b0278bf2d0b6046d6b396ff9f23f96bd01b913c2b1bb88698ca4b7b5cb2cf160e4e947d1a52aefda9abfc78310a33c7d4e31fec89e85a0a33b5bbbd412ae931b8ed459beacf3d5ef12ee41baae733be2b2eb8563b4d9de231d8af23c723410b67732d59fba90426ddcefa01ae35840dd4849202cee6b9b93bc577b08c75a96eb6239f2f84e10fbc0403be969ebedc0aea59c33b82794959e1621cdb80fcc107d072af3306c222e00652322f9253317bafc54cb59101802bdf12ae8e4984587d979d3909c2caf55e16303698f73cc8da6ee55916b55c4bb3c0322c5876e1d7f63eada6b2e78005d750beeea882358b7c4755cb1ae41af25cf180b269808234bdc779ef48d17ca877381e7b4eb55ffe62a6ede8e7a2840cef4c803ff748b3ec5d7eff4296b39f73bfdd2f4a67d076e37dde85a7511a4b814bca3b75f479f84e4a89d6dcb4db4eb26cec8ce1289fc2af176659d9a56d0fcd06e38150407f492b55fb708114dde624cbe144ed46e17e2f7a58e03dc71a7b84dbe5c4a6df4ed7fbd35128e51c3d8e81aa185ba6a4c5d94a1d5ba856091c4d65f2c93edc957582cda437fffe5e5f812b1d050ba4b9a72da1feec8f5dec0ac1f137d34ca4ab87b3587d3a2c424e11ace329ed57aaf7fe8dcd33d60b953aa3e37623f2b4fc2ab9df69849aa611bb7394155a65001b6663952ae878713fa6a6047d0ff4e84ba7d5292331bd8fac5a772e465c08935e56cd83432bb3e7ee7ce8e72ed018a3d1cf48cc25d8a576d6f68a6aa42e48dc3e881e7cc4b7748b6be7fcf6a83ed9e343814fb84448b190f5e4b7c01dc9fd221b73644fe35f3179766c8683ec0a5a38ff4c44dd44d65cec307928f17593f6f8c414aeedd38c136279e1f9ec834717edf0ef9fdbb60bae0f7df54d53f0af4c1b52f9f0fff2d7b31d5adac8fab2cbd1a7deee333bc3b502c9f8cbf9df6144020a0e1584c1c145e2c68f218596f0ba4c463e729b332c15234a83dabfcc28a7de051ef95cf8612b151a087c98877097142c26243bb47ac6b882ed9ab63cd1d8fe93f0de4ce7d4a152c465d552cdb20545e71297aaab91888ad2db61c4dd231299c65c8c31581df9fab22191c604c4ef12c6cd8fd0379ce900d045229ae6801515698c1eec60d5ff879f2fc5729a7ec7ea41a7aebae4fd65cf53e11613f48cba5273782a55d8d880fbdf8fc585f7692539607550da4e7a70fd0ef286dc8d4bbf2ad46a26d41326c8bfdc688cf2fb312c3abaac498699838fbc4b351d6c289ab119f433ac2c8d1cd4b9aa288ae073165de73f2964484dd12a99d4dc6db418dec3799377f33b4c974645438bd2683a18ecdeb271c230dfad3b9fae455551447dc3c91c265b794cee54eb4e9805bab9a31752f0cf32218fd8b19e6f7361ec2f540a235da86f8c41c00e67aeef7ce11c28f98fdfc730bdec3556a5d3bc90a74011ddef4c5c2eab49b146ff2848e86bba6aff25973f02c2d518d8eeaab7ab72685cf9ebd1df347715664aacd3ed0acbc5cd9e6b23d32784557b8b899c92cdd38a1896d3debbc9bed0a86877a4db63d61ca8b6514162659a02844346aeb2266e0d62cddfb01e1a786c3855da073d2323d4d9948c98fc8fbc28cea0e9cf51e5310c20acd9ff590cf5e5cfeace218b69ce3a4de2eee9636ae6a1aa37c73b823f3af654ca0f22b8b6cf296a8244181f346a03df7dff14c5c2e5f0b8d60d8aa1395381c2be90996509da1dbea62ed061080890e02fca610aa18fb5759a7a8b1337f3d5adac2c94eeb80efdb733e30fd1e8c53f1a8a3ec28ee0e30d597da1c9bbcee4626f0345959714a969f6ff8b41e146d091a9bb4b91a173bfbd465f532a3f5a4dd61cf61b8702e1795eb71604ec2cb41532fcfe36d11fe14eaa99ce8740f9d862b6a8715c60db2efa782aa091975d7d5e10ac113aab66cc96282340e64670513952358e484e1bbe42d0be2356251f664b2233468fea890b8c69c2caaa64a132832c5693943ac04db78b0cc8e37513fe3f7993146bb337af4ecfc600761b9345a079494287e06b49cd3258322ce4c628fbf79d6713685c0b8ec7f234ac158f4fd9efe6e69b18cc11a31a963d342f9bb516c1b1f8adf18658b1a65e451b06b3c6355b5e161988ca51a77327294e631b39e36d54265393cbdcf2b6ede8889571e108f7e092eee29c6e91cc390f5ebe2f23ce286e3c37413344c80a9159b4df5b2dd31d1cec265b4fc99c71fe131d9ad1f1b92176eba882fe68142801660ebf25f348feaf6bb0862dd8a01d44f465124ed628bc864b056a70bd588b8e2c7012f71c6622c7ba302b50938a769c25ce7d4cf05c7454b85b0da2654d02820f660f68a8d6d69c4b393b5ae56863bbe3a64b42a1a7cd6ed80c5e3425ccddebe20909e32d693a6653d32b09e13b9fbd68de194ce2083a4ffe1147393aab2a682eb076a29069a273cbb2db3281e417be9e6bf32fd43ac8b24d5abf796a9fef1416251983191a09c8fefa43a155d51add2e877d75f48fd0b6a7caf7a548913c305950fb149477b6991786de4c184a2b4e6f31276872e5e3f988f74810d68492b591844da56072bd6b4cdf95a2257fc152796689cc8a87287a805ac1fbed6b18b55b0d0917bb7f73a37af98e918b2a6c80aaacc67ead07219bb29a339c030168562532718396f8ed2a2a9316ffa608cb5f04a605d384089189dbda7b5daba921067c95ac58eac903152a84681ce526d32196d6d2be41fbb96cf011f1cd972881f8616186d3877cda8614c5a6fbbc94ec6d11b00ed521defd6d2d05488e94dc5141e238e032489de082a1496cc49954bd7be8b54e4eb051246addbeb19d0b133c1dba4bf28342d9a44cda7e33bd752597ea9f7d32257a0a17ebbc4b6017cf74cc54ace5c44ac3400a03427bd69ea6baf205b13eff9f4aac0723c2c8469f8c31d55e38b042e31b82e2e3521c831a7c42db8b7c10a979e8ab66292a86d1732a628be8aeca609c8eb90beb84f1ddddc78a675600bbb2a1b9b1703f5322d5c224b7d0810ae1131ecb6409afe49cd602173e0c16d7a3a68b3beff7b6a4ef3587ae3c3520a633256ae9278b2cf5fa10f470b59bc97b4558e2973ba9ec25ca6567ce155da686a81352582fcb69494c75e320861813724fe1099d1c7dde5b5e4bb24f67bfa1017a92771027bd4f0028b0efdbb151a852d48b4d9f80d15c6b74d50601179b06a28573139087b68c1a41ba1e326a177bb4832d8da1f0212bf5abf763cf693e5e63823164f1974beafbb55769a72097202b47e2b50de1284424d9412172a79e92a644ae2905c77a3f2f81bbdc03631dd0d16be20710e4206df787d23cdc6f548f5282f5457629ff293a70c8d5350deb6c7c7b5256765ac983ab0ba44c96b06815df4e4e2c1b5de523b85c8762284c7a0e242da20437779544a9af4bba52009b0987c55c3c7a2eeb5a479ebd810cfd1a8976da9cc8d7b807834c2324bc7cbff5b78ff3ce5c8af1bc0718de21d286c928d779b79d5d307933b082fc7ca6ee9671613140a4a5a954daf95cc06618a33dcba0f18b1b870f47557a6295b5cadafc81008a49301ca72744c1c0ae4ddfdeccbe1be8a3c87605c3e69a4f7ae99f90a5da4803d37cdb1c644da210ed6227bebc03608f819712c36cc52034fed6c4a6d6d4d96dae9ce12d0b0bccbc5fe82b312035480d16b8c1204672d25d4c2037c6b5a79309e526200e0669392fbe52cd2905051ee58edf4c7050ecb8f6cd26db9d21165ef1c97b1cb1b46cc07a5b37d94a2a6542af777a719d4ea009d240d2cd46fd3ca913cd45248db3948e11864fa61aeeda78cdca5a1d0e364eed754dfd32ac4071ad70607ad75b0aebbdd5381ed3a204d411290e2047494e590d691a54acaa9bc944ed4a516ccff0eacbb5bdeefda4d0f878bc1c2f87c7307286e5dd2e2cbe8689f65a77a4000bb543a1b15b666bb72436108a75971cc1e1d74eec37c4dc0b446bfc9c5739ec3f6088708c3c6ae3c2bbb4e173813d3b460b12f3bbc087ce6de1f14d6441a03d6da0861e431672289377d7a92f1943542f458d03a07c82cc4a442209b8f4c448d9dc19bba9d12f4a84973e9e06e87fdda9b56c7f0db016673e59b5597b5e20e2c233dc9abd9db4bf082bfa750c319263e09c3675fb281608dc20f03b9f72abc2bc86e390653a6ed01cc3c8f2c8dc484667fae9f7b816ae7815db8f819157618f01880ed221ca3c4488c3439ad7e2840d3aec1dc1b42d6e23d87fd9145468bb6bbedff5e256e62ca20699fb4bbac98052e40ad85673863e70e11144d1fd40b476511546f955cac1781d185d9aecab8178239a4e55a782888c7390b3b6e561431588b1506c9b82f80b0834a19d1fd0e2b361b62c75eeba72063e1b1752949a9edd9c5c46654af758dd8878e89ac432cb8369d7b63b0ed3a671310e19a7ad8f25a0b0bc233b202dbe7666d29c575360b5b51b0716893d30c5da71fc86adf88258ef5e2a95bac537987b0b972516b898a7d89384f18bf952302478079de3df1250be7aefe9a1751baf4c9422d306802319ca8ed01d972e307422e3f85e793d221a5f9c8e136c8c49df0b46938c2bc6de5989f08da0547cf78b94c13a01d6198edabbde9b7aeb52bcd4630a86d5619ba06a869ccba458314a57cb1e45fa0463d13949e8206de6665b9d9913645428114779061599f515211ae8b15012a343509040d047c125d8fe97db10499539ad60c35aab98dc3a6b2b152e9dc68e9b15c1739e496da14aa6046e0dac8db8113cee09be2caecd1b2054eccf31b29eaf0b23326a7f0764ca3425938df02ba08cc902ed5ac199c9bf077ba279b989a63cf20f8b2e6bd1e526930b32582fc0a433488786d8c42db3c9dbb7100ac01fe1a2badeb6c3095dcec7c36a3df24ae31bc43792807e8322c6a963a120c3c9983a7cc3601bb7097d59038185d1f4b5388c93b71180c35cba2d58e7e0ec77000ee058455e1dae69b59f26409790bfb3221696a5f822b2c8b3c32a456db6bf14f52e82d621f667252b5ba62c741399394773a6a722a6578ead05e6efe628350e6dddac6053248537390a41abd5ce1231263a8c741db07c897b99a2a62f6ff1c49558937667c7620f740bb1c595a136006c57656a0d71c2b39fd0a324932bb417e564f54576f4f56170948157af7ad4c978938847a07c3455f5f44b806cfc8cff4e5151704cb8097617b1a48f0f6cef5c77629e09916bb1fefad6d2f5a6605b9ca96c78aa9547a71896255fe878ca2fcfb43cc9cd3416c86c3db3364d9fc628df10f930428594e994467b48a40fe8773540a804f4448801d3eeb4c6712a8d362b48f36c177665aaec832421177a89b97b69471349d320bec31cf93e88c97ee7c8f62d9a90f5b0f3e2ffc0aec5a88352b6f35257937d081d0f78cc6dfa0cf291041eaeefd6f9a3150a92e804a2e2dcfabda5f4266a40fc1ecfc297663ef2f567d1ab37cd3ab69b58a28dc29eec11d284871b0cee296414666e750f9f6cecb58c411516e5f5cb937f01889d1864c41c040518f506d7577c54d2f26148c5968cc89d2712c59aa0b6c83799966acedacd0b557ff026ac98f90eb73f47bf532ed9cb3b52ef697ea15f91b0438c3ee540e9203ca670fa0657ba1f05dc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
