<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"40b89c32979058bfe8a2e64ee7e1a04bcf5881e586cd41f5dd32eee3a7a7001898210b91a9f4c37733c66b00543a2c0200ffcacc48eb1707bfd7f7d2356e6cc0a74c755733fca879d18630ef110011f8214015b4db871c2c03d15a895e696c2087f66b2613a59a2ac867d09653fdf5c901d82fe5b19575762f0c24d27492a4a04f598208099835dfe43266c5bf36507aee1904c24dc7eb7030db6d09f0ab20b1549f51e4df945535de98d5cfb7413e9e708a021acce6b063dc3304394f37662d384b84dafe26921dce593a1fea4fafc1b3decfeafa2cef417e4e1cc5f2e1660dc0fbd3d477baf9fcfd4feed39f38550f41f73f0d5abdf3c5bb2a9f5a2c2d55b4adbf3e1de8159c7a75f493a818e3a5d17a274659643e443a8aef3151016e7a1e863ce25f5b30504a561f2c01b5b5487233c7d9aa716c77184b1a745575a9efb3f891e454f9b0bccc4907b38bb1ea7d43900134a3ac1b2e9605d30cf25a5983576faf9d553e97fc1e455fbdf47356ef12528ead1d4dbd2b0645b815785c153e287ba0fd6d922e56c137baa6848d9deb0fc63dde6a4159b431d3793929af05ff6037738a38fd9e48a3c1bb63940c315c001b2a57c9d4a89e4f515ec6bc1cafdd35375efde5198049b4fe81263f3421a05514966f52745cdfdcc7fbb0892c07b1a4459ae81b3c60be1bda86b91f66000f85de3983d972bb7721d4e381c5efff8b065ddcfbf5b8aa8aee0d82823e122c59946a620cfdccc411619a7b0142cea9c9aa7c25ec7f3d00ec9b384b24c174ddcd92fd4a504b95c886b049bf0da81686c436ef4ca6a0b854bca2bf4dee7e7a7bed8a83758dd4bd32c3df849d53fa18d437f8a589edc812d8314609a5a812eb50e8d9e180d050e4b7438d056857d397378cdc3b673e414c195388fa588a3cdb901ca3709d66bf6ce5d3e5d89e10a5ea7264e32836715aa6ea7b36c25a0fa48d7fa99da07d4528a79eb9757cd7c642bd44b385932b75ce0e037e8b9fbcd75239e5f6122013bf950095c3044d82383792d3d4cf92189362736dc611ff16bd48c50c81aebc9dc76707333afd1a6faece70ae3c50a068eefd28c50bc11e891426a891fa092675fa8bf60c8329199b83b1b2504051f2fb8bd8cfea0750444b48d35438608cbe75b0ab54435e64e385879c818565e6351c0dc21647835d0c3dddadb7a7e5f8f63743aae1a212f28f3f641c1fe8292fdca3670de1d06d40e5ec58c74e20e645f880ce9a3b1581e3249337d670daa06863c59ca20920b55d2b18429dc1b6cf0753a0133ff57b1a8042c060e4c3b77201d9c4bc7816e960244100dada502245cc310eeb561d875239ee2331249eea52fa40360885f012804aade15d65a5951e0a22e00cdb47de8ee0fc69b89a243500de2a5dcf8d4654efe9426144850e32ed6c0b03b503c99855a82e9ce202d6313617fca1a90bbd5ad4b7403d9ac659bca152a5e6dee4ad5ce3c89860a0ba0f35844ce1f66a9f4fdb0ff88d122c549452f20a4fc97ecd99a3e979677d479b5af271f3f9d904680577e4f09aa9931ad867885291ca3da74311b57a736fcddc4ce35f6506974cb2337e24452d0240e1f351731e0d46e8e67e6ac369a4878d8949b8c72ab2c81898561baf55db85d30b5af94ade841f8e1d49cfe865741b140fbbb4252b15bc1a7133738862ab792384983b5aef8d37f5b92e7f04e49da175b6b60a878a75a085a13f94d121ad68a14aa5c71532da21e4f6fae0f77d560ef640d436ccb4d1b2beb9d1a634c2998e3e235ad8b8340997b973872956dfe6ff3a3cc72173495b352f89c81460ded93c23f3ef204c59d931f7ec4314bd03e7e5dd66b7e4ab39248c814f93afef98a6bacc43def4a3feb6b2f684a8b8f16738fd44bb7fda4a907579ba6042dc0950ca511f3c7d0ad43318db8b6535e1b949510fa1c490edda0c7f41b37f15142c6b39b2d942f956f0a221cf901ed6a36337245389edc33e2976b39a2e072cbbe2ddfdcbf5b838551c4e3925215153180f4839249af4e58f2e601ac49cd6d7e812b969c482ae23b5f50b9327e6edc39dec224dfe90e80da3968bfb0416f36c8256a202d6c26dcc69bc43ad3de12cd10bc1e3a25d508d8aa84cb4c627d22740936bbd7b804645e059e6171da83249be27e3c5173562625677b9460b51b7db12cb0f1b5de010b0e0d6665d984c5d45f8f426257595ae19c070f830d5fb4c22fd1c30eca7aaeeb3c74985989f3eec1abf06d4f41ba9c11ac48efff18a6ffa327c9e020236a1a64a656d4c1d47451ea925fa9e5b85f859e48f3afa77f7e6c9e6298e01a40bca8dc8b0f6c6b40f8bba1ee46539a9a14d80ad0bb91f03032a7b3f8805090973720a7e7f450745908166a695c591550cbbec1224899c415690a1a16063dc3e66736cce60897b07ff27eef424861943679e114595ecb47d7b2f81e80cc74747afa71e69e9585e834582dfcefb9b7120853e699091518c96ab0ef15a70e6045ffc6ca40040e71deae5e0d49cb988d6dbfb95e45a77b4a14896c129fea8acaf2dfeb4aa30c1d9d6ce454e0fc29a0ae3a87f5183a134f11f812b13f924139c2f756d28d62eb8d01d095b7e402c4eef52cf696446f5766efe1dbb87d68e3d8c6e45d07bb4f8ee1e1ed2eca8ea0016adb28bb9e5a18a1830bf5f03e6be08f9f0acee82bf8af46289833c078752a72130338e88424a60e5cebdcbe8134ab03ff2d0707b5bd78b6c35a7593dffea0d9c8c4dee2f78e03f140a87da04f2dbb27847ffa1aad1f150f2eba2fd1a41dd1f485110675df46bdb2e16b3c1f6ee2ae73d5c7b18cb86389b925e71cd63d8d0d8378c0888d8b4741168ac1841ff61d3f8b554a31123198abe7a7e195998184e87f7f64df693aca8dd0ce47ec9669cc0ac472d3e139a845338a96dfa5b5c3c6dada2e686d7b8c9a5d54786dff4f461e387777ac13f9350d0ff5e1414ea22434e737b92060b1b96c758d609dd7c4a1dce9debacfa8ac4ae17de2c0d37a8a0c9e7d9d24d9e8ba731fe1dfeb9f5b37c3ee0e9751baecdb956bb0d86f973d4620abcfd25a2286de1bb7ac6191dd98e85a00b9769cec45e2b01c42b353964c3514064a2ebaf721058f87d76f9a2b897324cac52b1c162a8c89e1406b49a8adff1324fc869373af3441cd239465baf3365dc81df3caf6e4a49a5f6891c623d86010b31217c223246ba46479dc3028e03c0065d0886656cd74315f9e94719e9b03806e55b1d7f5ce276042c5f1dd492c3234361d7362228ec7ba49fc00898d7658585de92635b79be0dda58bdade2bf8825a69ce37772ca09ca5e14a2ff015d73c58733b908d1b660076d792ac303aacb5469889bd786eada16874586d84f57cd7dd98bf94186919d55a21f9266f8b5663cd24727f77e1e853f9840ea7fd12013f62ed497dc0e105b32ad2f71af09624ae4189d72c0fb852812498aa35e410c7f6a9a773edebed929d54308bebf7edc4a0f59abd0e38a7bec8f0d26231b398b247b11d2d713360bb15febc8afeae91bc13c3914acdff4d01b16de97fe5d1526f22ace658e9e8c86e20469a31f2457ce82093372456322fc43f8b56e0ea6f5d700c24c56aa0bbfd293591f6c70de571f0bfe910ab64ee6b09d6e7ea22d9aeb4031e1898f8850ca9921c7f900588ffbdf72cd81d5ccec07e27f4a73663ac1a40a6f64e61674922c315f1acdb8cbef2e699d522afc4a4b8a3df7b25e7aa68a8587bfb9d514bdbf3c219f5b8e54a52a8c8b78db097b05f9f04498463be34ad6756ddb3a92124c9b62917181b1b76124dc9a656d2da9bc5b550c11c10dede4bf22b45368b35203a57519939343e3dbe5f38c7d2bf850e869dd3d1951a545a8d7d2bbd43001c144429d4b587456708b2c4c5aba6026e6e882f26de0c135e4d055d59e1d10460d59368acd68cc94cdcc49b0bf8a6a8cb6dc777dc9a52cd1217563996531615a4538f12e72c41de8110eb264e2db9fe479dc6e502696536bb1fd49acaf0fd71eb353d8473b31d3c71c525dac7e9d8a6af7a2a7d80686ab43acf7397f64cce4b70a5533e80303187cf6312eb7eeb2202ee8ecbd9a8902615fa3952e398b65aec4fc9987ab3d5df5d93720c8305c12caa41029d746324e62fa11663354b06d5df56a0e1ac39c36e3ce5e070a7d6a4d00762234fb45fedf96659f404051bd81f45575efde0671970572ad1c8183d73f2bd51de96b36982466c8eb20098f14e92aebe2b05710d19c0cbcec28c9866a47f3526a9d8a6e85a4b2c4006425f39f89ecd4888612543935d1803e26270ea2f1af43a4b78c8bb9246340856ee64f20c9d33913d9ec11e4105a104c7db535d876ca4262551094adaa776d1dfcbe0f4534ad5fcb27ef2dbd3c3e31fb8e353e35e2b088caaddbd1e056b45c62bb6582fdac3b39d97d32de7f50090e8003eb359b1839dee4a3e0b17b4328251f60835fce18640cfbc0a888b3e1344164ca89850a3d179ed92574e04ead50195396f1d562857509a31b66f7199ff7230d2bf59e26a2b4b9992101ce34fa9cb68be6b13546d75c190f5766b76406cd0faf1c989d0272cdb37844847edf579fae3b5bbdb2ca573f828877c6ec7d60c93c76e264783119268815043fb651ea655053d6a75b31569a1a6845ef6117da43fe7daf084cdb70fba0fe21371d0f7b3980840c153ddc0c4122e1833075f297865fede8c69ec2688b15a8b56912e30fca0c339f1667f2a47eea01abfde71357012009ae402f427cdb05433c25fb9f7e747449d8664ef5447e72148bd5c29b9b84f15335122a39a03e108a76ffce99d7a4c73ccdf59142ff1c1c503067afe9e16a5c39d1b33f806e5200c71368c833961737c0ae7c4a1e3f4d9755307c84acc80b93b6ed76d7a678efd42722b543cb6d626f533887a070923716e59499f3250d07f90e3b9a42c0f95b610917904bce701489fc69c46851ddeaf0b70c8ded1f9c5ac5578ed83f8a6509924ceb2f568bbe75e2359e143d16093ceff50b2c27059a5be222090c6ecee8b5a8dedfe1a40beb9ba8840fbbac42fdf6ea45bafaf8d514a77960df7dae496b53b2fb3d8b9283830329e5b93f7f7f3a1b8e236da535593adef56b04e59adf88dcc9c0687c8b8c519247f78967988168381cb7e11e9e950a8b7c4de718528eef6446cc2880cb69c1451df554ad40d280a92274c91c67eeb7e0c2e7a4f7bfd4e18edd9558285cdf24a5dc832089821b628015b0a940744a486e9a755587c71c2f1e65ad403ff3d28e9862c133ad83d2d4a636e5f7718e588acf79fce1836b1cd1d1f5202f3fd22d65f6ed78bbdde72482acd045db7669430f11bde7b70e33d679c8c837fb6767de1cff4b82ecb0fd6f0f391dd60b4401dc552bf832dc1b34add5d9996e84b54375b8484502385462a62e193919d88f4a2edbf5a2bf48d36f33aed255dd50403903b72e9d913b6a6cc032670852f6f6c11b53d61f072ec6c962260dba871a28dfc1b95ffb9c40ba888f3c4683b215410efeeca02e6d3c410ae453d50535eb558825de4a5b70e182e833a599a11c0d0f12d0e3ba9c9fd81de388cabce7afaefa6916fcb072ccf5927c16be5e6be666bac2157cdd1c49732b7d912490111ecaebe592aea69416880200ca4d49022fed234c864b5acf7b3fbf056def6bd759e9dd9252b8630656540fc5f55520f5b32b19802474d2eda1785dc60dcdec4726b954b930753474b3a43aa44349bdd07940f611d12adf67d640434e73f0ef1ecf848a2bad18cea341f32fdddd4f6c8fb83f0d9c4ef4608dde0e2c250e3a35e128f8ad9a08e78fbe5ae6b46ce4ac6ac1ae00aabed90ae8295e7673a5fd9052f5e72b903534abf91aa4546dcdfcf2498a344fd1c1cb0346cc5d0d020e5f960ec82dd4d8a53f82f8568d73b871732301219474ed8427759c2a4694e12492cc623f2fd706bcc80e45e9254740e41ce5d8e30bc3a2937439f87f8e4fef72288566789a406512ae5f93303f1df42268655dd3a59b135e55945f59fdeca6e7e32f1c0190a094b3bb04fa181a32e21167c3e3c357486cfaecdb540e28799101158ad952d00cb7e1b59cd8f6bcc3bf7e49716ecd4a4e0efda65fa8a67ae94e86d5fb5d30123fd73ba0a033aaa67a1c0cd865c48f691a707c46cdd1c13490141593546a715b7d685498f64c2bec66d7951083f45705927da76fe5cadbf7eed3cfebc5f6bee9dfb9e7870796f5f3fe5bd1456b9fdddcf0ea2f4d44d6a786150d5588d7bb7f2dc610a6291a734b1567148b1de4599b034aa7f43ba31f2bba5600979e29fe9dce73edf4f72d7945e7c933cfb375ad4934e20ed2034265d6998baf3b97abf3c9f7d4f1c425cf7d6c753740d293c1f184169f9ed2cdb09eb4c4085bfcdcf4772f7c2a52c851e0542af190b528a228609a6a7fa98aa667ff666a2da20f0ecca91b3055090cf164c42ed70861efb047b3de5ef3d382a2ed4b1c8937fabe60ed59fe9a7a2db89ec4d71298fab93af1df10df57d896c9a971100b60d90aea8053280e9da50ad8999fb86e99e73bdb66e917ba8c1f435e4e2dc7e4a710360cedd325222183caa37a2957102af6bbea01a273f3b6428297f795518bb3b2c4c5aa876d973288ab67d285d3b964505a54de46f0e23cec86fffe2f865121d81f7d28f2cef6ed075c17b79ee58d6e6a58557286ff923e6d82c365831d35e3b85a686afe134ea09badf5f81b1734527b470ec80fca488cf88ddb2195a3baf8162daaa4e927c5897dab001fe68b90a8acab2f149f17f821040e28892a112193e6dffb9f1d269cd89eafecdef9d3a37209c921ac7fa7695606aa76ae9ef992b95e6e0a9391146a582e60f0781fd41ae1cdd87208496684a128a6ecbc7aaecc07c7ca171636a658dfe1f99f97889883b5ca13bace46a8a01d829c3258d853753a4ef3ca26d6a14f5a5032afc3deae73cecf31df35a4d7f70de7513049c587a78fa92a9aae6ce624f2c3586b75060ed95dc87b7b3ba72f6943575bf47d8a46cf00ad84aecb01df6a0f378011e595d820057bfc84cb9b518af7b7cebf369aacceb1fd6cd8d8bd5040d467f38c8867f7d66e484f66f41bb409e48a1e946934bfe45e746a3d0fd635407a2303dd54516ad9ed0eac3fecc6c5baeeec968bae3dd079a4365052e374b4019b6e7ed2ef4060ab4aaa1dbda0fdcd96ff712221f5cb41f858c358a10d5a8fd90adea36f8713426f57204bf5d8378c298496c6a1f6aada86fbe1814edca621752a072b8b2fd4f9528a9dc356a7d635061b877fb8ad7420c9db9751bccf2bb84f783137d271b94bd98c456acd9e83232adbddcfe83bde47e90d5ec39a760e308657da616b38953d7a145f952e56945a133304a93fa4c91f138dbe03f9352218202f7266aec2726bc8cba2345632155fb5a73e15cc96f0c29ef47c44cd50fc26ecf0f8d1ba04fd617a2d8397b0b1f404a4d058da5b4df7dcb1e7a9123712a7e6429882f6cd7d025603c641f888ede1018a4e085f688500e96f688d689d97fec60884488de4a5a3fce605725e4fa07c5670155f288cc201310201050618854a0d063f128efc664a0921e3230dfd61a299e0722f49c037ce7e7e2dec6e56d3d7d49994b7e04954a489384484fc4d85065068b2f14aa11f7a61d022574740f24f067851da32326b80866054fa13569de5a82f336d0281972dcf4202e094645786d526226692e704289e7123ecbe69c2e56b9398e1870c58fb6b749a147c75dfe300269bbf37063132f7474fb6040cb8e7c66b295c913498b7ddf347869ea6363aaf840b393fad781ab32bbefd012ff974674af2d21e4a3168d369ada473d6d41761768fa831c422e911ad524da81bbc1e098100bc2fe839b699c11f5218648269e2741d2dc9abb452f4e7138b3fc5d366efb09b85bba56cd34d4a8fef882bd6b050ec1400aaf501f1ef09d352d20c1588063d9081727e89d0389693335371b6fd49fe01676e36be105416348f05ce47d88dd770237803baa221a601aa2545f4f6776171c9697281f1bb3a6c783379afe06c2c052ec211f01eac2e6bf061ac271ce79ca89ffb39c39808a2c2e605f36470779c4cb98df74f1a9b94bce922d775959b681024109de1b45993b9824a14407c3ee944aa1fc18ca722307e59976bdc8f71a9f1c38786c5086acfd26fa9cd2be8c3ceda169322112e3151ecbbbdd5eb72ac9ccac4e894784762df417f79bf5f7c0b1f3050d62bfee3f44708dd96c5a207e3c20fd77de1701c56578a3ca6c977a80accea885069a66ad0c4616a6801b705cf66ade5d68517ee87f25db68d56dc5193d46d906bffe7a9a0cc4d727f9c83dd5cd86e146437254cdbb1c523436822c613f3c52e8e9823218f7cb3e403bcadcb3552d6d03e73b67ae11341cbf0fdf0912ed893747fde756a449ea924229fc324a37958adabeec8f8100dbb6c233634911bf994d62b364ba7c46c881da617e01b92dbf4640db1d87e4414fd0e6647302a58a8a4800eefb8237f1208c004fe08abc67e586560ae00363b828cbc872f09a9cfa0c5622d8f0784740256e87cda50861de13b059ec1be33f5862f0b7e779f9f01726ae305dd36847e4ad439f7fc2412a232b64f4c315d763cc04e9e59e686c638194e92c36483434fb3affc70c62d561473293396935f9c0678b1e824d66006ace493128b64d86fd73ec76edf89f8acb2e9694921e49d9b16b901215100d9e17e861ef5d96f7f1d0d24d947f97a4b21fd0b6d1ab0c034b5ab4dfe087723690a2b3f3f341e808b875f4e73b84dc42453d0b46e85bbf9bb958f32191b285ff280c87e3b11f56ab0860fdbb3277ac3a6de6e9da24d384cc83a0a370d00ccf11c5a413005f0babcc0101d1671deb9dac6b0b8396a8aebefc0d3ed7922f6700ee341f7ef9f6bd63577d1b9fa41f17a20c62cddb5e3afba518d222cdd53a4936553ad3f78aebcce40a5f63892d975283df97e68c720667e461470ebe9039722e746bdc4a39fe90f81cbae0fce909096c7f1b1b3dc783d3fd8a774cf9a968ffc63d1dd36796bf079aa7a26a148bb8f2b08f43361be6f7652093e02e88c932a67121334b78a75dff9bd118a4d2a837cfb5e0761116afbb0a862ef551f1f1a0d42771ac6b951a3ab146129b2a3b346ae0aa8f08118ea1bb6b971bc62bf1c646c4d79e6e7ae783a2205273c8ace14f5edc7d15df8c4df078ad247999d01258a7134996225c95fbf685f143bef1340dddba06931ad2a2ea124b5c11e628c62223d8efedc34ad0eeb7a5effc80caa1375ed057de76d570a300f1f523b1873861222cc76806038b2623b73d0725e49750175cfa0f240832443cb61e91414d4e56cb90b143a379b21c29196216bd237f786624d7725d5407023b0dbd0f894cefdadfddbdf2d905abe85a7ee0837d1eb81a87ee2188e382164ae0908da8cd2ead450f79dc451c41e02d6ea1e5c75e333b502fe46f779bfd7a2c60cf7be7dabaa5fa850ab55f5f6cd5c32140c0ec00db3e1832c43a23e94d4cdf716db8cc8ec28da9d2eb0afb6e8874d3225c7ea073927f1c54545ab4cc883d58ab47f3b233b807c1ad84891241e3a3c4b330f59958980baed5c451adb566fe0f0acdbe2d100406bee0b10ea5931dc54c30ac86298d5e239952a46beea090950b3f14e755e3f1ea8cc973beb2fcfb73f978e16bfbc79f5f120fb38d0eb75fa942a22af6b898dc72e317e4a5ccd889b182299afbe5a362ed0adee5e39fb6ab0a6d6860a0769e50a478d9d966be8fd009b165ad070c7ed5e7df67994cd92b4c873cda5f0f3b26af731ec978a6d33bd82277fc2e63063c88f8d40a594c72a7b3c1bb84b815a609787e3e755da62de317941fcd7cbeff4f7254ac5b2617f5ce8a440beb2a75c80884f9a465ccd173c948844a58bc3f5d76678d2ea8bbb62c7a98c2d5a97b4ad919fe97069ee96b2561b52a88d9246c7ffd71083b703f168094a6336a8dd2030f71be0b91dc3a4939195e900fca3b74cc5f13f63806784a8205cdbead8481ee791f3c691ad16e06f24be0b48bb54b9e49fea0f4848e358d7b8febac4496d248e2bb13ab12a8d20400e4c25812d76f658dcfc39f1e24921e1840ba7275c4a41bd52ced3f6a66039d43f110242f3a4632a615ab2093bda239776259c44c393ad02f1f74758a0d5cddc0f488c5717a410547bff4af173c4a622f80736e7244df6968d985205936d1b77860bdc534d31de8a6e857dd8b0c679eb97ea917c424a7a7965b6237668dc6a62cf3fa3dff9682f80c0b977fdc0ee14113fd317387f4fd9174b83dbc1a13dc22a612c9ccfd6e57270cf838aa68d343893b82aa4c64dc75c16070f74891c8f29e49d4d69d437867294cacc0deb89f01c1ae4337ee7bba14dfb3b845e4f56612f9d577c6592ac0a292043cc3474add47340b0d7a1c8795b09f34eba67ac1013a1424fd57e9315b64f0fb6db6a06d3c7ea88818171f8f6fe298b25549cc34a655b82b6276ae4d29700520d086c9371c1ac9295d4a5d301cbb0814017b0cec1dfb1803db3ae82159fa60636a443bc84de1dc49627222b5e1a55eb42aee3b7d137a525753ae685803ce78631a8853452efbf1bb25ae6f9c9c241c01ecd923b9b8c3d551b0c571dd7f11b071f7caced60966129d1c2d78840fad6f0f869cf76b35e1fb76755ce424f5ee2f79ffa9065e6600757d830b35ae2173d636217fe7bc3eff68a3fe959846ca4ae0ef2bce1a8f8a7304e7dfc6a676b3e34208ad5de12978d5f0d770374725a4c0472160a79c29f32c96ec1fe6bc14fa6c133d9f96e0edc4742c96a6ac1263f23ce2a2a672f1da9361db1cdd5d5d8649234480c3f8b2db01d17b2d7e4ebb520026e35bff4c7a4d6ce8490cf3888adfc979de778ad0fca2fbb5d3b55888eabf79d3e833b262bf424a40209ebf6561e4d32fdeb05c0d89fcd91fbe1e6c190a3c486527f422f266dc372eb4e2d0577417bc0317655adb9ddebde796eb474eb6e9cd5c72a21058b0454dbf67a826fb2e252e33216521986248fb9e6dd0a7efc9d1a41a8dd95372ac9e68b7a77abeed5d41a2b31b8f6c6b08465f8bfbb4aafa2055b75a189a68811816830b16f052d88bdf8a4f3b8f1ba63ec73f7e686ddfcb5646392860eff937275ca32f3e2695a9fc1c4e004c096e04dad8c1813c786203931cf57b717af0fdb32a5c2e534ddfd58198377949b4f02b132571826d7f6151196f87f7a40729f97287ec3965310e0f2ba844baa093751665c1afaafecc6cfb38654fe9f9d3c3deaec240841560062512036bcbb0615f51130f3a626fef3731d3f3b52849945c306b458edebd5e03819e2daee8011fbd4e1155a32ce1e492b4f8157c399ef7c6820a4177dfa6e2d4a4c0a9ed1b522937bba12513f81787be46d2b00f3daac88fb3514bc019c506473b1eee9a8de891796614ec8bcdf5286c19c41087b1b38b91ad60b72895f6bafce4b9ad3d21d70f5899b729aa4546fc5adea3d7361f566ae7ff0d06c7a1facdc2b99115aaeb59f58d0bcba4a8db0f5826ed560155c2834885a062a312f8c7e21fa37d950949439926466699489c725bc7b690ed8f060b2a257d736657a49c7d31ad66277c829e705cb3cae567b4c00bf0fa0b5c60b122cf0f8b4997c254a6f8a0633b3bccf23876e2c879c4611b129a576bf225f09b0de041cb6c0ba172aa607b3c77f2860de15c8d65df0a296632e0a312e58e7fbd3fa6a3ab3f0153dfcd63039ab0fb93b9b3789dde2a7b95c3f6166165008ef120f7af680a4c1fb721be0f22de3ddfb013b921cf9baa1885c55024b79661e9c1123706c61973a2bd14e8e2d18816e0ba4efac07d2610476306bd592d5971e4a8a89a86ea6bd60d4f05657ddd7736fd660edb09e740a488f74a7584fa90811f1dc1fc9ff66210b71ba31e601c769b9088b9bff701eb45497f412f866fef952b96bf895de51a2ce587817cfe1eab172b0941c74bc0224765f52309da771a04ab9eeec723cb95359a5999c5195db069f426ba90cd986e44490b6390cc502df7c676b93a6a947af8c3fd965585617c5803adfbdaeec2f2f22402cdf74c2b50556b07e290139d0c659bfbcf359b1e1db684b56f9915b9249a286ef5c8c1bcb90ee4a724f9ea47a4c3e3e3ae21e79b757b708808dc69074e4e875366c21d32452a3dd4d3e485c3131db9664f23b0f5e13079c10ad9b86d5a2698026fd56f5db7c82ab945a13ddf7eba8770ccf741024e4d06569fd29fdf7e92e4bc3ea3b3776c2a6b09cf693822fe330752ac21429fbebd2c41fbab63824b3a9edbb606eadaf24cf908e5bf5059a497412b813bc51cd7dd12036add93bc6c7006c068f4bddd828c5baad61202debca72295a318607bab7b7777719aff4c870182e47deb14cba9a0a5cf2f3450e8f689968c5febbbe51cb10cf1bc4ab0d6cae9180a75a48f4f39b87a0ca9b417717988072102bce92a6d4e12f318fc5d19eefe696a895950bf9618f1a18000ebeb18b1a99087349ec2c7e655dec3a6f3692c389c640712d0a1c9e0e6aa49c5c84e4f6921f61b3a6f57aa94e2bd969d5fb2f18c84f66e1d5b2bd44c2a6240caf55c97deeacfda1782de2981651a06db9f52847768160b90c780d311c97ccfa471f28a5cddc106c0b7146ad5763c1b09ac24094b5b999f2bd2a7dbf2ad58fcb81c99386d0e9f68d311e4f32d5ca7084eaf87069ab1a6ae9ab05c9723649b7f1d2b6d06350bac16b711288a71515dc2802e2d765e1129594e053659ac23c8285ca0b76df344ed0f59bc9a977e179191ce7204dcce233451abd818d5db7f15dd7dc4a56e18bce4659beabfbd31d7fdd04bee023325f3588e647dac67ec84a14b6e0bc032dbb2471b3cfa2193e1ac322f6eff96294f826398f662c894aa11f495de59b1693a3f4d35eee69792898aaa3501a78b70a29cf3d270d504396faeba442e326aa99892b103468c9ec93796484d553ff0368e32de9a2b7d4624ca47081df68c69c171cc6f8596af72686395017c45d2dbc2152a663deee40b1805c2b503fe205788c354e250b25a5b3f6e452703c7c04e8239609ff674c859a170a51c2eb5660319048a1bdb7ef4abffe705a946468f98bfd50088ebde0f8d724849e677c6289544899a321f49ff637ba09485b36097bd6ef949dba0c17b20ef60def3d165b59b18b4dc5325a00f31722aae058aefd726c97a315c5968377fede8930978d72065db2d1aafea75d2e879b68dfb8fc0a17116dae670763ad5f1cda152adb33ecfaf6d2e29f26766eeaef22a30b110c630563e0058f57374f183a6ff480d1d6bd9a9a7ec5107686b6a6ed5ed0e208c553d3689f44b7ee83620178e8da98e62932c8444da5dc36373956d21b68e24c44fd6f56e0664c7f774623b3271866952818544c91b7074d1418de5e6797ba32f3d57c611da4db8cca00932032a180609541af1b933d227e8488be9e25d6fd353dc9d4ee3691716dac6293f7c45e21b28532c2f5a351cba2395ea8a37721560f421467e9d8aa5130e823d5b81916649f05dd93991401a79982361d45908042e9440bb609761f832e575d5ce0ead2b505c40aeef1a1c67b7839a912baaf4834cccb9f0a3fd2f9356e94a1d4ea9fedebfef5fad3318ff99b07b9951b587738ae8eccb35ab0fc1117f84cca3ed225f1db693b6f7eec9771d8ac4440a8282ec1071c1470dc6f8502291f345d311ee38120068215ecc437bb9ee547c37bd9895b9d8089741e043188c397511052b38a377f12828836acc05224e0d5e574094449db01101ced5ef19b3725ab5388d91322f60a427f82226c6d5c4de5b57b38f34ca7a9905b65c1759dac0b9e2260ea8d20dd72ed21a9eb91fe3df712ae553739963b3a21430f7cabab873b5b15ff46ab785cd3111e3cab0299fa162bf073cf295a9b4cd079ea541d1e40bfb542fe73370a3486a697139fbd63a6111d65c0f89c97761fb365269f9a2c92124b52d8bdcb792f05612eafd3b9d1b2c9a3451819c8b2ac33e3438fb75245ce89cc81b9406f81da3ac205119d818bed6191e98a0d0162059ceee2d232c1012a84cddbf289b83cc1a1968e9b79b1e6f06bba491ceab2f9626104e68311896558b305a4ab933d54931f4dcfd9e564f56162f60b80716373c3dd2d6665e7dda8afea8f6b6a35babab721d31f40be2f25663c99421f449646e3f7aedff134a3b4762b335fa6c6a1e3446b183009edd03c415705d4e6871a72062bb3dcedc8c56776e007b6ecb32f556e2c238e0ca5d01cb421a1fc34d5cb0597fa4ba16e4d7c7a6bb81e7858f498bac7a9a4b01380111cbfd6011a664efc98f1d51a4b5d807d6f947c66fead1a55aa7ac4df13735542ea90b4fad32a02a0ffdde039978dd515e1278b268c1225e8faf57b562bea92b1787c6d1f54d2f7e5e202d7b12e1e490ef21a9784eb5a6d799c5a12938f734ef233a79ddaf7bac1455250280c5b04b7128faaf63e761ccd06d1025fe2cc6c300e5270f358f782a2da6323e1223ebf8205bb1a9b4c88ce2b3ef7d904a1dae5d93556bc0a562fd19aca43aecf53f786c5c9824db94c5d98d905c07f90594851ccbadac511346e779146923cf94d9a1d4f842b7a579e26e2143d81e503332e831698dfd5fdffca6d2a8663c494bd832c866677b2971fca3b02f2cbd2b40c34ca55ff12c5514c71fe46ec2301641f72c7521430eef46f40a652a115ab9f1197d84c713d9d926f1db390b500363577a4232a04addec3297dcc7b1da4ac33f84d27ffb0443c266cb8a6294918ec4f5d7be7dbb90859c40d45f18e459a15aacc6cde3a1d7d160207d418e15446ab5c06df4798ed05fb2c1519291dbdffc1c277c1f562e37db3d0889f61b492173721c56d582b53dacc0bf124e5ac45a100969233260ba327643005ae1cc15371add056b1892dd25b92e535dea5c983006fe871638f43982ab74f16cbd1f6c711122a1a3169a49ed6b0facd8cc58661cc47ee0e6cfa3cff7c243b07c9928e7ffec0c5904c7a8cec21961a0f90fbe07b420be62cb269805ff5924a6aa4e2370ce16f4110247270c0be59dc6c40361ecffaacba53c93a22f27df53df3ed8f5dc97890cce35fbc86c33c7e81313b69d7adce7c253ee4ad25af49ec03cfde663dc778cf5cd32b5d34275cd233388b63feb75b0eca02d49d0d5cfe002dcfbb4e5c8a14a512560849b4c8f6a8872771fd0b9e4114c1044a477b2b8a2f35058d2095e6ac20119548a08747aa97c1159da91cbea78e09be3b08fe59f6c789654f99a11b9e1d62efe3bd6805094f4f2cbde3e057bdd1280ab46af3bb5b4ec317cdc00cd3db0f1f69df567b92c6dc47a104194d58cd455598eff99df1e7f360fd4cef259aa642b72083cd9fdba2b0013bc8b90dfdc80a7fdbd55e8c0e8872204d5ebf192d0d04aae4bf90f9a0a9342c0073c280d57043935ef058ca8054ccb70e5300c7dc662a9f0d9c79cc50fc1570219ef1ecefab932fb720ffa65767408c578d14c969f515fbfcbd10658c8bfcfc10ba454865054b1847eef0c3e2507d02b50266e4859a63e86c69ea613dba568fe4dd3402d02a9890c8d1f70eac82d03fd2b0f95a805c4e8487c2096eeb48bfebefd644b371029933fb3567bfbd63c71d3d78bcb8bcdcd6c628a03da351f2621aeb4f6bd036d159fe8ace3c236e7a39c59dd964b391dd91f6888f30216e2318551d4a31cde81ee7877f00e5dddde4324acdab1a08c25a64a122d0b97e1f1f65bdcfcc8052c2c1a833fca9c7e2e81333d5fc0c21a028dd0c0cee6088bc05d870d94c8205bea0e06bb6f862f7e59bd7f246b02fd3275acfa0f873de6666ee6f475ba8fb6ca37a8ea70e4c7426f36131fa417bd5b937670439f8de74967c50357736748da0ddc80ce0617df6cbf6cb0b5075cd4897d6a0fac1a81356aa50732372047ca46c74d6f1f45e2b53f896569ac29a6d0d2881d6a1a403ae5d1061c36478616052e8e87f6f49251a773637d98ef603f5f5e6627fa339e7c2bdfb191da0cb830063d34cd4407b8b8a0e7cd1c6c9147db9ff6aaeeed9cfe1af61d6569054783d8cc9b407173704ba65f2ac7f9cb8c63f1894b22cf652df9bb551a999c1bddddb56251126bda4f43d5a8162b1b19f68ae42eae681349bd843c53e59f6300508a7d083192e27e76eaff6d6e4d383a909fa2249181d0dbaf8942960eabd805c3a504141feb7a8ce89561ac77008358073fc6eb4ca2fc4bbb12ed7d39aaba2066b4787276be35272954f92be2f9edb3cf1bc661a16e7b4d287d5af9881d3d2b9ca8c439502b91def34359a2082c8ff4c0968f604f38baabbd341a488bf44006aaf0cf8d7939e2727530d5320b0aa6b9c9cb41027115f287148415d04cce3827fe56f619d24bd5195624f3dbd011405f5551406174e63f1faf7cbcc63d63b48308b88d639842c8a22b76b0609032035c899fb6c67bb4a2200c5a3623445bbde62f7a5d559ca459c91517da4afab91982674f8d757efae4bdd177a1e7b50d3875ff6d3df65381ba4224cd90eccc965384e2d045801a22d8d93655924ddb31c9c793c1bd96ba511a3c9dcfe5953c845a9760f9b67af0e6e52418001c9f999e6441b1568155c6cc391569e1ee43f8a3e90900d7fb10147ce307e5c711fcb5b7c85c92fa5829ae3f26493186c6ad11a71b1d69bced6279be8ad8ce38a0da21b9f95f4c1872d1f3813f2f18274763828351a2103ade49da353cc8be430cbfefb9621588af6165017177c895878a04d45400fd1a1ba6b6ec0df8ac4ff259abe604baae756eb0c64615ee0c0c26f3246b84ad9063caa20d48d954241dd85589e1f5318d4582a8b977304719e1f958b0bce1417e6868cca30158af80f9565ce7a5b00d1d10aa520b7a19a97b9af8f6deb1d498a30a6811a6f06c13e2c4c1feb9a1b132928aae03e17a1fe0c016d45357fff8aba41528be5e49e6265dabe9c218c97dd519b1b454793b8bd3d64e71bafe691332fef9626de28ebbbf998fce4b878124eef91501555b5d0bcf981df0282a350eb2d499bc7423660a90271f3ccbe6101b06b8cf6464f710a62d0019888c7dc04f12d69e8ab7c1f60653c75729f5ef71151b64b30f7facc860f8a3945f5b294ae1dbe765c16b117b88db52f449f1c6574b6d99b23df7b03924075f40ee610ed1cc8c4437359c08e45ead5f14127f293c74ed5031912be76a5f4f0ce4be0007483bcbb0bbafc7c2d1dbc3aaf489ac409dedcd1ec90085838c6b9122f2b6d36b57b333a6969aa172164047905e7990b3c391e2d92e3b00b3c418e1722f7abd34c2a1d2a729528b8797a516d39285862f28e666b25dcecde94668c490d73290fdfd7c37ac9538392328d440891e36b607ccf246573f60b6a08e5e02a6a0f10a002acddf3de7cc9d5035d6f1621ac859030fc8231c2326749d107b57cf2cf11319f754ace0f2cee46fb5071b634d227614f72b5fadb280f068ec69b4279a09c4f2962b46cbf5f1d9f9a3da1e913f2a331a20b0f9ef464cd4d8c0952689314ed776ba2b48acb310ef99647ad992da72f94c575e4ca88279e53bf012e52174ceaf3be591d1604c2ec9bb83c09dc35d445c99eed5834bfb369bb09db80","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
