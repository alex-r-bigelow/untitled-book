<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73a267809d63e7c2ddefb6b61ac313c752ee2facfd9e738220f731161356541005a9124e52333bde216f038f624f3b6fe7cc7669e5006e64469af1d7f48a214bd668cd4340c1845e68658d9f715a6d206cdd36cc6aad686f5e86ad793dba083690da3cebd11ae495dc3e64480964f44dbadce2dda80c129b7a2a4717a359a5bdc248c25d437b29ff70ef856f220d6ad4acebf6f7a6d8d6322bc815852f2c5b5974e47c589c3409609849a2c0fb37e2208b0062694bfcd75f82346d8798ebdd9fbd6c97df37da6f8903ca503e37ac6a807c2e3c09c6ce77866eb5f107a5530dba0770a04a37114fa4f47fec06ae7f889dcc6622652b030f4e05cb72decc78ec14bf63747c63d63d5242091e8a6cf981b37d46465bc877e5573d17fd6dc3d99ba37bb85472359ac20e079538c631809b87cbcd61321f4ca04ca74c6495cbac2c1e3d894a48f34537ba838e92710644f70d6eae1bfce707499d5a8cb65614fb66b2b2e9b4586a819d60bd2b8f1bcd63034f339c15385a51b45c9b75b141f61e90a4daa6b05637c73ac9696c3985898e93bfd775e81b0199afe9753a86e1c42413d50c28837a4338f7ae5605264e43a3792312093fa328dd707b704f8789677112586f75da9cb2af4dfafe5c475f423d41192d9399539a051fae67c4d598b46ea7af0fb47e6ca2fc1dbfa6c1732eedc54a1513bc8b19e41cf741c50075e52566bfb89d2d1f7c3b292b70ab99a99b6300672d6bf4789239b11f0cbeb6ac315fda40d7b785425133deecce102fc328623e3754f3d2872c1636f3ad383ab4d7476f356c5849db42bece4c1b4841f18bb46b360151b4cb74539a595e3fb31b832599d36202ad064d3e1981a34705d6659f712eb5413aa326b7ac460756d0b3b7df27d6a87d0e5f9a4a13f8f78667314de5a007db3d41a4eaa9c38e2982bfed21e20fee4a46c820798a9cdb7d8139f8752a251b2ab072788054a7834b7f34f0287438a7c61bef66e2f18cacaf44ee94b910fe2b61813eae5376a592620c506e833e5f24ac74572239529cf447bed81d5123d8a7369b0209f5a4799fb2a4a078fe0b875573bdc9df196852aff548841d705666e0aece235c21ae1b2fa8c4fb237290385e3560b50ce25cebe13e82458f3c74bc8f74e44069db8b73243a705b26b77299caa267f7b4032b3a686783103fc03a1ff6b9b9805c27055f2fad2e99cacc46d94baa247a7bfe978769ed42530b876cc74c93ff79e962d005649956253518883c614a2299dd374c314d7f6bdb29e2a1e2de393996f1d91b7f3d8763743f95c2ab8aaa19d74f34ad5196014a954d8b030b9f2c37264a2ca8fa435cca632c0a7c4dfbf90052a02a62be9aa8c680c48761cd3418b76132709c48fb849b97faaacdb2a59e655df8ea28ca0c8975c57f280b7b0868d39db03bd9b00a9bfe255f1ab17525c9c76f59d32c979954db55f417bf1661603ea7b2342d82dfa3da4a5104a7d9a5bc81e31c958c169a796db564f365ac5851cbe05373d3c511302cd82fda7fd72ea8a9d7e9367ab3ba09f57c934dc9b0be7cf1166ebfe859c4fd39726ffa5941c8d456ecd217dc158d03bb4f0024355b5b3c310387454d8ce33766f91a7f0291c996d25ca9b17cdbd71260aa24590d212323086303d0a823b0a7f1dd69eea20367b01f6aee10929c0d54359dd1ffb14bd3183970d7048806d1c0a1d7411c849509ab15a1934af24cb005dd7437c29e7636d482bbeda5df6d0409f8a286282e8f78bf8ee348c83e7a869accab3440982ee18ec965e86bfb123f354434b78c326c81a70dfcbb0dee8edfde43b7bdf016147df0b027815df54fb00a76918ffe00d35e2da0e4946e78c0d56a619a86c92e0595dd1cf37bfcd61f646a806a793474b6625e1beba00889d1059e76ae1aa1a74a254a0adbae3c67f0eef9830ebbb7068b13c38677d73cc28c9cc0fd5e75a2c30141216c7c67df52ce7fb783d3c8fdf64b220b893c9c84a939a083d500fd078660b363d2b13bab9057f81424a2f2f5c75be70187048b690dc09251e9ccd936806b35da13f8512d0175015b7803c83e7f88e40615f8fcb7aab4081bd2e8375ffe8a51b07eca91062aa4962015b1cc775cb06d71f08f755ae385ee507a5f723e4d3eafd9c928e9c796d1c3e7b3971b6e0d72610a0d98f4803c2d58a383df36bb552b2798f252eb5805ecc1518f664353b78b75b365286db23dca0c1a64d740faeca4f999c4360b7bedb17954c4bb1565a819087b8e16419b09715b1c183f11588a0eb6793e18997d1ebe985b72998ba7cd014a269c7c3e5b03cd7d7b3b0f5c1ad419897c1a678fe231edf4f0fd5258505659f9487ffa88bcaebfdcb306cea8e5544d11525d76af50644320a5f6c9e71ede99bf1ac44c4dec7f2937e26e211e9db53fca4ef66111452f6a22fe8fe597457959b24858b4ffd24bb80e1d7949f33b6a0565a9e4795c9f0b9b87cbe9d50852fcb326d585867d3a59e33a16e1f6151dbfd67b5ba7aa37192f347c29bb4083a064b2b4fa8e49c9d933b58675a7d0bf37378d00f8504b1cf5888a60013350e72c35d3ea7da62926bda8a709a5cf5ae9065b49c87950379b4a17c97f1a8d6d60230c83912f13f4184799e79997e31d4f469e20264f3c688283e940239c8096202bfdf6c1ee8dc562799f034dae89883334e7ce02e76940a8dcf8e9fa0473709389ecb274f67f7acccc8cc5a2843774d5cfe949d3ea447ee369c7c5b41d38c1e87592d8d060961f94abe146e71ebd52a3ba77304f9624ca17d939628071674bbd1f2878bd06172bd810c3a3becd77343fe981dffbe027f070a57177e4b1fd26b5009d5e86835cc671ae752d8fb9a3517fa1f09de5ed932fbcf374150a5af157b88a0697d491d2ade87dcf8496d5447ed8f501679af855c700f03d926e8e5c8bf105de6dc408acefa270d6e15bcd26f55aabcee2c19d0bcd028eee5f339984800b17b0cdfc39def600248da1a209f5285fda48b5ecfc2970f4126ccd9ee10e2c5c54104674edaaf744ebbac006221990b829f4288fcdbcdd3484070a563fa2c631cbf931c2e91567c8b45dfc6b4e52d600a0d83ebdf00b735192c4d15f7226e2e71a9513801c9221c24ac68af3552e7a73e0d4e441544337ad8bfaf9e593da4b020bb11043a8017182c863d19272e3bbcd7dc2e1a68292be4a7d19555286e21dbc6008f4c04625a5324c6926883eb5b2bedd35c6cd901718f4f7ecd35eb6ae9a73d5e04e10ce31d62ef453016671a5bb31c28666d069d3f72f420c178c398c742d4dad90ebdf627839db0e50a82dff9c8ebb0f8720713968504bf4e157fadfa21aa2950f20fcdf1f0f9a5f4975e8c7ca93279e6e855bc9284c7c678818be3d379397a202efd96178dc0547ca28747cfcf1b3bd5904df962f8c11453ebf8177cf9c010a5abe5f27cf210551217625d63b2a10a46c878b5ff0bf81e157b5dae79d6989f3eb168ed24eb9e264853b6bb2b2c1fe44f3a6e7b3eadc4908419df45a47798005a020c3e6a7882fdbf5c09871277a221cd8c0a17a40d9b47db46bf0034ccd1cb9e369295cb1fc57d3dd0a493301aca6249274b368204390cfa6510a7674ef11162622687fb774c9a60885eb6b06bc43f86450a1b44962442db3fffb9a92c757b2af8da5a04d06d539917425f6e965f55151d298b6e7c5f838eec62f61e1e94ca66d468ec81177f4a4f1118c2242bbc7b663901f7cf0e250ebb3641a85555061ae4598c94c03fb6f618e8793d149ed50dcb163cdb0df3e44daed7952c1b4365eb3480c91076ca73c559870d4570e743e8d850d00880a27fa11e8c58a80f4c2eae750b23aad9f53bf41acfa408787ec1c290e6f31b41f01f8e0434bfaeafc67ce2c8d038dacfeb3ad4ec2b1f934ede02ff79f909df611ae81238d2e3bb5a7d0f3c40dc126b2c4622636fe803777950ada78d4d08d8d82b9cf45f8b6b3b9f9a4d38b1aacde1d91b9c0b9e76e496865c82e18f45d7fea8eae3d35bca1943fbb620d684d85a2f97ce043bc6a49f456c8ec51a1f8d4f4ff87bf091f675327c721a8cf797f9915093bd8c1c47a75fcf4fe983a66f3a7b76a5d9a9743c5e4fc388017cad8e33de9f66620650b4bf110935afa31eced543cdc49042c489945f37ed2591675d16127792b8fc64b60816a721d8fdf5f70ab747e3e46cf76b17526abe67f26ad0ffff19f01ba33eb571890dcc072a65533edc4a62ae60454b91416f596f5d7e782e57000f4a048007c131ee2f2f604a44c1725a7722db511aac0f7ad7c35cd145747cbc9f7c49e34accd6216c86b3b287bdfc7939260054301b21da06408ceaf349778e5d03183893378999157f63d36bab53ac316abdd1c3fc74e897c595a58c8dcee89bf248086e8a6ad76bd3ab9856d80e1cf27a4fd3fdd264a16f9ad6e22942c8b0cbc9428080f8f85d7c36fc378ea06b2150a0b9d9faaaba879f4298fec80493931d51888685b060fc71fea78c882c1ceb809d1670663e1d00ed2c0f1d7a6bcc837ed45e575e9cf3dc6009f2364a8ca0bd1a931231f4d359ce3c5e5852359e179b3373e9f3c51093765213e0c34b31d65fc89eb62863969e5519f6667a52cc473c3ba9dcec2565b10dc69b396a4b6bb7a7b8653608602eb92454fc31e262a16c3a3f00caa9ca26bb4a86fb6e3bc531e5f46d9237936c38e7faf36c6fc7ebc2c8a0e190d1728490c18d47a61ed02734b75e445665fdcb103f51ddc37f2b57a8cca77f105ad2cb9549e1db430f8dc60b575c5c9b303f2375d70afee8e9bde87793283a0bb9dbd271c73ebf03ab53542f9cd341cb3d67ae308264c349a979041a7ffdeeb8dbdca85e69e467fee54883dbe74b50f0ab73684e9343415980b9228b8f304349e2372e68204ed9c78005daca1a3ec741bc5e1fbe37391f9f477e25c4597f5379fdee3ead679259662b00279a092c4fde9325d91d9ecaea5dc459655b68f61d390d16ed9c92e7b9d5550eac7319fa6c6cfd575a70920230f285b659e8149be698ae9531fffa11c5c4a55fe1e858d70d1433bd02906eee533ee835fdbc5c48bcf4e73e34eae39d8aad43726beb70ae6f8b16b3abaa5072665baba45aff341d2bc24beceac9ad2733692a11c9a96a242450de727c1dd6334e8c860c76e1d38352da798bb885564aac69cace650620aebbe68a3b1cce3c30abd71f8ac9ae8cdd9c1827ba21eeaafc2e5fcb58965ea8503cd10c0816084ca8cb95f679f140e3f36c0ff29d9e682dd06a0e7e0169fabc11657418d26f82d1d88d711a8af24fa849bebdaf03527495431fcd0f359cd99ab0a458d5cc60221e304072a8b65322140540d5fcd004337b3c113b5f32f96e3440c850bcb8482243fc7e8e884f7722b86f920237175d37bf611fffd617b9d9ca0daa66632d711182bfea9bee9908d1b3b628b9f2e4a8746af9fbc69c5366b73670266ecbabbc5837dc5adffd4e14dab4109ab385a206d6a2e8563ad9f3bc4a0b196cd47437e5029f210a222bba5293dc658e06c885a50452c8eb44b84888a6e19b9ffe939a4bd99fc356edcb15a5ee44cb168c0f17327ffd43caab01f1fb57497596f65686f267928a35c752e7e8ca7718f0f3c99aaff6dc8672841c78d43b2fc53ef8777cd34978a566c83961a843c0b6206020c8538be96f8b80c227563c12c4ad107ca66efda6a5b9650c04c75bb5f0a08d12ee23c61eeebf7e01b3ce8e8ad0d2a00f3aa30581e44a632683bf09e74c9047cdcf47240dae59b6c0dcc96e6165e8c80af3ac57ad8f67dafc7efa70a29bb78c52053dcca5fc03bf2acd672146034d00a4330d40caeaa11ab0a2bdac29546a93b9ec041a36ea6101686fc806546ed5e16fa78a22713f9cef16d515cfd4b7383664e4d82044114d9ef5b39a36d90d35f47bb6672a4f3005d8ce8cd0571afdd40b0f6c3af49f7009ee9eee18d4ebab32f5a51721a6dd262bd2ea36060e5db11b7166d644ce1fb01e880a166c252248d13d3d954e0d9d9faf1dbdd762fc0916435c62024379944f2f79084a106c784ea49a5ca3637be2220aa4cc26f0c133ddf4db86ba64fbd8afbc60728d6f1a73b53ce6d7e54a336af3fe732f4170c169674b70cfc04bb7f70e339bee6e07abdd059530241e66c82254f241ced1ba86eb218ae124ff090b56e0b8422ff9398aa2cbef58e91c306ae52b172857e118aa4f38fd03ddbc19531932fb05fba02abf61357b78b21ea8b73852a2f744e14236352e7856cbe53b33bc68d6ded50a04b24e3057168babb1a66f11c7373cbe0e51dd182df1d9df0e1d01a4e5fa553a659854eaf6b5a73d485f4bb6ed91fd9616875b07550251e79b1ad8a5905311e7020cfb1a159727960065c86fe80849fd43d59509d09a27ea20d950f04151aa0b3edf20195637d9b581cf8e5d24b9f5b0d8cfbb6251bb21fd568668aa16b3a80711e331d806d959ba056470a7bfef653ed1c8de2630d18384f1d795d5d031cf5abbae763cf465024c8a029664f60b20fdba810cef8eb4d21b64630fd3cb2c4c6d08d286e55e30de854cad440accc2e1de076546de19fc152179b63f85b1b9574275d34c721c5f46659c18406497b857df0ef4f74801cc4d7781f777b9e2fa10a3a47a25e64ee5af2cee72aa2a1c9eae3184907b0c50bd68b7dcb3429acee0ae4fa9c0b47a430341a560524ad349c985601985142522df8fce900e40919f3697662b8d57701c85694e1eb38d3dfbb121089a3aa7ababa2d72652dc05093ba56952fda5c7fa780e8b7e1236e3779001b8fb962cfaa9e09b07e6b8f85e4c4a33dc470b67bae5f4acf26ce468aee3e4e222f102c42843ce025d32e79dfa1b2128451d04c17689732af206fdd6d282fee57de69816cf03bcedbc55d96fbf07017ef3ebc72e7d1b26ff022afb9f6e7f878565c94780ad60921871d9fe3e420e960a4fb610ad0dc19290f64879e377d862ed3b8a0f97568c9aa97ecdfdf2810e13c3ec0ab2b85fb9a2cd9d084f23944a6f5dd98187674ca60c49cefbeb4ffd7eb7a8e882c9d71343a7326e40a0057235d9ad4b7838ceea3feb2139d4fefaca0041f7332530794c7040fd301cbd9422c254d580edec5f4692d836479b4221f22673efe83ed5490a01bf8954e5e2232cc6e98ec7e1a0a172be501614f8ed03ed888a998499dd30413d34ee86ba2ba829a18915c4896ca6c865c7d2b6f48023d4ea1be752aa0102692716b777f080d0d1cd050e93104a40b12b6dc8e5911254aa30b1753b76ca65f5c4c94b21330f809ee221970054d611621e1fdf6bbb7571713a836097dc58fe0e547e595eb6bd396dd76299aead9f306071044b0fb591e4f188c6d7f2317f13ed956a709645578db66f0d5b472c6c571500c54cff80efc0bb08e1f4af133b617cd4dc242bc62ed037b860e8430a2b87e9add6b57cc4a7ceafd8ef1c4df12189fcff3e05d1f67c5a7a78d2b0e9a81ac67c7a1ec0efacb5e11c10d03bc81b85bc4fe9193b7d27be7a60914e47431689d97803f620335a0b1929c5963ff1f07bcaad2a7ce32e1c33c2f9923818a76fe534ee0fba825acc1d76158ff24f24b86843b3465eafa665a55b7b0959e5dcd82ea76070bd72d7d7de7ab349baa67b6b6dd30c350f5a9baa1d739e76f10e49a6b9c233da31d26554984fb64b0748c1af8cd0e9d5f9eb66f199f54aa2e6ec7d15eb4fc6da7ef44b70267d85cf09c642987aae4d1dd3946fb860443d543d6eec7559c37c6c3933fc61d01f2471cedde4ea3caced6437b2c4bdf19d6c87ecf18ae71ff75007847f648feb52941d559a5eb5c4a0ce565a34fc451e9a66a53d53887875f0cc1d5142225e198d12b09dc947d9ca1778a691fe836e29803d19d5928f59f2b5d535e4d29826faca0b6b2c76baf7e7a8c40f7c2c964824f1354bd6a5df9eeae2e4da1d06658d9cfcb946e75bbb69b4dc43215a2e86c7fb3cc893de4eb7ff344fb7fab15aebfade6dccdc8966dc6eb4c3de62381b22f0427f74582b0c52e6049f5d161292f340642a1ffc14c42b3e0cb037c080a28941593a5fa463fe29d8e679c81d2fa6cf883ba8f6e38fe6db38a15434cf5854cd36c84e0c59dc9b381faba9a19ea6001882f3605f66d00aa6a12122efeb0e6b5abffcf7df11dfd046ac8d04f1d3cd797447c68226da61db4edb071cd94f0a0696573fb4863ee58522d3b1acb2629ee44b875272a1de893f2aa342899e7e0392526768881cfd847b9b67c346fa432d338849ea12876c658af3a5a06e85d22ef48b123ebdda10bcb618dc8209e2b7649d9cc4ecf83b57f615ec3a23ad7e144549e2cee2802547f15b2a07120646a5493d9476fdc557aa13195e80487ed11e6e22dbe383c272170095f4e24843c459c5f595d28e4915801c6f335a9692f34d088fe86f84d44c952fc1d4a24866262b173c4619901f569cf2dbce66875d75066eee13a9aab7bb44664685385c9cc659266dcc7dcf219d00f70db7d22440cad38eaf54be99dbf1326288d966ba655bc7704466d72c9d2858d32f33ca0a392d9d1190bbb1c6403b04cbbefb688d5f32fe8e400943e97b6435de265f465456f02ceb59d3e246bf36cad39facaaa7a1e6599d2cb9824051cb09bfd045f66fd44a170c9a10f233e49dfb224c1e9f6f2f67b394d57701962eb9d53c7361988c61553e09a6d92b8ed5790d5331fbfcce3d7d06e2aa1c2769810be9201fdf1e9750df421ff9affd02f8fc8c04b6c76b2b4a0346b4f44e1e1c493554f73ab3becf9df5ca9d37c411e3561805aafaa20bd0db13db1853774e6b1a80e442861e503a09d766fd6ef01fecefcb0b7c146994594b6353a771d7b31e5abba10c161529f9b2783bf5c9de398223dd45eff30981e745ff063bf55618e8031b625dc2b1502d995c0e8e3a4ace1b1f741054462dd8374dbd4126c779e2a1ae6c93e55c39a46639745933ebdbe7f1b82c502ab9231e65ecea0d784ce9879210ee0b140b516d41ae3f8fc6648e9fa5f98da79e65213bf8e3c9a56bd85dddfa764565df174eb64acd863c6510a968408e836447cacbbdd7dcc7cca51f8bf4fee0f1945de537ae44bd9ca64a68f12eb3e576de97ab9be9f51d1271e2382621d2f4ab2ec42c70134946e99f1abf180545ea46d822728f874b8d51f74cf435d60c138a4d9f2a17b1b5e1e82e3246e3df922a5a93ea8461a06293fb96e7dbf622e42f6fab69963dd306ba2a043ff59fd9345b43b52a509fd132e17663f3450925a903925bf30eab654e51ac0912c4d586a558d8ce4601ea15ae2d2cc3e1558e62e17c17eb101faa405c5a006b7bb574a03952aae57a66961b82fe2467256fbc9802a42f8b90b5712525f780723a30a07c77d093919fc5ba6fbd2d66c5958eec6eb79fa2b5baeb28a7a02ffccf7bae78a2bf974f103a8d7ae3a56f5193d57047725da8e61235e83f0f8f087726f9e035b889d76a8177d29f38c0053f0f53c0f69e3d45ff278f22b54e9e333ecd4e68bc9acfb7fa5b05cb4a7d8c05c69044c828443e65bdd25ec6d6fa28d97fffcf5d9a1691f2f1a86e6c937aa2d419cdf19101630be730027ffe818cb5dfd99ab8d84145b3610df8b60d912e246d7c532bf9b0a3908bc7a0deb4c3ce5865c381a38bd9af93c3531d72291d2ebec9c8d1ca80145f27e252feec31760d4b1b138fff723e40b5422a1cf5ee91638f6f449bfa0bd7605a948ceedcdc63712a9e42774a771ddc669fd84eaa0b7e4a36147f5e15542857c8465980077c91cbf279ca6d5e8129bcd29cb893f8b76588cb1de431525e55a75166f0daf08a595419fe7c48ad628608d747ee7d35512418fd3d1ceee3000a164edaf4be5af5086a5c95616e4184b66ddbdcf4343c6d6c982a8877113e8424c7bc5319daa5c7ca83f9aed5e8d973f1b3cc7899ec30966464d6352fec009c30b19fb8d165cfaa2531afbaee7efe5995eda34f2077c4477d68da5df5e4b1993fd6db4cff8ec3e28c86c5202396524d9e0372a717d9206a8ec2af2efb951f5bbeecaa006c4ed5eaa0c859f0cb33a998d2439d375daf859f46e43f9959e007bfd0311fa47714d8b7a1d4a3efab6d085a61a1c0edee7f33c1c4e52782bd13d879d1828f46398ed380e2009d1c82cdc3be9f7b56838f637afb04c4b9cf9684ea8fd28b8aeb21fad9a9bba68be8b1a15de11fa098162523087ee2a6b2bc41f353dcad256d3494d05bb6040bcc989d0f77a2dce29b5dfddc9912774b49bc4ed14159b31556dfccec2590e414bc8d3490331061ec1162300f7cb0a52ceb53cac2e55902a55c1db82ac3c916c45a8ee59a248fdb58bfc022647bc610685e3003db3bfb160168b7bdebb87a587ed1af44f8bcacba58a21c45edab79ec49fe12aaa2174a7b392b363014280d10846f83e408e4e6379214f27cf1a2fa079e22f04a7d6735d2ef262a446ddad06271f70e0412134e7a02d4276dc9913e5769cbde93bd9f3bec90e22c8df98c6d1bd8104ca06152752648b0b5abef5ebe4a72d04ac26fdd551ac69bb2f4fb7cff85539b85ab0cd6a6e449df548fa43c201bac1bc05e612649bf4bb717635a690ffd04a07afd01e0a943ec402bbfd92b495e640c5311ec0389b2bee2c377573e6b97a30cc26df7a4d200ba604468f33a41e711f07cd7152a36811417d76a45ff3acc8a9f6854a4bc28f3d467ecf7b0207da899023115ea9285ad0b5f8f7a2532623cbcd7b2413a87ba71a526df081d8cf0550f759b48da4c627575a584063328862a725888fbbd9aeca5bbc0ff0823eaeb8d71cb399749616c72c849cb074cd3e503984a7e0822aee2321421c554b28379b149f4e779526586a33ed0cc2162555ae4fcab12ec88b2f52f224b51e9b2e3102e3894e34a9ff0c0d7c8a646fc73e4c4435fef374a3de9feafb5adb90f4d2dd78d2fe3b256778b159d99a85f7ccdb36489747f25f75e1ab9c4e46a0a24de894b64bf4bdea02db831a94d4af18b315343c0a8b6b985a1ab89e7f1dc057b54db84b16a250787b23d0b0a51db52ab1fffe815bb34775802f0ff4d42d4cb70193d3fbe0aeefdd7c1b67536580f99caa6a712be6d879bccc38d30134570f0e16ca66837b63b06084ae0f4d226b32a1e5caf0eddb1255f3b39912f667a35f7a55a0038e019d75e09a6e7977d10ca33f1fef88ab92bb042a81244ca3101d2b03a992735d185b0695c76977adb38dfa444ebda7b44f6e2d33adece342cf919ea7e08aea332f7703792d875840ff109e0dadf9c37101445dd75ce6fe0a6b49d6b4483ed2c06e3176f81ecbc90a7b18518f614934b140554572525a129b5cb59d79cf98f54e696e83413ca69e9f911961c5c8fb2b609a2e1a84023caa5c10ea77718bbcfcffced80b0fe8199ed6153d8edcd44bae5011978b144b5aad07c8940fe021d9a2fe7b212dfd6a8dab14d6bedf749d94d396564f4e12d6310e553677a0ee8d144038120aad88bbff95d4803fdad97af28fc27adcd1b0776d6ec1d320755060b0895abe72e423ea35cbaf2032f5f6c0f47077f4ade95ce747eee98bfd524e449da3cc2b85fee28cbe9c4c82afa6599911907b7c11b85ab9689eb45a4ba7d7c37fa68fde637ef251bcdc9fba3d04c89d5c7c6f06f16382c214b291109708898f72e31a0df14e4b3e004d8ab0b8bf94920ec3013664cac7d98b722a32179ce3da28956674632e47a11d0a4fcc38bc664cbaac3eb0f7bc787419cf0d847de26247033f5a45b29e3d4eda5bd12b26e3a1bb6aa63cbe31cfd088855102af755a6ca9aee4552c404f7556a35cec52c26a0736ba3b9c8b2d8615ba46e80895518cffe81209f7646462697c427a38c1486252a0f4d84afc1ca4c7644a5b137aee093f0f6afae03c76dc5603380bcb3f412e0e438da21ba98df6458883c939903e348e29e6b90cffea759e0590d11aa2f157493ab0fc20b72df817d65187eb35dfe7b10deefb71130a2e6cd6537117b68cc1f1b28c873ea1a8e755ed9ffada1ed93d258daa43cbac70d3c5a6150d89cd3170ab169653513399ee411b5a70f5eb7096f15fdf41d5626b25949c6cdc02e4b095300fb476a3b8a7a5d16ce924374c63e1c98708dd1ad6d1355c63c40248cfbde7ccd9f37e051f42538499c44ea24f11ab081ff8decf226e94c05ef864504a968f2660ee0e8917a3eedf8ded43a635eb6b91ed25035531b8f7e8045178dfe827f12a582b4d6832f06c2275814c447e72537188be6e5fa705e16ff0e87bf02c40c2654bfc2d3c314f0c8ce5076cbc6f83993331cba15cefe811c096bc3d2482739c96e856b5514c9510de055c4aede9a94d91567254ab70905af7214e8d616bc7944cc58ff7343ece7b39860a8615ebe55387b5b4f729906d1cabed3c368cd43b13aaad9d2b2e9c72fa41e4e09175da511fcf0c13384a64f349dcda802995083b4bffeeb3039993fb1570ac013391b95e3de26db7a1c981b61d0348ac830a68ce9cf4b69a8ae9ba5d6bb24d6ef8253d5f90fddd0f5792d9ad8ab967e8e7b51dae15f715a69ac899f452def825e299a305eca034495ca59925dae9d76e596974de8a576c3faf37be07f6710099bb895f6e470627db3b4b3e85d91da7aa2cdbde2460c7482c8e881d69e110674937423c98e66d762ab071de00b94a18c1e37ad31fa021bb8ff8477ce9f02d93d2328d0839d4bdbc715f0caa01a9148aa11dcb2b058ea15f64e5487fa195970901a4bfb9ba0cdc4d4711c61b14349b4432a8c2b0cab93159dd2e4c9b427232853f53f59f0bfc15b07d6be3a64c388fc2d6ddb0b9f876f07c9c7df7b029f0ea15f2710927e96c5fc5d0b8dabe2935345767119df2708facb8612b23e030fc9914661ee6fcd0f669f33a734461ccb3724cc9d1771380b5aa1f48b070aed33e1150bec60410525043e29e904756084db792f82baffd9f5bba09f950da736773409f8010ceb75ce26a8c78f54a7f5af0d53ec70e9634d7c2f1d16588399d84038a53505a6e05fe8132bc7580c667920dee7245dfe2e6a51ef494ab86da88f87f4d5a41ce5f25e1e410c427a4d2987d5c421facead43109d83c533826d1c852e76d6ffb08aab708851c8b6d26076323dc56be83e6e51e22a60ddecf57051cadaa62195f75bf949d66353e0a5f6a862f60e74170c2c6ab7d85d0f2b40f3728bd838eeda8e83ca1b1fa6b511c30f37b4c6491e594c36690b9c4cebe437ccfc455600428ce88c196336ec9ec6b7b156c989efd53cca5fbf9f3713c444ed5aff9926426e7f20ccba9a482b6ae1832bad5a71bebf488b929e5da3fd4344dad046422ffa8c22063a1110344636fae4f7c3083839234ba1c1b04f37083908618cca59763886e273302c958a4a2eb9587ca8956d0ea54d05d878e32f80a932f2c15b609c20af6648213aad01b5c7ebc226303a35b5c43d8367a1a62f3b21529b2b3f6548997d05ff55aae88768847a83158a19a08f1aba1a05087beec6705bfe16bdb074ec1bf65ed06f993265324284ed73cf514e5832481f49d463531ca202d7e36a87c97afd6e3f1c9aa70c0da81dc1cfd493e85d9f25a07b41ce9a088fab3d4fa20df6eebeb670f71c082cb81682130d26cf7bc2729df2a20a187438e65254dc5539ed6d7f8f943536a75bb83fdad94367b40b84855b10baa5cd74259a04f0edc4f87e804d626cb424e518e2e618b625730e954054d4cc335aee026e8a901f76b2119bb74d1ecc2dfc597fd80ac374ca25a4f1b88163ec32edde8d5f99d7bbdf65118feee26375f32c072f5130dc2c666461c67d6500ad656a686ab648a2da92b1cc4767c59f733495d964512bb335cd00942db0d4a956d44cfe8f08abf045d291956dd92ef9f2db0864cb1387b8e94ab91b5ad54371197caf6c9e7cd5b8d73e9d015fb38b75f9859c397542030ae45e7ac77c25b2f57f326abf1a05870e69c4ef237e2f58351b23ea3a41c0503fa13674cdfaf675a8e05723680c2ed69c6fe8f9e03e84b87a487d0cbd8c37febd14c9bc09efdcf1c22abd7043fac38f80223b622add8bf7893cd649b182cfea525ea37b1eba2353c47195d96365c2e89a7e8bb84e5b32ecf98c0634cd2fb340ed4cd738dd206b72d783af7bd674368b256de940756080ab11b0d9c6d503ed8a68873b34c43692c2161372f6c80b223fd9e3beb68cb370993de13a728a1fad9d7f00b099bc21c13ebcc2846b63029d71c8e35489c22adde17d9059473100729c1eb173e7bb77c437a6d81e7c1f133ee885f00efd3af64e3f04505aa9fb8bd1d8374b9dd1a4054326227522032d97c84bc7f113ec43ca8913f0359d3691fa2b32baa9bfaa023092a378dfdfae942f822d2f161d0ee77f5b20688aa5bed18cce50fddceeb42a36733629ab573a28b10448b4623a010e261bdb8e84f07673218604cfc4e8f5d44ccde2a882774db650840b432482740a95ab64cc049e857129cbbe030835b6898e41f7739b415cca4342d838d1f847f8f3276bd3096893dee170ec4d47e696360f54a22b94bcef85c6f900c2d082fdf683cc3884c4c274c4e597208ab3e0222a834a50c20ecbbc2f0dd69a8fbefda04bf8e67f5a4059cf2a4611bddbc183b26ff069b453fefddcef03d8271f54de691262037248415c2b46263afb229bd5dfdea7894e6c6214160e4d46bdfb0a6f9203d124bfbd2ea2087a66f723012db882ddcdcb8b55eeba19c9e14b2dee2a705cbbce660b8ba8372ec54bdda16f88c5bae72370444a8485263f7772e91302f11aa2a6d30e7d616488480c6d62b5053ebb77440bdf0dd2e6ffdb71f5e188538e78366490f2c05f5d32909eca0951e637835b1833eb565fd072d21ea0117f91c72aebe8ad5d13ede2189e14c0ec4e093d0947676fcc049baec24af3b55204aecb4cd32edb0073823d2429be1d7acc89221f6b0fdba9231324872a639e51d105913af8074be37eed521535240d9ae4b2a03f41dd12bfbfc29da2fe209987b0c9de8b01c46e7e204e075a29e425c3dc30deabb5c7746a697c5dbe474662b5fcacbc89827f278cde6aff36db9cb5e794d2124c06c4c128082ca743a37de84fe93dc239fd1231efcec7d4aab9393651e8ce1e68372f2acb02a5e39a7923a35088c384ff3fd694c430bfc5d182a63526dfad6d4949724817b02c952206ef5141f1ee0fbc688dc7a5cdc7ef7c3ee67d63c43c9d5f4a3f39e429612f656dba38ed75750834d6d1b830fb7f78ab09a2f0b9ee9740d63398d02c3c0a7c20ab084f5e680ba56b464ac2e8adc4e2e9fb4a566c523557aeb9151be64a152b305fb55969ba49420a0cea2c688157dcf3af40fab11c74ae5989b686ea5f6deb488d6ed0b932db056f9dccf103cd41e4ffd7100b8d83623b03f08abbb8ca02bafda9b164515e4313931d06092a2ec2f51271f2f2642301f067f278a69ea7911874edcac5d8a027991ee0dbf0d6a576c385facc2327f268eb2f3241ba3b0815198ddab13399d53ad0b8374325479582f24868061a61b36a8b48f0abfa0520905cae77a6d7f8df2bc1bab00d8cb0ff4a5c52a49898986c15609f1c7d4eb2ddac75feb69fe38379dc649fe9752e87c61562a3ed834f83629a8050b18917f7ac80e39d758fcb6b45aa9ce1205ffcb2cfa56fe5068b8f2b4a247699e15e78c4cec20bdde67178e517ac073eee82ed2df1df6d5671dedb3ac2d48edc45794c6e74b2b7b2fb0e140c7e8d4758a12771006a7c63eeb1c08dabbe4e6b71ac2d28112798b37f5eab9b5890242567a0c4bb23d273868fee7af7b4e0afc04562d020839e696a5555458f9cee62b705a0a728a1e5889c8a32f4336e4ea062a98e48cd069bcf3957ce6d77f243c5f1680bebd57f4ddf57bdf9863173546c103f640353fa92b7a289e8199d453fd609e8a0fb834c34e0e91695bc70e03ca9a53bbee62aa61565842f7293ea8022b2fd365fba517228119856bad33d23a393711fe1876264398f63ab2b00dd060632125a9fc24dcd95981532fdd49f2bf05a0564951dfff5bae78b4247f0d04ba53491a122fb6204d862bf3e1e9d59e1e24ee110f94f2ad31bf5885667862cf9512e2fbf0f65a7fd6285bae72a4594a6b54f4183a810af9c5a9adfcee63a790cf7953751b91c68de8bce89468bd0522b751b7cbdb4fd7f9e184079a17d356c76d577716d86b12b5e92bb67c1be5a8f4e23fb8afe37247c976883432abff1a7bc1c7544233b6e145dd86d5314036f0d9b8cf0ceb3806a8f10991058726d48d6d39624e5ef36b34935ec95c1681f9397f97269bf56fc0991e26f8de29075de2f8fccc478ddf3cd31aab65085ff7926f054d26b216ad8750c167c8ffae8d8b4fb267d484e7d671e9d8fe3a2291c074cef9efd29ce69a7d2454a56aa951340b2a5133f2d9e45171ffe1b4686b42cd25693bc4c08b447f95acf187d8c879bb674b7325727a50f28b65384a16049e1133edca55f596c4087e52d28e18b2dab895f6a9d255b8779605cf5337d9c4aa6a4b5d8613d638abdaa8e2abffe0c235c291ba2b7f39115a0894f90be334540f917704f3ea73d31014c89d5425efbdf4c523715adcf473aca658c1fef6518b08fbf30fb5f653048ac068dc1f7fb7031040f39b8c4ad6e62926f8d736a89e37573b3182c375247d214dc53667cb4a69db124502a60b3378a48863c79491845350c3912cd2174e0ea2f185b1ec251d1cf1ad007097f13003528b5b5b8c14ce79e94e9531033a13ccb7ff38922d86bc492b73cd4ceb49b76ec1841e0e20446631a42cc46a9c6f11ef6895c54adfcf2da0d6737304befecec468b456d230e31bc7d5024ecfc259d93eb022271f0cebeeb72f65b5105b4d7be65e40b5e95522e0280650f4eb9556e05f463e649e3c85d0ff4f9ef8aa47d16ed698e9bf11f1ba3e1befc9db6c6841df207c6dd87b8f5dce7c63c8fe73a593c12da0f24f629a5427a98268925398fd21246e6b32d3f731f69cf4c614d4c3ae503d14de7f1ed4341ed7728dd96495a7a9d4c4839e46e439faf461f62585195d31128f15dcd85b84ac10fb2d3665458165797ca8c7c55c50af99ed86a6a566aba26dc58ac5127c8ea81fa4d3890545522386cb6a6d358673d4066ec04e8590fc6f391f0e439e0451e237096045bc56e40fb72268bae726f71733245ee10f13a6b7fc02238b116119beba54b09d2c4110ea1b8ced3265c87d4769eba562bc9bfea86c0b54b83a75fcaa37499d8fa2342914e267f605a6cee26eba3f56f065488a85253ba759bd33a2298d7abe6a69217830e493872efe3f4f7c7afd64cd60fd1c24799a0f34a3309e046d9ee01f3e0943f7d5a1b26df57d5c8aeb16866733583966adebf7032b1b9944ed5eda689a072d78463a2728f73b68968ddd7efc9c8809cd535fad695bc58c30ccb6c3f24553890597820e2adcc2afbe0f4efd5d05316394c972d82ecb56e3af1ac8fa2af27fcf61cf8429a271e958c006f6725675769b842ada62f3445162571d84c77b878d59cc64e7a0823d58ada70708d0720b6f3f5334402cb69f2de8a61a4dbdcbf19a9871c6c3d638f6ee4e25f091b1c044f86091707e220d62b190b4fbd52191049b6f647762b07d8ab783e4b0ff0809164fc784bee2d1388f5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
