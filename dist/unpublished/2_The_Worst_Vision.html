<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4a4f92f24c5b01a68fb289853d426802fe8bcdb26df30a8f9f18ec92f63e8ece8dea538903861b6d52d9d5eec67a6ec09a0f3c38de6806b1fbc38fdc6ba4b109fc273060ca8dfad210121d0f2568d5f1603c3bb84bc1c6d9ef134286d4a137c4c3fe5bfc86a2ec3f41e0d8906bcc2a9ed8fb4bfc369ea59189b4ad886058e2dbd398f223508d416f9e2a8fbc38adbd89e875ce780710f8dd6486fef1572524f60e367deedb29103d08ff80fdf3e8cd4522ef83c44e26a1cdc28f3a86a4e54af0a48362dd92dbd15dcaf99e8a2d974db5ad4909116dc8a98a90d2364666e17b2aab6e1212be3de7409b998afc5548178f91adf2d2882fafd033d7008723aa525268c32a127f5d3fa9392df63755354d3e5b3967dd5e437d113fb814ce6e0b2f5092652ee053df4c2b0f56cec233932b0abb20dc050f6ea6fd2fbc1e54c1497b30a80febb51be9ac45b04c04026d9b8bbccc958d8951ce295abcdcf66b62de87f99d4a3ef244add3b02fe6ca46d036c3e0984817096c7dcfac78498df6c24cf28388200f8c3fe390c943ef04f24e5b3baaa71bc04751603e41f96a4c5827443c9b6fae0056bf4a07b5187345aacef85d3044b62e6431bfe19b92f01b46311bcd2b0b74c4dd79b77c60ebcd852d96b8986aa3ba3bb71a952a98a02a42b71df80bf468580e04497cae5cdeae53456e204eb2f39a43df2c6d0c389409c1b289306326803c46ff7e0f795dabc609bde0cd80b85150216c3821244e3b65731274debe205f081d3b7d4f82f359c76544dffdd9956f3bb41d84ac71f1b5692347efaac4901276d61e50395fa4f797aafca9a1a97902faa08dedd9dd6429216044b2d504775d8ca3e1f62ce7b1ef35c6a01fc6ecc22323b44824d77384725e7c5c369354150dca691f3046157339a1ea4687fb8eb1e9aee8c72b5b00807d3b99dd3106699b3288079a2074bd1b91c769e090bf4b3f5d391af8a251fcdea84d22843b592ac95d408603b132c7e26b33c30a866546c2ac2a0f98381331884a364bb4c7c6619855f592088bed07d2304a100c7e7cab33f73026a99c768254f4fb3a10944c757d0c0950abc1b97900da8094a9d847521b5eb2deb75e7ff2e990536cc54700896e5b2675880a0c506a56e2d4c99face0cb4d9b50db3d3d115b14262fc7af6729e93df0c870889e7fafd67196dea3ffe45cbcf671c43ad95e61dc66fa0b8ccf046d9d5cbfa4d5bcb46afb7a211072eb7e78b13f5f2739632d7deb8f5c673c136dba3c7cb8170df97b5e1dc74b10e541d4af4bf4518b14e5c0f892e82e50982f03359f6f9dd605c052aac6f41bee8f7af3204e02a685e59465475ee214fc4a8a9b251b1d10dc827b7f173f8d1590a07ed76a7c84b4d02ffc13fa5e472fc6255a9883b81af3f22152bd3ce8ab028fbcb308f6bf216beea3fedcd67d997077a93a63398575f94905260169a351fcf420c968489aeeb993b34ede7ac7ea9a4715f4feb626522f5b0614f98780d0f90fb42eceb08084206cab6de88cbb7863e38c00c8d3468b54820b0ad81fd87847989674a2d5c66befae09fbc52b67a04117183d5def369dfe2799a2184ba6b927df003938954829416cb8bdec5f268076d5c23ee3b78e36f0c73579ee76b9bca8862d81db58313695c46b86fdb7d75ef405804b2d872ed9aae28b1717072efcaf67175367473e9228a69a8c1aab8fecdde726142b24a7fa1d0d7fd184797b710bbd4c8ace9281ebcbe3ad221b75ec1bcd931233143ed74bd748647b4db93bfad2cff4dc8a8b961bacca04c6c05c38e2912b16d4ea034b7fedebc9b537d3574820d9cd103290f163c7cd419ed28c5159feb87233a27faf97d29d5afcdf68e1fac5820408a8beb4afbbdb1d877468ed0c39aa9355f521d85b270fb1da3d848ad1796fc88e893489dfeda0c590a995f876ab19a8ae0f858f28c5d713bef09c7a0ade2c812ee9d0152591475e6212fe3f0b1fa3a3e8907913c444e1bc4c8c2d3a9a7b4c0d50e82dcdb9f4069a3701f4ff493b9f54979484d8ee84a6a275e8e3deffe56ef1bc48f1a33e860012f69845275e41fd63d83d2d936236cf4fec496cf9b9a388cfab68cde8ba79eda7b2eb328bab14d4e492ffaaf509c8f5ac6c59391d8f73de32e0de6761043159f5ceecb306ea4df801608c8169c88fe9576b75a521187e84a2221cd5481e177cd77749fb230f475d9e2409ae608175208d372e28e88e28222e4f78e4ec7462bbaa1e14e9a15814820eb799174ff9bf314103fd8fe8ba360726dcdabfa28a5998725419fe5bec21b3815185cd4d76e3b1f1a10408b624e9a8cb0a398080f3303c959239cb0af52d7f2ad019304ef203756ba9973479b5a81cf62cede54db70cde0ef01b6dec8b0a1a7c7ced5b0eebfcc6e0e3215240d804ed154cd9d25ab4ddbee35d50a6872dcf6b8f9fb8ff7dd119f71fa4503f1f837625bd2914d006b5a443883e3587293277cd5229e1aeef642c73975e4aea6bce3414284bdac22d40d25aec3e82a2974e014a413d248f577848c3339e5fdb4e84ebf1b5d533b05d8292dbda488efb49b1bd5fadc3f370d2512df6e0bb98dc7d31360bc0fb23b4611d82d8cea8e2202544a337a167e50068057648d52bd413a0a633818835568851d23d1d8798e60c97f78cd56d8281e0f1c8c60bc00e76e2f8d844e760d9b364e8eed9cbcb14667482170441a034ba762ae156f3bb68a98a8b0c83dea5189003a1f2a94afb602dfc170ca013c9cadb3f3d91f588847473d450ee7f13c1bad1d17f9747781ef03e1389070ea8958d14e5160c7c08da9595c5e8db3650689e8a0b590761c1777a8434349b3883a1e7597b9dc92514a0f269fa632f4d36986706c59213a6906fef57ea383840dcb47b15a373551aba4af1bfc387b0f77e5fd845a8f9f48a12739781e15d1d61d030bf0c16bd6094fe7319cf1d4aef5b18a96f3340c57883bf19370ba5d10a46b073b8b1dddc079c5c40a4bf4bd1a5f3da3dd329e5d9000a0c311b4f375f7399028e0302ba0d66d76d4c99b49549afb03b8675dd17086f544a74171f25e60ff686fb9fd4b16512486f10ed8e925b8ad404ade38ffb73023407ea925b9b8eae002e4e20e4d6262c0a52765dcec2f868c5fff353e067c43c3ed9379083774e83efaa50b68837aecfbfb3cf160dd2c7d74314537bb9c1cf80236c195720c95ea20a65436c0446f04e9663b07de023762c94514e118b251b1523758a7d3f83b4da02d54504dc390a654df8d41337abf9117ba4a7b01d1cdf7ac4f0211915505fcc7645c235400112bf3d8528a2eb6565e2e295be20a0640b82a15ee11d5417779d3e3fd3551508386bdcb65f2f03371eabe2a95c0976968d152b0f2bab58e6a9a86924eb826517a0f9e472b8b27e9d19c798387b320e7007e50681550dda4e48a21b98fcf2ae628fa349188710258f7362d039a7394ad061f775f1e40269e32c7097726077576d6454744aa096e56a481fea27415ecf3740ae7ccbd7d03d2fe22a82faa6b277695fb5508501062c947c908cf5ba90cf8b5a3451026008b36f7c637742504fb817beefaf7dee93fa35b2aff9e8bb3f64fd1d3d84ba8c2846e69a0095c0b37a91b590a8e595a7287d8f3bca5d943353b603e1ffda24ef21295bc1b1e3fdd365602164083eb713deaeccb6c79522f0e84f4a96664f58282f357b4ee48644f776235fb97162bc784b5b02a09aa580a46255136b21da4e4989be6ed7ab8367f48633b284094f490c6d057b0c4b69c61ece470d026df89ac12b67a1b9c04b733319a61b163016d9bfbc4b8c810e7a3aa450af3dd22e04593422d81ff01ea5bb39865903331f964239d1080de66d8c3090e6b65577880688e0cec50a02c461769ebc356762dd98f774150ea2e8dee0d03d50ced3c39af3039166d2ddb54d2cbb88686f3771134ee19ea3f391142fabc73e11cd131af1f01ab5c93fb95325a12e7b39c75052c3c3438aea6396b1705598bfc3516d8d8aba5117734eea8c886206cfc305ed2710f10ff276d5b554e0b5eb3efaa55629117628865e212fd36f498b3e630ab88d9ded4f288cf0f8c2c3fcb7e807e59d228e8f7e83aa310562835ef1fb5b451863dc153b3d0e8b27bca63e81e095db3ef7e6a9a2010a52ddc69e3fd614cd1b3ae4b17d26d4bc29c8c80e4bba60729ad0d2d9949e3acb1fbf5a04dc957e996f6ac330a3a235d35e76606058688b25803112083b5a14d00901abd8d76cda90a0843086f3c3d369c66b66d419212a2086b1d9e4612ac195c3cfe2db246499acc97d481e65fd9e636309180fec370b442acf073a23505f781484c40d52b87cec3c8b2bd65b8759b435fa166393fa48cee282da08dbb29c712c8dd34f3885b885eebb9fde3133fd583d3356c9d867fee9b0df6365b3f49ae1af929d482139e0376ef9cdc5d6ba336938e41997e35f15b8454432b98e380d299724d4aa15c78dea8908239b0760f4f7c27e69fec82d3ba95f10387e71d499da8595911c1d0e2a56ae8b2e6b6124b9bba47594d6ce1013b93029e0e1bdf157516fad1d30c37fc534076d71c4dc82e24ffb1b9ca6aadb39a7f335f691c799ac9e2a1a03f3b40740823c9e0d4f80ab31349a8d16a248a6b9f9aa5cd24db3b87f8758de161b5e12e72f7750b10f422a1a3ceef9f2a374fcbf323960e89295c22377df6acec5a6422539d04f211c5e1fa636c180b4a123e8c58d08a738efccbfe1eb6e5ec126424d52cc1bab6555d58d812f0fe0ef78a77c1900f55e6a3989ee5f192bf7761554be19ae2a4adaaea0c9977906ca69c21a5b2bd1411f9bc6c75b0093a70ee39e15a42268637fe13cb3d4f3babc6da9206eeef49c068c203ef3539a5d475da1ab8062d9e1a99aabc9a9fb8c12a72bc0418a79d632e8c4d201d38d5ddc933ada8e9d845baa90257a48873ede760c08a5705da2c90d0aa418b5eaf03dcd4bc9d3d4bb8b0b2d9d6cde089d0e7835a4bb7941a886ddf00ded36c5c2d900cbf341a752cde7b01139069ddec23604d2087cf714e1dae78a2b24759dfe91f5e3fedfa3bb918d70db30b045e723cd2ab16148f332098aa404ddb068805312ca82abdae228186f0857508fef129e01551be7dff85b30b60a80d7dfe2cba335ce4668771dd0c8568c1a878a96ec383211ad48dfec178e3fea893c5a5e402c3e53df766764a8c7075f0e3def1473f37f86d1fee42944139f2d714e610a1d5c89b3c6e6d0e9bf08ff2b9005b42d554309b11a926d9f658ccaeb9c4b44e5e59f30f6e914bbc24afd096683ec9f40c4b15676e7f23d9824072f3232a5a11184e160d78ec3d18dd3bba629f8b65df7c2230f7c42e66952dd24396de56a3867b629d3f644ac36c5486c6a9b12c77785b449823cf5ece8b8f1bb54e1d1467dd8f565713e8e8b45db32d950d89eda339328bf8de5ddd65d5cb18f405f322aad13cb85bd9377779016bd75e6656d9b0c36a271aff0eb529d6834ad9373666ccbe8d2d8aba7ce7dd0c1e12aa114e99efe3ed117d29d5d41a43ff1c0ad731b23d1d14492ed8acd628bd88f3e67deeb72c3388076e525ad2458c8d498f490b21f1fb6810bacb011e0ef186804da026626d6a7842992e9aac2a715b2b04ac30b81291762a72c21a4c345c41bb3723434d0f8765049fa4da6c27ce2f48306bf61c2a1727d5a3b022f0f34a5d121ea25bcf96f722a7f55694ddba81d6003e57df40fceac3cd31f31285fa2944d4a8145e4e1a3b987964d14694bcd9f53be7aad9b12a7bfa341d24a218e27ab6f11604ac1d659c3ddd2cc405a095bd6f6de0bfd86c256b47f6d691d869637767d402b72b16ead375ba4b0fe3663b2520672010881d90dd56a509b80623c35f562444e898916e9f2829041ca100ec802ba084950fde2ea3d3d02e5f540c34a2e3a76dd5fd39342cfd31fc57199f4817c95768236b7c29352970d9904e057bdc0f9ffa24a83d3dd3ea51c159959389fa57c871142e4c7df125fa4a6fb740bea7d69bde50920f6b68a01e32dadf425ce6799bb3f3865d6ff845f0052d5608e970ef82a374c53630264348df23c7db5cd2fa70e0f4fe56b576d4327ec38adcb148963640977e04293d45296cd11c1f1260c53420872e85ad97dd0266e9d4561f41f130d7926cec3f2ab1549bda19ec5e61dd182fe65e3b7148acabe88b81729e4dfdc6b1336530313956d571361ab8dee3a9bc3788a5bbfe19db7357ceb775757e80046d1138c5e188e6ecb5ad6925add152fc69594fda70942a1a03f6b07869981d661f6c22fa4783ecae6d65a6a68a9b9402e7d6a8037f3e06270f7732e1fdcf3c8eb1909f858e155f3a5ea654ce7170b25732e90042fe36fb9537ed564ad1c6e6a2e124e4eba9c079287b4a7443e364c9598c2b40bbbdf3420d45d68d8f21cbfd7969ff903c377236d4b07cbc72cfdb771dc4f42506916d926ba758ad97561b018aba8afb01c7c67562d5d7e3dfc17b89b87dde58a3564940b28964e9fa85fbd1769e638aa58bc74c1fe11ccdf4c72f32b68f6cbc81ab9f13fe5c85057bd0e6f9ebd18705684e785625d710519eefe72e0398d3ed18f03082f324e259393fa48ebc4ebbe0716d60c0d1c1b00a9e461b3161020f725bb7f6806a3c0bd1645ad7d01129ac856ee94a52dd24fc7ed4984ae6b5c1c67c5907baf77f274b680f25b3c9eed4a5f1afe40b4d850fe183882ac0e7d378f57294b6868559c1f9e3adb4bc4b22e55c03701887056e27c6a0d442ede1e2c1cb2cb87ee709c5de52a606778c8952c877ae19a134d2d8d6bd49652b491559e579bf8f12d897351cdf974f9de0871941cbd4c71f6a3c7cc8dd88b4eb2c6a67833bd0d20f9194bc5857f574e54d5654cb306f2ccf9a45db789b90692e9badf2a9dbb68757ca281d379cbd3371eebe1b77105963a9b4c1556c00a58ebb6777a500f811d42569bf283e2c03dfd05c31f5ed425f7ea3cd4cc592005a8715f2a5d5ebaee50d50a3030a7fc923e0f2d383b80cd24aaba9cb7373b9417f2af64966bbaaedf63e9a706a0eae9be0033ee84b58dc3b9a12b6e31b6e6f3746ea28b104d467c0b22dd70e7933f622835989aacc38ceb707480be5d439392f25a47f90c287cbbeceb285e3c86fa2bc8aeebd80c3c715339aefb595c1c48cef227a53580469c3defee3c9a8e77053a71790c7c2b235616a6c62abef744b788043a1f9b245ceb90099244c53b38545f56b6896f6d6eb4a59c8464670bed8726544465afd5863c7816670287c0bb891ad9246be2ec25f0243ef15677ead5a7ee6e50267fd04dfb304a59ee3152fcc0dbf73aa82e9fb7157fbc76a2d4ea159b477c86b80fba16623c435184f5e58884f3ccac6076a012f07416b7e298cd053e0e28fe1295a657d443c35ed32a5be94e4d818faee48d33e89f8c2a26b16b0e2d9a6f7bebe11206d4a50bbf63de0ff68fad610306d49fdd61bae1a91f0d698315489434803cb3bcfd5345072e5211f70174960c3b4671488e404672da0dd55837d3da11341386bbf382afe7964ff25052a86d79bcd7cb8bd95e5106aa5b7c4b1fad5202080821da92039e2ef274e13da657df87fdc1ec44ff8eae7a1fca8ba89dc1580f017003f364db4898b3e7256b5fc50bf565a5cfc8baa5974f29622b1ac58d9d1cf79079cff79c1123b2c655906a9edc1b41bb1a6715764c540a614d053b8fafe52af94b83172d838493286bba6e8d4240905fb4a6bd36e3fb6105d6eb1711deba0da54613fc01e9a0cd84f77f35c88c1b98591eb0b81ab2f91d0e809f82c888459741cd57f9e632af230f6ae3d4cb49c81021f0217ca0bfb89253a60de9b23e098f5803e9f202b9133a269735e037ab15bf113f9d975544f057b87b96fc8b8939a9843612ac7b2f59465d066bfda7566f7b384bb8f18c31c241356ca921b5221d6b0c406c5cee93973169dfef9c7e907063199fd6867652a69808de67cb0ffbc406dbf9b8913314b13d5a57c2f5db0814a2d65e0f72e4e3cf98808bff5631391c622e4b70b026c2e36b1beb99c345afa2495e2c9d08941c38e992b11ad6188f2eb22234196adde334632f1049c12b47d5a1a63c6343d627e7b60e1c97109cf24a63db53384acc25a536346583863c1e864e44c1777bc7578b63e34c6e7a11683df36412c66c970241387aa56680153615cc47e22d4176b7eb9d28fbc44759f7fa06665f22572c65c38a7f7a3c29a25e8fb7d56776e7a16362afcb1f9b891e46b1dbb491f6e487946dac1143a848ad6bb8b142e069cff77c4168c2d17bc884874f032328a5334b8b9bf016f1481783f8ddd0a6a95a415fd399fdae08ddb9e1f52e27e3643567a2a8db1d71dbe8e37932ffde6998442e56bd7c076e7f8d7119f39e3f916bc493936bdc40da73e0dd63df57627e290a37b6cdbf93499a0f9d071dec3bb80315a8d78630edc601986a5c944f3704ba93ded0ec4d5337b2df720c2381478b2ee86e2769173a857fcf97fb9648a0b38c34703e011ccf8f07683d22e939d89fd6d5a7dec83401143aff1064e866ec35114dd3aeb67b90b0a944e4e86af0e4c3d13aab75fb614a5492edb58b70710519f549955bc49ef35582ce10db13b164ef58f8e7fb468f086649d03ec2c63ffcd8df30d1349a15ab5dee1897b8316a6ef7f30f5c0cf77a3d23492fa8b6756b7a266c959d2a1082fa4676de16e1c430e4fc48f5597b2177318a751cf788eee3a837fa04484eaf79b0e4425bf3dd69df92aaeea6d57ca843d08c49689470b1f5ffc9e1f1228945ba8f0c7a45a2bd15bb686240c50036cb00529c51afb4441e3b737f0e3a6cc82245411aa7e18451bd57e1a50d825df3f160346a3b25fb073456d6bd0ca497c80b5f464ec0bd5cb8a8ab289d5e292145e3fd9decdc295febf22a368ff07060edf7baaf1f082aeb12318228406448a4f94080bc2eb5485edf1b3396ae2b50fc6c116a2098a3b26897cce499ee8f15f9cbf4e29ec1dc4921a0ead0adc06f37f6f7e40119637ead760b03300a34820a38fb2ca7d4a12cc29e3c7922c32bb0124e4291f78fd56dfa102e57ef81ce118326dd9469bb3d15930a61420188d4ff401d549fa106be8a3522aa94f1ae5c35842790a474ecc371c0475e68463d9d4091a8d91109ab6f7ab654962c0de0340e9978f9655310951382a8875c7a1741acc66951767f833bd5e09013ea6ba38e15701463f5b577c2dae75a70e13bdb3c4752ad87244d5a62dc906939b61d14b3e7e34f26052fd00ad15852ba38580825ebc38c5b333fb0f78a6a1c8218f9a20b00a707fbf73d3cbfe9960421c536d5efbcccf824bc1d888ef3715921b895fb821624083dda683601ea171ee551c0ec05ffd3764b07235e5150f4b2e0cc4c2eea4da865aa075cb54428e96bd45727043e7acc9df3f5841726806ff0bb13bda92bfa66c25161ab7952c7aaf37813ea4aa5024a9c5abb5cc6eb3b797e231aa2acf0a940f8dc4520a02a2424e3258ab87849890b4b5c88d45bb0c32b5bdc4f5e4451b2c3dc1356729608e0b639a1f3cfcec7f5c4969ce2f42e8bc3e3436aa0274b0ce098ff13e0f1d7199814544ef58c65b9fbdba300d81758a7bc3cd3f85ab75461b9d337728174fc8af62d95c6bf6a8ee4ffd8e79fbc2c57c17fa660aca207baa4827245456ce31f12f7788f8e79e4763a4109e384c41f7e5621be116a549e0ef41e333e03b9cdf378cb070f7f38bd535b2402f482feb2cf945e9bac6d3199987cc8b3a530642b8a7e848000955559d61a97d914515e4ebb23239a98584cf731fc911778b7a3c5addbabff30a36005f05ab379fc4f67c7fc8595103226cc32bf878b669348086235b662b31c110d9e89c9a2d59aadaf98785aa4a788680c45651933d2623e7d23f19a55e93173722e0f9f915b08589c5aa854dd2403ff16873aad8f3bdefb7c7488c23221bbe473b90f6a6f9f0f1b0436457b5d4fb390ae4fb7191eeedb860d168d7f67c31e3831c6fd2278ab8535be62870a934a4f9f5a72deff2e0c9b92c4aaa3155b31ee09aa7465f39a7c8ef6b78e42264be0a9d983170c4a4e279c25ad549cdf098c7f916aafb3b1ad7e34ae5c3045fae9a72e14a5b1148e2bec60915ba662377f0774e0547cbec040869f0a57fc54483d7d4a4d31b5361865fd0560d262c16485cf910e34de28987da4bc0e87f01174135ecd4d5e47bee70fc927a3c32c8c609cc2fcaf1afa942df47395005c279235fc27309f75d1771b77ab0724e297113a473be622e9eaa38bbbe57abb655a0ac45d8a27b30ab8154ee780851f77c331e231827983b8e25bf21a5a3861c79872457492ac5c84a05c6c972b9e28382c0f802981d550eb1ff9ab21080cbb41c08ddfb4577c2af7a8cf0a8620c917bfab4dd2498d76ba5c008117bb0015999871a79996aa4fa0fe7ebc4164660e08a6a4577c6a9a2b95032b1adf61fda8d6cc481a0bc6765e46f1d157687739de39764a678feea7c5a1f3c6ce0888da7f9f1576d9847ad5324e92c3087eef379aa08a590a043440bbba6a46cfccbe71d4d194d08c3c891f88444f0d01c3e8d50a5dffefa62da0e93cf881e5fd8182835661e2aed98ee27f8d3ec0c260f5afabf38c4a80b49bebf495962f07019674871e637c2ae8da3c9ad5cfaa7182762fe048282aaf636b3271ca72da0c655513920809022ace43d91bb86e1fed24ec59eec7aed687c38ced07df83f345aeb0e231eb2656644602929615aa0ce7e3a5db618fa48565386d82bd5c5ebb7a9cbfd82e95badab7a34ea74a85cb350f90b77ea2ebbb93f407611ffcf1a93e426987d8af0bed2bbe490b43b9b0f59c19e5eb30c9308ea3d292cc5c627244bdb2e6c8bddeddbe336d40bbc650765df5dd1a36ffbb9d56a61a67ac3960498ae89e71d261ac92eb73d1d346ce4f875d0871f2eb3b1a93d96552b531c1b815ff189785d4e2b84d1dc8fd7a1c5063daaacd6c4192ce5c1db555130a6d7c1f6e10bb8cf2c240439ce4d693a646c9c1973c14540e34da321b99576fc824f9b6489c70c6509d103215b7b46b448fe718e9627d13d7005d1db72047bb4de8cb01fef36d8d72a3a45101ea2bdec37a357a63ca7e3764ab6a211e9ae8504011b66f7d4cd22531767b2e6b61f685f3073a6c725f1a08c6bc92b866d0013180a9f25b0af5883773b12771ba615d30130b42e296956af4a2eda5d171aec1846fd881d38aa77cd9716e208202dd69bb10596f432c21a09204ae9692b0b22903f654869ba0f050a67da92998dd21d8d45ee5b36c2a6637b271510290a1954986082fd10e15835ad3cae8e9d0b89245684f38bb6d55cebae2042a624c7b9c45aec5dcfd7ca8f1f20345e1bdfd74a7e48707c11bc9d63eaaab22b3b4ea3c547d6863b8aa1ed0dea2bc9d9a54409b94df3294a762e730fe91b8bf58c8a6309d84b8547679fdb15e10ca01913282b77c78305afe987828ff3e4e13ead8019b9d90311334917a4ce830834168df2617c62abd2a1a101712beca400532861940461f2f20c6157d31a715df06454e1eaa9422149173100c42f8fdf5cba7420194ff25cf8e07ba5856915bcf7c5bdd2d2b130ded7170ce5a3c9d03dd0f29c6c81d3e31100c83cfd4069212a6a011c706b5ef584bf0f99ccf982e3d46470daf0942d34600fc79e79ac1883fa9d5346fe3b196a4193be05ea3eb51153207e0bba8b5b30674e10765f1dc9cd1f2a73a9b1a6fa291370a9674655fe5b12d426c3a91b58954a64db028ba012471a0f605bc8bc417344443e027add97b0b22723e6885069f7927b82d8870ab245b293c14d5257dd0cdfd49bb1ec1b1722a71ac963ad58e6c0c795f41e50f39cbf637a9d9f43e3550baf6f3328446258fd97afbec0125fc78c8252cb25b9a060a041fbe10e816a14c3cbdb65642bc11685f941477213d3f216204dd3f7e8d29ef3d45caede559849f5c69e157dd52a8afa566ca263b1d375f38bc4ce16730c455379eac6dd3fb417a1330103f917df26fb0946de130013c007c7e4f5cbcb3f2618429bc29ac631e134a0602d773ca53a206907854e09c94c7d8a4a6faaf3fc7781d51730add81928398541f7b6053631df6d644bf791ae2e360f7aac11ecef405652ff5030a24a4fad4696eb32c8c6053f3e424596850f056cfbc2312290dd3f79b3368ab0980408140c11fe8535d61ba2a7734cc2fd73cd2eaea58c19427fb6a6ed365933ca58bc9adf2844dcde088122ce118bfedc3ca8770f8ed509f1bf7d0d740cfb13c96c43155f12029ca4efa3936ef06ad519822d9602dce2fe3ec62342c7a0f1180dbffca7b2e165dc6177f6e8c71110af37b196fdab4f75f56359f54a9b66702127e25ea9c8330265cca0412fe705aa16144d77a29e3ee47da59eb331c6a44eac2f69518e151fd1758f75e9e0266f7a2a56f6b3e294813f7ee4cb45cf694aeb364d96eba67606aaba0fcaeacc8f41bad8f5f4f0692ec417f4a1f729ff506fdd5229a2de73455ae055fc635dfacfcefaeb866841286798bcd10fb6aa4e33ed3612764efcacb1809dbf1ec68117af61c21d5aa7534bf9e82ac6033e818c651f213ddc161cd4c7e5f018a0c3ff121c06df69c194f8f2192479d4a9b9f953352831df0e0ceabb613a25763ab9a01aa0fdc0c7d52509f9450f26e37144eb690b98f12f6e04eb10e7918c6e9b6316398194f32b6b577c0328a4ea01fe4210a526c7a2b012f62135a037325c22e9b58405e58588efa5ba24d5d3a5d428f073db2b3b976524099f6f16bbc571f7d79856c8977570481dd9b5481b8ccfc7cdb3c0f899b88ee1616fa9067a5ec4eb6220c85d1450e4104e48fe547e9b8ce6921a47093bca013cd09dd51c7d3339e06b5b6a4c9b2fafac66670711c1d93be60922ada0162d8e4962bf59fca5d72671f6b29b55616ad5b5513d44783993ebdabc8a9709e8a467aaa054ab613e87d0c2905b88a81dfbf52c5cb0e8d079cecd4414abf472512b2e600b848e94f253231b945884a86cebf9a3bfc43ef7dec78abe7d3b0afdf5ed1b59cab976a082bec306a0e2ee64b7bbd9da248ae1eaad4d37c46e2c882f941bb2849840a87027bfd583e98fd2a5fc323e88202383e4cbbf438f0320d156edec1f4189e964f3787d9b329ba0f72a26fe56ff1d92f4a57b5a7d87a2c18300c5c69dd3e0867210c43e9ab2e26821a2fb5d4cb6a955b15b3af00f8a8948b8ea151e57eeec34665a71565ce015374e671890feded990215bde0688bc30aa5246ed8fd74404ecfd04f4d6a1dc262ee3fb92433e4678c000e9e58a355724a3a84e95c5d906828d323d529f0b5100b96fbc78703ee63a9ed59d780ff6cda65eb4f22e0b1681d90b5210c291f792340ae1767ba347e133c0c2122c7ecb28905868001a9e003ac9283251eef1de81ee85d25b3dadc111604ac63508f7bb2465d12d9410a319fc701f07449808634a04c59f8b7ca53d8a42b2afa696544ba2baef5b8624d7d7ab4a27e1ed76a31ba7175b3c4554d9438f697821ad4199a9073d44da9a12130be8c40fc95e1662ed18ddf7c4dfc3a94817f44f7c338aa497d1bd303994c48cee30e7a0759d4a0af1bc30061b7e75e80dcda31ddfd3bee1f57d5ed8b640695e0f9ede90d1ddbc5bb3ed5aec300ceb70f3869c122d1c1c7d2471398322eeef248fc678f973c6f518ff92cc95ad5b3d7094b7ebc1a8379cb4624752a09e32f9bb65202ca45df1ae16e062c4b7fae4c3becad21eb7f19091db1497102d08538edac09d05d25a6f2704b532ee46c290d2f71b61bd952d5c4cb23463c604174893eba4d167b7026052890ff0ed5adeebce69bd2d4a461133d09bdfa964efbe47e30c2efc193ce9a2ff212980c954840beefefd05f8b0784dec6861097c0a517a8fc9a8aed5aafee5dd20d0c7af70eed1e848856ff5fd389169dcaf904e213f270c44bae2d9b33fab7c6ceb28621a575172de3733d69bc22c422af814fb1f89b196392de804d6f313bc63874a9f5e1b4af8fc5fc5df12802ef6b4b6ecc6b1bb9b60114b961dfae70fd5a50aa3b56cc10c743d2e4b8dd8ea5dca9828949404e1c384c77d9ff34a3f08669bdab41882fa13ab216764667d47ad60f966f3444f222bfcf2559d1f1eef8108f92db6f3bbb9f5ab83b1d8b205e3dff36e39596603105ea9d768c9bc66f3fb1e623c48c0b41780564d79022ca25be69c825399844e4d27928b715aa3645e506591ce66b28bc6e3b5f2587a326261c058e008b8dc73512171be049ed4c5edd2384870dbec48865cff125715a7b1c74f136d059b0ac03aa6a2aa36e7dc391f7695c3a6b3dc0cdeef9c1edd721cac2bd532ffd401846dea6baae65db45016148b090454ac82f9b60c40f3c77881bd1023596595b3641aa55de676bb4998ca3064f06c041190b4f81307450490eda25fc63b3ac7c1af71468b7123149083a2ce5dc5123fe22253e3a4fad10e9b3af2f38275efabff5686cdcfd54e344c64a6a6d90be7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
