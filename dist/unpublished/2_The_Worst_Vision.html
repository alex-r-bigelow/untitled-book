<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bdab7fcc6c20ba2fcc66a8b04b0089931e02ec30bbdce8e77972202c95faee12953b7086a8a056e976fb2770691dde742c0bd6e2d97895045af0548a890368275806ac21350ddfa171ff9c1775e299367604f2ac02cc65d49a2a2cc82ec4450665535e281e2621b35fa73c2dad6937e0cde32836ba2d695f797b8af83f66a6c7c89bd760ab56cc766d5add5b72cdd603112e73fa72df51a2e349f9f1cf1e7803563b47cc6dbc61ce8c2d40a96d1fdf9c97206a278c0685b22a636556fb60862f67ea6ef0316c27967779d69ae126f36f0199354667ba5b8fa33bfe9212135a687154630714e5653ea21be3eafc7fb0df5db3d4e400f78dc457a51ac060e809071b3db757558be9ace03f2789c2c7024b8e3ba5c4b05771715ea53e2773d7b993125d4cc09f572becb4379978efff3eb175b4e0b38e574975f1b2e4d8e603dca94069f11c3ce078545f6aac38095dba2d9587a566ff4daf522744f4dfa12c1df19504f02f8e2024496b4106f4eaf9095f8d952a1f84645455353764ee7a3e4d1a0ca8ef9096dfbc0067480b703243ba8f72f5e5edc018cd8d91c6e20d2c8d691cca1046f27afcfb3280be6c96e7a14302920d31a41a6e0caf40991bfb5bb2ea37b0b615aa6b70bd0389b80c6be0b531b0300b81bb914c21a9f84752153bf6309a1b6b1b71ad5ed3e19bbef4bea2f3d1bfea95a68a34ad19ab560a948d1f6404439252162d10da4ee98c09858360fc38b8a12144b9e1928527b83761bd015e129b45dd965f09eb3dbfa0cc8fc6b5bb438ac96c091fa764bb5ed6bda3eb64e0efb8a91b950a75c1cfe1b7e2ec50b5b9190f88ee7af03346bbca61776a6468c1d99a4156c32b02f8797fa071d88e59da9f38bbd08fba013819fc929da9aab1fa106a0d5987f291e6cf1695a91b85e0d52e3fa3ed37b6d18ffa05dd095af864ffbc4e9de2ea15b51aa9dc837ac2cc1825f53edb0e1c8587bf374e1f02a0030508152a5133f438481ed8b207bbee2c59a4ff01d1119a6070880d5e638312d86c1c492f8d8ac0b32340518c7bb5a8c20b98201babb5d6bb30b1db35586f4e4b38b37c5b63130b1e2bb8c06ff59aaf05750d55acbc790daf9b9f7589211b34eb4d29144d3348859a5a81e0aceaea9acbd0d0226c27601687662ca40ed3a364f3c43db52bddd8e51d8ad179327459ecab9a2549eba5dd11db5d5fd780f916ea25fb84c5f250bab5682224c8da33af2753c9ba9237cb039d3a7ad1aafeb0a3204ae7c88b43afd603b323eab2ff9e062789a519687bd9756b41eed3cf5575248b277553a077708e17a71820c684855cdf51cd47154ceae41844b38e137582bb03056919de435ccbce89e99dae1fcfe8561d92b512860e241f30289b87ee1668789554ebe8351f139815bb9090811ef13e6bb568252a66fe6c8259274d82e35abeb0bb10a42af0173483fedbbf150ff0e7ddb382ac142c95199bb7eb44fe46c6254bf6f6096b75d5b9d31adea252399e03137cb48d905d649a9559908fa66de3b2a185eef85ba9673ed5872ff5f4f3557c0d9aa1e8fab8b4a951056c802301197b3ec2ad1169bd6e45eacdbc4a94ade7395e8db8c91a5c45b13e3b0e19278ee65a4589aebe2ea9be35d404cb880423c37fdd6eaca2c54966225fd570cea164fdb6fbc17d9785a03091f3861588396ed578a54f48a3981706b69482399c3ed66d993d05d0673fa02aca8295715d920e2ceba9339a92014c10acdfbf7a79995cbc7311cdb9f6093f8975219bc2705dd7b9ecd37655a50dc90ef0c556dc06c98cffd0c79a7df5f57599a3951cf83032f242dd99191ea391f9afa787e37f313980f592fa5f5408a32964a55d2b395e9c07ea9d7842170d2458e0272bcc99f7542ba745a0a628c143e75c92302244c54e8fc09d5d802795cdc368073470449c15a9b3470390b50935a5dcd3496e69072e7e490efa62c563c885bf78fc5e9de7a16c20b702e39b22ba2a83292d3a93886de8bd2d5d553e51e08a4c3e749bdc6ade6087611a0da77a4ad90f02326cb2003dbad8e2d174c7fe014f6cab3df9e181cafb2817d940121e237765a18b02c43eb48f52e9fefea70c8b8cc59e07118306c3dc7e4ac9f341549bd48a21081f6f031b13466448d968e8320e0cdb98a3c4a9d78b149a9e1e616ae34625de4f24c46d9c365247e9ab49868f0363cbb904a4d3638fd997c851c3f318d204df8efc20134a8bfe0938d71e63085242abaa89ec7e196c6e696c2e8d75cfb84b83698fe70660bddbe77084aaee3f9617a0860abba76b114c4fce8392b559827dbf2100ca4abd22ac8720f588fb5b2e64f963fa50485cea26c8f461e1303f541b7064b3ce48351b8ca1f4981c7836e48e37686b5da71e25b74cde3905dad346efe18aae7ba8fe6c491fccaa81ddae296842c86d2cc460569cf443cfa1433420cd9c3ba07a388913c0bfea2dc2cb97aaf1d99219edd5e09ba7d0891ef93c1063cae414a5b573f7d0da3c33d449eed0677661af7c6104d046fe3d3b6fd20384bea9ebb04ccc5b4bb471ffe2914dfb8b394614ddf96daa3cad3e86d829ad66f39a631c1c660fbc853a562dac82d1c8f5111cca85e24a1691b038aee2e8d20d8a1f24481d0d2ddc7dc8e3dadc016d1ae7ec80037da82bc9d21d3960dcf70ab97d7f55a5ae2bdce1f7dbdc0e64f50680c614783d202d979b370c02065281b0e3c69566bb7505c8e8f86285b4787270aba7766d689ad833ff52108f478c7806baa43a02dfb60fec2f40ec9a45dc67564b5974e4a7f7e7803e23dab30aeb9df2dfb09b77d35e9337d268e8a916d7724045780553e1e7dd2a253a1a8a5de3eec1dbcf460a6477f475ac72ba01bff2382f81fab7f07cdf2ffd350f518cd4848541a4a16c6998802754ecada154376d0e09734a855b1ddced59931a23048d24b014048a9068368bdfa4765013445bed0d7fe306eb074ff8d00e926bf58f9728682f85e5c190c131824618c2d2851ece05284da82626c5e9d6f381df280a9625badd863972ed51a9d711aadb69ca811eb3f502482b0b4fe068ea007c38d70addc3b62f7bc6afe52249d9cf297e43d901800986307e9bfc5a8eec2273ae96593587271a9877e3a428dc5a569df109cf0ff7f767cada3b03fea3ce42e74cfa446c50571fee9b8a0003ae02cc38501cff15831a70964aec0f8c2e207b281cb8c9bf121913f944541434c5b3cd08f5be30805a14cc448be18938ec5ad1473ee2ae826f12da0fec32a42e7154d118f00746bfab0de2b037ee3c1ca214fdd7910372c450b0b17554ecabe439d3d4d7bfcb11174a9fd59bca79030acd4fd7c2f9b02740dd0263984bed2c1f90179362ca0fce6a25f7085e12c7f1e0545a3e9052cacf9db9cd4ac49e546a27b6ee6dfabba32a5a9027b9102b610049a832280f59fd61634eb9bd1e5d447d48309b1e68ed298c40bb48266b4b054aaa6b8f01c811a2d9b94b37f41ad6a104956eb2ccb2a9940beef70ef40cb010b2ce692360af9081b3aab244a7ef3fd5164e810d3adf84701797a38904ea59d557c7a7e4c88c5d0bf8512e989c6f524dde57b1524bf1c7b25e1ea98ccff6552531aed5253acf96e6e4ee65fd2757c56640ba9dce11512b0618cdc04d91029fad6d8bed1ddc2349a276eacfdb45248653f19f83660736a261aaadc8a7061cb7b976476e080dfcf2555ab608362ee3876015d840a9a8855612020b982eef4ae5d8416bd01261aeb1f009a4936c4132aca80ac14d2500bec03622c6702cb7e467998e0e3b28b1713c05202b2a0ce8a8e75f320c43dd7d4ec53bd31febc80f37d12812c3b042aeda3df61fd04bd5b48d77447f18ac3209ff7488c88f067e906217da75997452cfb3253583312bfc6e39b830e1cd1f720dc166297a33123dd6755d8e11d39276383ce57680daede01d649ace96c47b9c158d714ef48e60c91e7a40d961f0d7be55ac4581bb1b67003f99a1862a31327777de41f98c70fef200f3d4f6f54f3e18248f75959524d4eb399ac98ce0268f95800f5893ce7c129ae2ca0a7f7895cd857229634d28adf174cd773a3b413ece677262a140045b0f73e0be5f2dbd0c3f94f10b744d4f2797a7719eade9e46e84fe49fc093dfed1d2dfd2a77a38d0a6ec5a87da80871f7f9e2cbee557f479489954ba1047b52cdc8f8c5f2e53599286387094c327285852283927681f835c820bb1fe8e7fd6d3bad578ecbd2d1faef1df5c2fcd32e44bdb2a581fb2fee8cafc6bebb127a1ab2bf1bd11cd0bea5d53167bdaff67e324b23ace0bc9f0821e2d6829194a5b72bd6778992f6eaa8c36a7bf7f0ab715cf1f33746ef98d3e01edd5ed8adf6c1f4b7a23afd14ec12b468a4c855963e076c6dcee9f894cfac953fade4e2c6b691cc1fea44e2aec81875d14314009060b1cf70b941b3e254ce756f20a15fd3bac69fd4e1cb4119e49d4c6f64823219dd6c57c87328f3c640c8ce832708535908066ed339d5b60b884d140d09a95c09061f6cfeef479b4ffdeea43999d9eb456d000aa80a1ad57e0746e61cde997943709a948b5be5ea42a8722c622762255c5a10e646d27fc9d584c67051baddaf144623fc18ac6b21fa8bbc653f696201b2ff4d13b83bd3823ec9b5ba4c016a70b16e3002103b0d952997661e6786d98f478919d29ac1ef12e5af9ac2037d53d84d052e7bd8e4ec4c5f6d4223f7544f760eb8872453a3ab6d80e10eb23ed07521efc226d7b0f9663ce9c997187dfe823fd1632e5e5975dae60f8f35992a84120fd22da8e815383dd67e4d78bdf722ef22076fde2528238d967d7548d80088bb2867befe9267b6c1a18b066c50a518a4334b279276da4e24617f0036152892a451579f0a416160dda0a2d1bf5c0481801d27f2fe650a8fc02906700ec8c6e8a3eb1c811cfaef37df703a32287890a7f852d2f37ba432b74282f8831862509c3872cccde2f5b833059a6872e9f9603d7d0ec97f6d7e9c9ff8564ca3d8e7ccdbb4981f569d0449cd24819d0dcac870e2f4b72fe96b59ecbadc9b5e56f20cfa8fd4c62fac336668c4b008d0145e39b7f6e2a0deb47416d715935427aa82315f8af620220cde44908932e74213cdfaef2d04f014afe445f084924592f40b61c7957842c240be686140d79a7992da913fbfb698b3312940025b6de20477289e63ef5cc97a46b6f0ef939e4084b7878350885d76a79687982c5c166e32e28c6d4c02173a6d7a2f9a99ffc9f2cf887b3e6b6196a74fb4c77bc8903b83a6f6869c79b5f60c78e2c78020110985db1653c3820b94486dda22cbf5f37e3031e786f791a02445f6ee0f6611faa63e199489b59c43c504826038b4a69e0823984f38be3249af984716cf63b25deb29fce1f347febb55ea53a673930174e35acb7b80fb01b5662e1336ebe6790d1edf4f03ee5accfd5059ad06aef52557aac998bf4b0b10b13a7a9cdbd4fcb593eb33fc4a02bd6208cd9c06d264ef5043e34eb57a7efdf28c16b899083cc8516fe2dcc4f58ee8ae6489953630a785c0c496fbc73e2a2839d6880ebcfe7ca3176b5897c4c96eea964d425a3d7b0ab1e41692d7ad802381f3eb6ce056f367cda8603bb46fa69fb6e15274add67d3fdd00da9f73395c6b7ef5f40e550819ae6478f19976a26a24813971280993110c1b0991e740e736306115aa888a29ca3e59e45f3389517286d22fb90a8c4248ab952bb500537821e686288026af120b1f9d84db3c4d57eea0ad6c7a462b8c3596e8730b043b15906a7eec8dab409bf11d0b5040b2e421fd378aa3e70b6ace8d73a296e60281d679e811d0163b78ef7f4ff36383af4a902646e7c34e9de07af0f4c86d6a184a5c812b8f252eddd0a02c52b31b4e52dab9d4c24e54b6eeb54965bcd23df48d0595692cb54abcfa1a13e6105ca58d88acc5cba8cf6fb5fe3276facfecd6a743b0c6232afd2f19afe91b454266195bdb796522da7d8663629fb31dd20c80539502ba9154396350f48d34d0f266f0df0585cee4007440afbe7a5dec21187e47d8926accdbb7f2624d278b72f24210afebfcc9ad5051fa5bcf94c352c353cc65ed8f9300823ec2188f600da631a1a2449e6e22d3ab56019f958bed432218312aa2d28c72b00cf00e2796e3140f059df3b0058fa4267c684c4c17dea7f7d847bb14ecf9e9e45f5abb503622775bf62ded4533f9f8cf38d986ff3950f67e2677b2bcd6adc787acf8eb8f9b5703c62229c37c86c666ce35b9b7f8a4eed33109d4c5001f5d11094b1c523589436469f7a4f58bfa9e2a66d4994afff1a49025413b8d3ef67331d1c467a6b13eaa46c6e1a2b7739471ce4004122b8d3af790cfb1ff0efeb257cecd71f21df1db33c32037376de26115bb9ff490f71d37e93fe1388efd6b03e4c91ac2165bb70ba84c7f617f039edf00923cefc65b69216a187a487c586a765057ca3de4b76fff4ad2ce1469730d1cd7247fd6bf8008fe147986fa8c6400585b6f71f62514ca925d47718ad58cbd4390d95c5f959c1e860104fc7f092de3abea568dc2a131bef62603ecfdef4bdb17b1ab8f6541d49f3ca17bce4c07584871de21200a26ac677e9fd1e545c7a3ac14ca3afa2a5356c68233716033421d9a31ca7eae8759f04620377117a1bb8c6510624088deaaed6f27761fb4772d3b82506b5fe8d954a0f07aad760a291783ac7b3f33e438fbbcffece26ff6106838f33029308f0b6d5aa3391aeb1d4fde95b95ccf833f7ffab6eb1f799fbde2efea418950c444b096ddbe65f814d7068719274a8e415743247121930ac7294b686cc3a7bd6b873d2b418a85e4200c719f1f83c024656d7099ea59274ccd1372b84063ff94edccb525be940f075d90a09a3e6dd486228040e2e53c84a4be03ccba70c6bea07b84469b45f44d57040e5d7de674faea5b77e15779cdf5b4c8d7643eb1661d8a50fb812e1be169638c86c2ef8d92bbaa766261f73cb4df2a94d9b881bcdedef59482d8d2c369d4ca2264926c7742c8583c0ac9a6a507ce84f3597809f4bcd295c3312bfe22c8ddb37ff9a3c54221d22d467fd2fff7815a3088abfb8d4f9ae39e9cbb5f632cca1ce346fe2cb2856a503cb71fd01e97529c885dd87c98d502d60a4e18f405e5b6e9c5dd3691e29a8e9f31824b6e649d0973fde4a88d49284f129b9208e5db7e55c7da54a7111759b45c5125103ba93cebc5bcae667b2c7958de3d9bdd9485a541b061af9bc791cb35492af10ead1f4c0f5f2ed0cd1ad1f7cc9b4a3243194a743f919f021a64428eaae215a15ae5a6fa11c692fbee9afddcab0b7e907ce79f91810ce5210761634efb2317985d68218b504daee796a44a976e274fa968a53f6d940d6e1ed4c8483a1a91cadee60e0ab1c44a255681636209d63397807de53bf6ca48d76e3b9a4efb277b8df7df09e34b67ea30c4444a419dc06a61e0602a0cb19f3ef792af33ec3f007aaa03b0078970293dedcdc3699869d3baa39bb4bd829701359750fe1554c363282fade104ffdf49f0beb18f2c71efd584fdb430cb8c79472253dee77addf4f8e57a5eff4392974b31bc83450ce0898721d75eb8d24f4fa6f64c24ddb4b8c00e06d02823e7c61dffa4709e7365d1490a31fda460a78dca62278bed59523645b0700bff5ae145c12b23dd462a1786500f527c711b540ba0b7048670f3606a7352fafe1b8c2e914145e3f465fe6a39a90f1ba0a86b59a396d0ac572f16fbb206330b5b1d98b998316b344c5794b3ad9c3d34ee4eaa53310dc1ec9f74c7fe88e32b7efd0e3255a6297c8c41abc68cf69fe48ffcc19d77928a0f74c7a7701575480d3c04e8e971e32cd7e82d6335728498f21d854163201122b92ad3d3347fcb78a49b618482928c99870f04d869332c5ea99f689e65daf035dd29bec28b8a1fbedd950b33a3c7026ad553523a2748025407794d4f11173dc173c2545e41a1bb0d559ac5cf5934706a2a114808d8c77aff41003a75cd6b9ad78474a943450b613d487c213e0a24f7f219b121b07651edb45716c601c706d8ad0f4b97187264b33a92086372d8249b1409fff3704acc83aa54611b7c6f391fc79c4b2eeca98ea78325428a225d2db9143f63ed9a531657ad8672b3bf8a3300dcbce23e33d86bb367a92c119efb86bd71a763e503bb9770b61092fce9c3a320b85fb3e6553b7059b8e3903339ef45d832ac6058dd5d2ecb79242765aa1a75230f144b16b603e8b6339c7022c2e86b79d667eaf10740b3dd2c775d98d7d4f1a661194693c32788e31aada9c2bfb6edae119dedec9cd3b0bc9a33f9ffead8b07cdacdcb2de922579e3568a1d0335d8f20ba2e784236bf1eb932ae5785cadcfc18087a6644389674fc6865e7c79481d99dbe977da597ae6451ba01080c74aa56556e8221b7205fa1741bcef45c7b24df61f661ed81274f0ce0772d4e1de14ca32c121bff8886b30eb3c00c8ee8216b9250ecbc4a1687c5db837cb5ea83a987881639c47d0c5605c0690e90e97b37d5a386889e02acb0c1ded4b4464c4673de35483844ecc66f42e7cd7bab991d244fdb234390506e627e7b2d9ccca52c3a1742ae3ad5b69d5f8fbfb2e65e3484b9488ecb10ab5bb4020bdb5b2ec301178f51017507010cc71d92556e9a843f9255ab3adf30ef85cd19cd60d8b770ff805a8b990458d0528f66334cfe6529ea6e4e5ef1c3ae087799e874babba94e168fb036ce1b7c6bb06f56fc3a61b344d613569080d78e9dc77578412426e9f0e3509da0795b668a8182e8f712d81cfb3d54bb2fa29c8a33d212c83fef1e148ec988d8c59a20081a2138c8b6006ffe91928cc6c0d42a03b5a1b03bb78945d1f9c694e0af225bab75b69e875effc52ec16f3614d7507864a6d9edac80fec9fbafd62621472eab69bec1e338c0a74b3ebae77d23ec75ac0b8077a9efeed893d3da9fa605c9d83b4f7bb42de1090a821ab09706b0d25aa83523154b1063dc2c26bfb6270918f70c7407d5be7e958213331d43cea783da892457b8cfe459a3f49f665de75fefc599945ee83d92b486e183d7efd3e76c0ef9ccd7badf889d845be7b1f80aaa571280e3b8ee5f11d1ed6ef3df325a4dfd8f075ce057ba02c9d0f5b2727993c5e0d8134f94c30927501b5329954ffffd21f392928ca6b5e625be3e75b14aa1f7c3dee9edb05a342bb81f61d87631732f80902dd6e22094a4e7209851a9bc82019483a371e3fddd3832e917b07ac38452c8759a5782a2ea1c433da1a0f19ea97e5c6a3538f8e50db95331be41b990075cefbeab0be0dc752a1cf2435cc156ed367a1184a3226c720784349d9ccde2c486a06c6f30dc418018e447ce2ef364a350450a673b31b2dbf31c5c94559c1e55d26f19d0249088cfb872fa85856fdbd307d3bb7da18cebeba6ecfc3172665e8daec68b337f2502bf499319b3d741dcf4726e871f1f5cadc64443039c1d61341a9e94f3d3282a29d2391d4bd9a5fa36432dc512ae881f16a6e94cec3100447216d3cf07097c10227281cc3197a8065445f220b03d50a5ba1ce1745ca6213111d9c03dd47e993d7cd0203b120dc78d70df0503eefba2d8e46526afe9b17e136f8e3f9c0e206206074e4ab6f81f6f5f470e67663276110391cf8a2675cdd116588f7166b3a200c9e65fdcac1aaf995540d4a60badcecd45487e94c45f5032a99c537838a18a075f74035a730dc341e81f0f71e2147da7ff6bca7fa40ff5ecd8967e6f3882597805f26764f7b9c8cbfb22c4c57fa74194e47814c20fbe71c4c52ed7f33eab1e7af1a6d8a74b34dcf106f0f8ff51206ea3eb34bbfc2a04a31a67d0074eb2aa3cd90bd948a0560328637dfa311a300e9a4cc64415b789959103ae9572c1e55f1bf157cb47817a62c7957a1c3536f3adea80f17818f7111d5cd7033c174f5aba163515badb0430fcd41158d7da8f076862df9d387816ec431fe665a44a919bb457e2c9c3a6c586cf72c218aad28b83e1f81e103571754b3f2e5f3589b336338349d78da604bf833c8537199ddb7fecdf1c68d6618d71755b99b6e6e1a05b918f3b69b97d8d0a7f39169c274906080b369f1fe6920485011b1ae8c3e34c84b7e3b872a83d31459d761277afd23ba3070124d93d05754f3ac91d1f8abd30a83b7206eb8128650c5bc4d0d04a63390f5c1fb5b619d70bd6a41265a893586f629bcd493d3eab5ddf40a2cbe42fa9a4e0bc01f17e91933f7da9b5bd84842870a9d7dacdda1392ea467a9b38b371a07b59f943332f55c2c06bfeee20c9100b6bc53e9e6e8d7405f8bb908953406530e4d487b07806a8b7f858c164f894a5641213a839751dc365501f0a76e99cea5d06a92eac3c2c8d904598910368c0f9f241ae4b60f89f3a0ef9a40f231e0c59a219d4c3269f3223efe4ec2eb8be4067f6c182f1e83792f82b01755ad49c81740873c1deb9899923092edba119486e53b6a60a55a7e4c040d8d50954cf921581d7256dfb709260e39c71c1568eb95b7c5e6b161a2c46e5ad6575572fa40b1bd009b310e130f40e812e38e9fed481c89088c95e6ccc7eb15945fa251964de4a53f6de957b5b7c85e402999f725ef3f1f1580553713dd542678356cc14e4e102759856d9306b290952f80176fb03d10ff27202305d4af99e9b2404c64352ff90c941b347f7d85e4827346c1117e48f29987a18b905f830a92502997a7242a1140ae28554e449ca74f4abed826db5227fbe0cfa19e1abeef67a225c8ce60e6f3f85d1b5a09f693a5419b2f4eda8c6792c6145cc95f52e762aeb40012af468280feaaa75f32822382238733c54f709547ab367fa94f1f1f2124d96b5437d6932b52ab31edfc93a35cabd3ef5db2fc0c0f26d958c02bb8a7be46c19561614717b95c763c33e30a305a96dc7e29bcf1d25ef630f9fd33cf78337aba0b920fc0931820fd2df69a0835ea592751a8a2b8b56ead578b1d68652542ee3ac970983bb882e3494ef45f58ece746ee7eac6e17c7744ddbaea7ea62f91f03233cb2aebc268e4826888528fc1b52c321324482c05e681afa3df0da1978310cb7193d57f6c62f7bb951f598f00d8ef86360f933cd515d4d3d665852ed599ba896d652d1fc59132a0cb6d3ee02fbcb448d8123e28afd86121a63a717d83672e96eb29d1c572272065f83c29f32579098ed6dca796d47e92bb5224090aaec16462f7753fe29e5b35d554e3724a86ac203c992fad2dca6a8726a77154c78719a55a09d125512cf4bdadb113692e474625f0f0fd8635d8ad8c7e3e5652518da3588ea94637f7a048cbf6e5dc3e779c30cb6bcbce4a3ad59f4c4ec4fd0f1adaec43bafa52cb9dd2233342661010a8220851b781cb463dd571c4fd961b17db10cf6c835736664ab3f206f540fa5cb42c05cccf7045d9c2ef47413b42c04172cd5cb30b8d8faf0cefef7e890a6503c92afbc77e07ec129658cf8f0d025d3d923d1ba0d59d052a1d1dbde84aba160ec466340f30797c0ddfb8c0857967d39a9262c720982b4369532727f0dcc8438eea6ae98f157bf9c6279056eb9aca99f7bfb5efc8eb7f0b576bfc95f27bcf1294040df74ebec2ed738c054baab29ef9e474537f6752584c92be79e0bd1759441f52265bcf52f248af125db244d6479943e098b81040c937161bea9f211967414f1865864a01a2a0edd6ed60e19b8d30f23f270945323af3b6fd379edeb443cc17b8a2bfe3baf6a77fd2f216f375fa023aac98294d5909de03763fee737bb4d02073b1d2fb4482aab887041cc7723b2a9d8a7e3ae0bd1a5c54f023a323c10aa64594ffcc3beb20a59b4437413d0f7ca4b758f5f7b88c25dc6c6cd13ad4bcfeaab35482cb3098d3e6647b5b0ad94fd4189540479d0953ced2b3cba99bfcce543d93e8bf27363191f12ed319c911d8caf9b287a0e061f016dc8c88aee95e8f674d49a5f91cd298190b7ce94cbc1c86b11af65770c301ab948444461cb47d876d468a03a7bee6df72e1a6643f98d4c902c8fb6e4ec06ff38a64a1aa9b2f0bdcdc3f25e00d6609165faecf8419174d302012cd435cd903633e2aa62f5fbbdf4131e9b9117ad204ea90bc890759140b63952213330c9d4904dc61130be50a63622f5d7f984d8597341735af4f2ca0bb3c7291e6cf60a77ab79b2f59de4ec22582e3d855464931f4149652ff892a3755ce4711bc2f9492ab4221ac9e32fe3c7975b43c37c5d5a125c4643c9f9c61f031bdbd2c26c91267abfb2ba5587256af280dc719bdad047cf2e1d0c148692d0fcface3ef70b091278ab21790329972425d91856fc1257df5832d08328c01f4b454886a0edfebd4fe328997951f763b862e0035512b78dffd417140cb0eb3617a44eb81e4887ca80964784d8b72306f156350dbc80aea1764d78ab29011d7a68937f69623a54a4a47fda660e2f6eca6fb5d46cb270efb8d8dca19c95c49dce6b4a13818990bb867bdbbeb7563b11c8d847a5d3d5da195c6ef1829ab428df2e4f72726d9a956e4a2fa85ac2f6dbe5451ff1e6de166daceb3d94312eb1a1d79d9c64444c3b00aff7968400ce6118fa8dc2e366a505aaadc12ab8223e8e7a0b34b76a1c35a6d412dfb0a58a89606d791ab194bd2c416e2287545b132003992777a8130fab31ce4f22f07c4355758ea256625b96244a8ed88602296f244b470033dcdafef41ba299c5d9f4fdafd96f5ca5b088be266f22c047df1c0d17f11adf1b48de5c98a57b106737a484811353e3895e2395b1b80e07cdf07ca405a8c174ea1af2c6ffea6418c1abba10e4039469d28d41f3f2cf922184082d0ca17430214e4bf4c5069d057c48cf986b08920f5730b098718d82b47408c70f601450f9305f46697ca8869787e9482c4f4de69b19c0acb30e6eaadf0f3ade7964dd636a3b80d3e90ab9a29e50ac0e160078435d82795eee2718ddd3daf40c02c5b11866c2b4d1b519bf979a9ba19744574c1a46a82b24e4c1d95f539d6f16c89a05520e5ee67ba0d6e71df1d441a5cd106764ba12fa87b20135f50c4d48e021f52192dd2cef97ba56adf8390155a6782efe60399d915adcef4ee9646cf280c8ae2f0b6959a19e020358614b66e3cd4f8bd6a3019bbed89377b2c86a2169b74a914656fe2109e749e169bc963eb65208e71dffa99ffa4751559471ca0699bf0fb0e573eb99c840b8e86ef6f7c587ebb6ecc5519074d6fccc9801d291c5e4fdcee105eadef5259f14347a4f2d6d43f52908e9da213a12a75f075b98560c1937b4db2ba887720d1b55b401d755cfd443cbaac43ca810af662fa57306912dc85c826ab5e100c7a94cdd672037dc5378b594975fe0fe2955c4aff57169166e1dfb59889156759f0851f2c2516b3e78e3141f4562d04112857c1f337abeabb0609c485cb784f4bd1e207f0bef39eb6a3ea00670d5e05130b3ccc05254d2220669cb6337f50378a7c8ab4aa533bfa99d461d5cc505d93e3242fe42078d597ac138321d81e6e0984bd7242df75d9ef4cf851c18d05201310b4909858cac6629699b0be80873e0627974fbd9f865ddec751cc5740aa68fee3b397db84df973d2868c61dcfdabaedcfc965d15f18ae2d41d2f940385f5152d52527f546ca49bcc7bbda2aa03fd19e986db3f0384e6e392dd6e16ab64c9afa8a3014879e7dbd5b253e90f5157de85b50f136d338827419f7ffa26f327fa4398cd0de0c50151d73d2100c9682e1147d66672d7181c89d6840bf6851cd8a3940c0120ae14165e5613765dd41fb723745fd90e403b9a9e175f1cb2bc2c89c66a1e64d08b60014bac1e545a8c867729abeb7252c2585e98fdd69e04cf845a7e91fb811a1e53606324a15b6deaf06dea8060fa4e95326b80c794f2d4254e4a88fcc9edba4b1e6168ca3ada1a87a007f798fa6501ebeb6fcaab5adeb03cc1e13308425cec90ddd3c3a5cac0a90e4d35edc65c3828af83c6886fbcf06d3896d3f90eb4e47701dd8c6aaf97c030a5d13b03e8ce9dd7848f4388b4c9f97865faa2ccf494b3c8cefb937f363e8f94513d4229777d8aa271a86ed409c9550ac1166f8abf38e5a4c96c7ce0d819a024f2515bcfe8304ff012a56f0701872ab2eca4de0a99c7e579042de671560ac2879da1e3146ffcdef6a857448429511b4b1cec247ba9513f46df7030e3412d498faa809f5094e56fcb4d1fab49ae4160df82e925fa7e1982c8d68d4b9827dbbb35e36770ddbeedd747daf45293c05147d3daf2900a3d6e0ca0316803973c0893b44609b0f38bf908cbd546f281f942e33159a56eee4759dab240577fe70e17ae1e65a1b1ffebce98efc5330c72c8294880de1abbe2c536546aabc3360d585fd80258680be7c9d2c764ce478bf14350a75d27dc9f5390b87388dc0752b694cfe753eb3eceab8c3a47bd6d9cf9c16c0dc235120cb9ee1a207b6b350347c27ad49d7ee1f5713ee4bae33e634575bd43d73090a2dc19296095d386807ba7fde76da115435a9c8ee1cbf3b02b7ffe55249d928dc5947e1ba131ac7272102477bf9ef93791e8757184bcfad5b57d87c5a97994784c4fbc7f8d4882eb887d84162ad37f2847680bffafd170516361b1086d5efc3cb603e814e9660215f46745b519cf5d7a8a20069dff70e9515c5ecdb31441b54040dba8f9f4a234fe2705015081ea2bb147b4554e034b8ba2f971df460ee56d6270f330a6ac5aea487f08be773c8433aaebd8b9acba46db49be04087c7e51c7e37ef2087a5c47965c5506679accdbc5e1e595c0aa4c8983b5f7b13b1235c02c219325098425291cbdfa8a6325f0fa0b84a5254d1d916ea1d8875504f40a6dd736bbc8c1b9c9907888c9fb5a0c48cfd00ec56ff7c1f58b67f46800a680c64ee3d4bb16dde7505175e0d995c67cb9a8b02618844df1769372c455bf2a7be688d5714d278ec5d9f1d7ee8265a922831444b54e69d602edf7691b9e840785ee042a830a22fae10c21e66e341a1da73bf1a4c80df342e7cb63fde3e35f36e9cde0d5cabd7a4140bc7c0d7707ec88b954127b0592940d365f04d623967251bd98e42c9d6470d0f025dc0cd08f4aee8c8133a30c061d59c83baa8fba23ce53e704861bb843e7acfa0475608e3992b3b6c185c08e311c85d4ec42191f4d0ee65fc579de4a9d07b2f9116d9c50d8528c7bcd052a58c5712819892d3428bd9eba7f9609236ee3a8ec89c81133f78dd23c334a01bebf91b6f2beb6f31e6929bd446f64a680289e127b6e04e7f3953a6906033ba61c8d2c1643a1f8d175c8399b1b996e8b6d129e76cd7f5a1b9804a4e19b439fecf06da02c32674fb61246fbe1e3a0e08ef5c2fc5fc0c4b8973c2b37ad956342cf198f4b3cdf1eb5825e8ab916dcc595c4b9e6901b44c214ee3bb500dba230c8966b2049bed23ee96e144eec9da27e013947780cb1352539cddd7f30f2fd1d28a0ff3dbf19af06b04fecb7d25c3766f70319a44ad3a8e75d20f1f825551255ca96cd342244df1833a76d422375881db43d58ccf4cf8917d23a60d2d5994352cfb2d8a7043202b4c9ee6982a258d12e8a6e5b62681846c16db1d84560b5d0cd55dd59b412b26826864437a4f76beeac2f222e5853ab8b07a2f23a3319277e2ccf99c4ec06038828f501eea1ceceb36dade9f2ec3c9293d6eb085ceb2a7ebf4ebd9f78e30c9f2fd69c916b48f4e9b744ec47215378b85b30cc10d5c2c653f35ac7588136bdbe1b373ffb437d3a84398e7158e3717dd7e3a93639f0101d24a35d97cfde78b8031017e61d18dc2be165c243b4ab596b45a641a526ab18fa7b9b850ba14cf6430f3d9ea5baf3af3294f8ad6b4a14b5f893cbfe4103bcb7fd8a310acbc12d862e780986196cccc9d76ef473e6a1b2a6609c64e86182f03032c798071936b8ca02a31c926276f67bd628f6fd9b93c6affbbcd75cb3ae6f0f456156de493c5632128f67cb7093402e4b2bb16af04cc01dd56fbdd7f4e6592c3d5e4fa90d41875f178e644c8d9eb0d6089cc5d3a67fc5383fdc708068d1ebc3ac5c9b0ea050dde43bf3cec6684b4ba915216c9631bb474bfe0564a4381530bf41c9bcfb2d037df5fa640c285ee0a000b94e831f6d19fbd5467f423c515f8a1501be661e1707510","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
