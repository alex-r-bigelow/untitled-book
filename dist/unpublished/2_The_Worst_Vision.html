<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a69f9ac62090f9622ff8ddd92c27ddf6c65b3f70f1c28eebcf630d337a6f0a8ac319b8e68e1bce81ff2f0b182ad0752da9656af6aeb33e0ece8e1e3af9c2830e76660d5875af1b4898559ebb6147e5ab096467d75d2dc212f47f00a04bc2e5b3b345706f1219d4c1d984f8ed2ea7321077cf22d95599fa5cdf933f2456cd66abe4ae8f86721b2faaf3d9645e5974b6a6adb61ca31966ce2b600fb4a8ab22253b760bac341f61e6cfa2ce672dd67dde2f942131f77fcc94987583cb0d2c3b05bb36894db300891aad72ee7a5f38abd3fd58a10a4d1d8b01c00faa5dcf6020067b8d7b889dafa3c4ac24894951194c6fbcb24a026e66405f4fc8a9b92e4a4f35dd5a9cc615906284411fd97c61e4333b2142f59b943d5ad605da017cdaf9ec42585b07154d7a5eac52da903593bff885ad6775eba0d153e54c927c93bd0bc7432b0624bccc7da1f1390d2072691b17a4101414e4080891cbc382155907e522443b90c25e9fdd523f72d13041a70b7c83d36c1f51d2981bd6857a89c2a32029332f581390d7cd4da9c76323d820013be5d9fb95deb39c7c6934d05eca6679537a4daa97da0c90d0ecba85da4d9ea033b17e2eb04bc4d0d6d9ea15d7bb3bc62bdad746c76253bf7c4ab3b484850d10af11ee43a82bb933fd7d8990fffd29e23874a4b48a5e5cd0e095c5adcd18fd7156db6b2cdacdf5fdd217b9fbc0434f88f9a107f50e25be229d17465eab0f4233fdaa6fa8f5618d3ad59055e970f062175c57877fe3a3e2f9073776c78118773526eb01b346a3107d2b6ca93f7f10b11c12ca00e0d1c2930d6ae2edd60a436ff05c7f52a151f8c509ce62d6b626ec68c6f848da69c9475c13e2acc1d43909c260ad042981269253b8f619fe0b0c3b3e66fa9146136934a3fab0a2d227717f8772990617ad298170664f48b677d1e11c818cdae0cc71fd32702a9890c8a9792c9a962b8f603a18355f01801e63c86897d88889762c6f253ee0f54688d64bae9a9b1223d1c3208121a840c0b34e9e93d6b29c1cbd3262f0005f43a7a09b093d5dff05341e716da06e7b7b9b33e64f23b74aae1ec48b6441b61c8397d4465dc699fa37a14f56b95659638d4131375b54d28157fd6baaebfe5378a3a31f15a2f5b9d29862bdc3b1641bf7032bb99d23020fa333bde9ba493167f28aff3ca537cdd5274be38a5b5c42b7838d0a2e6576612fd638ccab26fefbadf30d67ae58841f60f05c930ff94c19ac1f9107409ddc2642dcd3cf6fa6914d55944b2ba85597503b561ca996e7bb91c2825ddc83bf8ea56b4954badc4bc3f6356032aa7efa9ddb4e66ba6b379b836579bbc1b79bd98678e3a5b35717d059e0625a1bb17cf9a24fb9e2803de40fc074a88330f32ba47c1ce8308fe1162fb9bf8f2e431d5ae8a1446aa2d850e42090aeaa105c4b15894d147ce0132d04ff15d4cd9f8c57376d99b7dbec6f7ff79a6d3f08048d10247fb4939c4e19ba2eb1da87915521e9acfd88a213c99cdbd905882a71d064ed30dd25f8f8c9deff17ec2f4eb707826153470e174fa29a50fcafb0b9b108bf8324c52c37db20549bf2fef2ca2c6b267f613273ab9de6d083a5534fa9926a81cdcd88f13279de2bb44d9eec68eff172b2853833e3e3505b32b2760be4b86d21dc3449b66454f55fd0871daedb08d965061a3bab46b4202221769e080f385c9a1c365cee9c02ab2b1fd1eafa8682e9b38ff8b41e21551b972978d4ad1b2e642aabfc97adc2394724648ca8cca67078a6f54da4b75beff86bc48154c0e0a51b83b1a77a5a8d67150be66a1d7cba93e3575698a919cda4ce53a48071991153b047643f1119bf828d7ef58c859824e31f8d97c411433b96e0bb12636e94f6a1de24a2625a497fd40a31a27c2e7ffe1ea5b94281766db1979109314a0a98dba7f633550275e3c6658e50cde9b5192bee211ef2105d5eeac6704121b041a076becdd761f2337cb1e9afd46af9711d5eacdd6bce321032c71fe92a9c46ba70e1b176aebd8eec3c8e00bad3d1e2a2665e96a3e8145eb8b50dbca0cf87e90da033b27dc6d10d98d8c596b6a5850068753e2a75a1b35e7b450d614c2938819170f58eda01af8fc6ea2e76a114b0d4fea08f1ebe92475c2b948f88b40287015b31d42df810b87dfd3da5fe966afa430026a204bc0616ba8355aba6c7ce1a58dbc04fade8a32ece52ecd2eaf93b65224934952c38ea9dd13fbefd2d58029deadbfdc99413bd8edda2cdf0d9b4d6cdf71f48c9cc9e4a7267651906cf0dc962e90a0be6070e8cbfd5eb806dfc24ad1815d7d7e99657b702e5fc1edce7d9a2eed9057c49b05599df623098c86832ba7cae38277ada62612689d5f6897d5728a2c623d16e4272b70016d4068c24bf35bdd0a0a60cbfeb2ccbfba1ac302f6919c2c70cc07342fd0df65082cc2fe28424bfdfdebd538a3c46b2387dd26fe593e3e34c952057db09f457d6a0c0b0f084241d8e4c39eb6ca644dd576e4883d67bbea4dd32efea9709d8c217f7f9e444f8f401b1ad1fb83b194ff11e5890c5f6553dc5994b4ae7d8b3d9c0bdaecd655443e555d9c420f6eb4c11c7229e57d8b82e0247c495207616be2cbaadd7144d431421a0320998812e8bd4ad1f20e27dd5dfc63c1cd203c72a309cf440d3dd3be219e6327991846a046619e15436ef0062349b3e90a7bad72ffb8ed67f28fe29219cfc593355b72f43177ede0037faf73bf934bedfd97089b496e83d5f4309aff3de66d3a95837fdc1c5d367f5e7deb3574aab9fde9151a3e41cc037495e3b56213e3736d8003ed4bb1711c5f9acb98fcfe6acb9faf6183ee23673f2a826001fe3c1790b2b58dd412a771531cd643db7e9df0f15150c56cbbeb3f01f7ab1aa66d0ef0cbcf44d101ca672b79a5a02ca5d6ff7ef21338ff0c3d7fadb4428e2dc337d73828829870a33fcf3cc8df00fe9a94bb2b6e41a95a6342f5ad6f517f217a46b9c1b238067d5a5afa294685005ebadce0caf38ef454dc61855d18a1422761c4ea1cb01b47eac61f80f25bca4b415f6cdba397645ae749cab40e8029f04a73996757570e75f21c5d6d67fb62e0f96d3ea17bf1e1f5a6ac12563f729d5a5b44c847c6b856a2ab489181347c32ff0403e8465f7142a157003ddb90b6a0b227360dab569752fb32a79bb1cf4167ded1553d553b411d7f582a61bd4cb3f8132d79fb266bf71d7e58a80f4dcf6fc2530b4a07cfe06aec3f69f45058e436cb79a18641f529c4e9c7414700f1cdff4760a198f0c20872fffa4e052ecae9cbe97898d754cc05f28ea67bffbe8f26771dff515be8dd469ac85e6921b19748e9ddf40f3d1f265c538d1691a5981e39bd4a1fb50d7fe1d33c910c8b382d46584a1523c425d8044ef5193ada9b09d8c09754260ddae2f35103e1d9994024651596c8e5d120d3af26141e1d9bac78fade9fe5a0e2847a4065dcfa2f87b66a4365d84baf94e71507a349f5adf8c1e178ec2b221b743047f24f43264ec9a3d5466ddab753ba323e0f8ec1ffd4a91dbe966224be090c0ea8adc549f4f68f83a7678c84340558d92e99152ba04ebbdbc7adcd0dd54be9aa8d6e7ae37638c25e4ec3cc37fe265a775430d7132fbde7e0b216a6872b208fe15df68f934256769c8cbd6c4580089c256f5d423844eeca4aaca8607541e0fa7610bee0a9613b1f86750fab0c1f56db73333557cfe0eed58cac3d269858d30b3f5c15ff9a4bc81de0dd01ed83482be40c5036c24596ce7963ecfd37a4e298159486a8c66b5f8d34e2dbf5df4983588354366e970e203c0da07408b59dda292a12f6c62d78bb9dc720d988ea1ee7ab8bec7870134f12a33e1ffab619ae47d8bdbc6a5ff5a11aa84df1e68d109ef202d9a830253fc5c657c35a189b54b6a40a634e2b276eb5dd794bc82c248ffd3294e02457a605669e0213c2284727db6f0d708b2e730a1c9bf32a9895ac9295c9644d5b02e35349145e9f1824a665c08f734151bb4e0d656c132de7f5edd918c00b9a08d7ed8cbd26f89c6c2d515b1e60a4893f6af77ba622cf2fc935562a3dedab3efbf05f08fd7779eddc7b1be9a8cf4f5368b02e784ab1f5b91775e9a37de5f6697abb005463940c3ae0cd0aced0204589a14c56827a7425a55b3665ef996432e8a8afacee5de5708508cffc1b386d5da067377fc2aeb151d6cb2282f2df04149a969ffdd61d781b8928d62b148c567e8722c41e84139929faaf83a16130d6d45cccd1bf2ab11f5bb0848a10a5064cb7ec39f84fb11edc64acebd31780c4d208ccbf3141ede1133e9a195e075db62992d6642f5558560ebe00b63713ec19492ac72f0ff753c0b698089f9169414faadede0489ef0b814faf9d482d7da252fc6d57ad6b5abf59d8d5eb5c70ea9b7f2e99abffae7c9c809fa932e5259273c24189cdb24c97b98aa377b752f1a1e91181ee7799de24ea194dd0c644741c324d8958cefedcc2b410319e2ae93e8b5999f49d33e5b3e0e09056b94b085d3a916b3cf11708a3417184958d151303257d75dabff7ed381ff9447676e8fb1e9644f790b872a549d2bd53e1fca6de9d79f2b8ec727216d82b79253374ec3d3c4203acf67797c76f50bcf2adad5e2122a800290833cbc685928eed2128181469788021141311f6640c7ad794e378d2c27cef8cd8433812e4967de679cd422337c6473ec9338fd8793c7b3469793c93f32ed9135192407caebdb0e5bb477932bbc6a9106edeec531ef044cbe816646b9f004b91b27cb5a10cfd6c25868e0a375cd800ae7273e50760f5c5e8e03a7754ece0f149da83d0e849306c62e8cc0a016f4da9823c880127fee395b2b176258d89b28b6e259ff0c247f1667b264d7854c372b7f89657677e65e6d7c58d526789496caea973f4fcfdcff31bf8d9d85cc82a65bf297e0b8fb5f5e1629c08e47d171653be9113b8539fef6c479e0c3ef2cfdad63df3bfe689d15ec46129d605ccd4cbace587f894ecc037c2a94935eec8b8673e75075dba07d0d4b7a0fc0220f4aeaa4ffd5c3f25f4e9ce9b72bce3279b8c03ceebd758be2b9f1c5700f7f59395b6e2ab27bdce6804c677c9885aebb9ef1120896c9c67a317309f1bd41b67500abc62ecf74681dfcd6808c7f1792d99be635a5af8c4e6c683116d35e0e42a4f07921c5e85f21474e8c1846f6fc2ea9bacd54fd7a889bf732b395f93fbcb67cf7dfd785ffb92d4168504ffdea67df0295ad1939a5d40fe0f435ce16b7072be12093dfa090f80a4c59fdfb335e0a86e0c323178d5e526f0fb5f2e34a6229f92b6f6ccaa29f458c570834de79536856db094b528734fca1c3ec4b0869e8b711eaf8451c672b34ccc53cf7b9e1a7ef58db320fd43f4f5dae78938d3f4ed9f0372f41e148c08adf33e80c00b972845c035722ea4959e0e39da88df9e8e93d8ff7eb0bcb12169896dcc0d981263f6074cff29a160e6943fcc83105a463887caa424b1b1ca9d0d86666e25b8aa92e773207e612194ec4765bf4e3a3bf21484a8bfb35fdb8de74ad753d01a4df9b85ab5705166fa7fe7ac3b0d0377650c791af9d752b3eacdbbfa3e026ff8af59590f09f3919ac32005b0a04747ecd81b2d9b96f86d3ac17b993cab2438022898cfc09b636061a9388b1dec6ce31eee6c1f5e89f73d008841e1bec23ca334c0cdae705345cb4f720fb55b4eb48bc1ad4eb15b5e45a1347f54b9ea781da6389339d36ec5eeff30ef6b7e800d9979e7cce66889f0b15e973b74be78b18e5f660daa2fd9bc0a7e70a719ea670b7f543430671eaf442bea564635a9c4f23ef2e648e49e7f8cc1310fe0984ca3be768bf8268d7aff2429a121b90fe376056b8561bfa807db6ed7a39c92ff3073c94eae7c9fb9dddd6299ae878c9d83d96633fa0ce77e6b8702f34fea4ac772c6fc8b526c4e3725aa65d4574f10f32fa76a86d0ee2db09264a312de546eb306b5828b8075be13752a7667b36debd014d81798b9e7bdf5c6fd48bcd66489216e2d4ccb918814e7ce6e0eeda477770374df10d3f42bbe6790b5c9879d70f23424fac59ae9d2c0044e57dd0e7f5f5fcc389afd20261181506676bc846991f969d9dd9ce14992dea03a77209f4b6f95ed13ca09b41d2007cf3f9941ff7489ddd9358c372ffb289335c076620cb3625c1d1d82875f97606b43179920b23b6f84867f54c7ad3e8124bcdbb75f448e309431848ecf2c2a7afb7b9adc63c6b3d95df04e2f96e070f459d8d1ff74191055de900196dc1bd3d0847cdf1a153bf9051cc3012f4491cacce09a993912631f54d94af82f5cd0c1682f01ae74822e09e5657bdceab4b91db55b51aa4885c4f5cc9598587296d8622efb6c7e53303ee2c8971152ce31ea7da62b5bc93b7c1545310668dd5fe4e974d9fb70c8771bf12fab304dca502429c9bf263bda31d1012ff0996dbf95e76ddbfc8661a6bf2ae9181bb601b5ad565be726b1bf7d4f834bb2e78af1727c5327d4aa721740d59883c569f3c45284dac43e9907fc72b78004c4d8108cd857635ad1dac350c02082b1245363f032c6181c7688ca870db6d13a3ab895bd112c3df7a04da51d7e99b7b795b4d02cc364875a8cb3a8a129170c77a00798f3f66a9858448faabb634b4fdb2657a03e5b29da2c4c6e92a115f68748a7f53d5486fc6240985bc93d63abb548085d8b54bb4d382dff9068cd2eb2a085f50b38314e5a7f5d627efe69391d687c731a50de9a2217a9a5cec869034f1aad0f4145eb34cc2444ab9b0ff09558b0ad3ffd43f41a8fa21253cb9bbe9cb5f11d8324dc67600555576c8c22fece54d9e19d170a04d58d9ac54ae064eecf287d8c3dab93281644b796ae1d48ad6527cbf7c3d771fc0e13736bb848497f6d95dce4e2c19530660a2a831431bcf6578c7caa89e6921bae7cb589a76d24a860857923c62bc3af6c36a4faaef81b15e4717e3d30b695ae6375bc91306f709eff568612e9e971698d7c135167ff756efe8112ececf2ed51e53d89fb1babf61d153bf46ea15f0c7bb9ca79f9ad10a0fd8a4e2fe0c1da3e2073b408fd78390890462dc55c5ffccac39860f1038dfc702dcf3d3d6d10284f9ac501d3a6c0895bf89abd93017f241c5006793865b7347422b011ab249cd0108426109e121af4c162283d0ca5599b78c6e15dea265f9f35c5c49b1ff7af2f75f6f987674c797512744eb9c5f912c2ae0fb550b5d0d1fad9a441fc2a986076f7b83e79f7659eaa27b3786a191ea7ed73e6200812693b4f99fc1a4214b5ef7aa9dc76bea126ce3551650186f9f83e619974d7164e4f257751175dec5d3fb4c8db984d191532c500d16d3c61fbeb8039ca6bfb00b37954d5e9ae88aa99fd772b01b06f395ed943abf0175b0342eff5486891e7129918b3d4a74023784b83d6d300a5aabd78d421a44b5ac3a68a5f84a1ffa8d59588804bbfb16bc6f58a092efea44b417f18097dd309f92b2d5bca7ddc0359b8897c3afb2da891ade7fe778415d271983d8a46dcd803adea1ea40a994c069ad3000fc720b5fc666baeb64f0c58fd669b7d314f0e9471351ee11a942392db9f4fd0e1c85268af34534159b8afecf8488afeefc3255bbced98d076ddc82bc43cf38078bd39a8b828c4074d701fc9301b76aafa2c748793d27249449869d8a838490fa70de734c47823e02177b012360d5edde096fdcbe4320f393b6b0e83139d56767436900edb19479c5207e40847a4ad9258c6f7af20b10581b78ef781925cfb4eb0f84f35b2a1bb51a183ee28485a6c90702acdd69afc9cddbfbeae9924430ef931b95ad16299295c1b479e2f0207372ca6c70eae6091f91ec78e4699fbc118dc3e8bd9aa16b6769e615bee61d177683b615bba8792c821b70811e1de39c8b1c787677dd932b1fbd0661acd37f20a0f39d906987bdf5630f8103cac8b519a8dee2d4469b0b4fbcba62fc5f0c484962f19ec0e7d57f92b4091386dc5e5f5d849771e12826b78955960bb044f6748e0824e3bec60cd449ccaf19a0e38e6a7b56dc2c63a39c82da3d931e84550b5701ac685696a5b0e067eddab8ae9366b4c51eba2c751ac263f849a99edbc41878e42526e0722f70b62f4bee53765be26c9909c37b7e72171037d18e77b3c5ba438a34f993058758725492657569ffc7a06f11612e1a9d8f922e53f6b02d8f5e43d6d9657f07b2dfac7700a5d5abd91dbf95097b48b3dc7a463a96a58df0fb8ff700b94f6356104fe041b438e0645056e48766f80c227ab0f32dab2b66a31862143022ba249cb5fd6edbf17af7920c5eea89f3baea2cfa14554c5766091333c7da6d5b7509111560134486575192c4d5bc658393f4c31cb474aaa5f69167ee89b3ba94ba7533bb934be5de3c58cad0b9fbc6fcac307b8bc016800dee95ed56934b9e4458f9df050cbfa4dcaad91dad9b3ecb28a86de3b377efaf0da46017299dd5519dce839f333c4c6691b5239426e4049b05b66d8b7e07f3336ce479f1bd63ddd484941b6ff0ad4a8e174f38ebe19845dbbe019f6af714074abf423a297be652b7299756c6e551e94beab6fb11d55ee519672f93dc94d54670dc3c7d8909753edcbac2c333f0dd20ff3e8d04c0b8150cb98842c5845b0b1d528b6b54eaed2010008c992e10c9eb71dd8d7c169ef84758dafa2f2bb3464cd3659441814a437f2aeaba1af7f6ae7023687bff5de3bd7d351daba9914e7b52021f132f87610ed6ba98c3db8e8d588332232f70d6b87aef15629c157e25ccb86c8dae13b593023bc43618c9b64aed4df68f374f577a2f3a9e2ede6240fcb971e53c1baa74fd588bed075b518879f592626156478a6dceb77b7c3961624165a9f67f8308c7da92ebb1bbdce4758a17f39d0aaf40d46949ae2d10e61675838ce1b63ed03892f7c212f854dd4a333c229a0052fb440c4beca19c8e8739c8e04039d94cac74f9ec495ad7fa16b3740433edcded47f266f5b7cef4030467ee5ab639339b73bf38db68996d80fd47037ae74a0224618ba9361b07e4070e16b233052c484f20f84cf34fd752b9bae5e3f212edc1693ad127a6538c82141e02b445514e7e805f841349d98856ed35fff21403358a2f9d279bd509b93dbf07ec1fc4eded818b3b60b8353750237da82bde506210e0ab2def3a351e8bf8e6e0ce10fe88254c53c45313eae7fd27a699d0916e8ff9b23d8402215ef4f3eab72eac0ee578a75e38c5f9dfb1e2d97a94811801e9b1a69ae8732590760036a882f4ee45cb0e02c9a6652ff5cb50813be01a03cbf0dd931a919aa1e8cda0b717f0590e6c2409e82b44774b31394fe9874f26c47a0122216e84923678ab8c0e398817bad5da1c0722f9fa37d7b8178e0c41c1e56ee93a22e60f096dd79445fbd18a4e1b463fdc7233e0449c0622645ede3832bb0c37511abcb48faffc74e6660db09b1c815bb0a94f39e5798c49b2b76d7f58a243c4102d6afb5c0b6879794fbf8e315f585603e58e682c5852db719eefbec6c8a41723d671e6500a2903a7c3586dc92144655e0830a7cd0cfefe7f7b3e0f26c1fa9b0eb1718e11f89bc80be0a7524b2e3300b287c9f993f16f1f262020ffe1973d7c04a49d6206d0c2c8f6c40c1ac23285a150879b45cbab1e6059e1161a79df1ebe14c883ee0f93fb794e5ce2ad44b1db8d228f4f577424273193eab6db56e6a5bc12688a5ccfbb61cd9204c8cfdea70f07a70e12dc3dfd40fb5c84035320c5d06392769e224154becf7edc6cbf3b1c5f0b35893076d540e08dc6d1630deda257de366e0d1e53373ad46694e66c3c9e745fc3bc57ce734dd39cce053a22d6b0719b596e870ab96b77d6c263ccefaf03f1d35128f64bfad8d384acc1902a9f55fbb71a1ea89c61d328efe9935bfafce4bfb3ccef8822c02bd216271bdde034c18cd67f162b240da18ccba61aa0255dc27ae15843ca5c7e109fcbf4438fe76a494dff1ec3ad862988a112a75cd284f43eaa7b5d03a3945813ce30192a22a143326454dfd46ca50f00fb64b79adc1da1873ec144b211c2873d787825d5af462f39a95a9188eac552494efb7c7d6683bdfff4cbd4b1c7cdb1a60842c296af047eb6d6f09b1e02162e4b43f41b1a62023f4a72b6ebb8f778e63eb599a2934785a7bcbb12ee97548ead8b5cf477cfe284dd43aa0cda63c2e66a1c50fbf98229a00f500e2b8b6f5bb9cab867f84269ea244364d98c25d9bd4f001b398f02e2d0164817d5ded9ea7f20e65ac02d3f7989320db2497d4471dcbcf60b8956f8752b22f1ab93e5d44543a8b4f7a99cd48a5c6de65affe71b38c7cf3fff3bda2638a4483f4ba00777463d4bd4bf396c0bff94d43b1d9288468f6e1c46d87c3371a85402a55f5a0869bb98702c8bfe98cb5a7e0aab067d4c7248b229cd84f6c7c9d4585710a3e02ee58375711139dc06f3b3e728db1650aceb627ef3d5caf9c829ab2fd729d4ec21c04e2946be5c287ac64e45e3aadcc7b68419a813353a53d85573a64af0daee7e831c893f89ca7d2f0c3170035cac8e38b37a0465c3e113ade868f3f5475ba2bfa2a495e99894acd4e650b0ea067756a8e3523edfeb1de8ec31107ae1c46b2d8248fce33efcb41aab0f6b5908e75c938c20a9a2052da0cb9e2834fa61aa5a433688fe0f7ed7458496f007f3711050cbf13279e5e30d105dfed54bce081d348412b4f785d626db6067bf118681a56dbd1c206e7c83d95d6647b648343d6febc442f9af7eade265cd2ade6aa8a6aae6d768349befbcba31c6ba4ff74fe0cc7bd46cb646e8fa9570c02d7fb6c73d0e41c97d4cce4b10f069ea2c57f076074ac35e9a69e02124180c0cbcb59737eb3352729acb5ebe4b9c62c9641f47afe35fded36b7b27bd7599c12095f6002fefdc2ae812ceda72d2e78a8f9d155a211a1cbed796a340308724aa65893ff44fd283d3decd26fe1728a5525343532c0d68e9b3e6578b22a78e25882a767cbb3e75e8e934691338a55fd0efaaf9403f4d20dc3225af09c0276c073f75b6d7c225452d618331a8352d6cb59acb7a4322b20ce9ff3f255128881d8e0f86017333cc4103c1a54334078c87988ad57ab992d4c6cedf877f203704322da36218582770cb4ae963900869dbb842c3551b808aeb746b4e905c3eb7e6b15759f0227b37a7ee422adf28926e5d168df27da13b3710a442a3037e4bd5a85fa4ac1ec0ce7318bda3c83ee2633d783773030a098f49869777a99e2c95e76e761b18167c92296947a565e1d56a299f30c5f631497d8ecbff59a5a9a7e60e82c5ffa4d454ed73d4352291d76700b1c3b940a3b6fc67fa230c577d6a1227528760ce67dde7e4391954c8d455d81bcca32ba2555d0b33700e2aeab5ed01f3300d8ac23fe451a8173d7ae727eb1d093d7c0becf99362e2da8e33f65e62ad971c13a43937b696f6b3175d6c93a3f954bb0a258046c65a05ef3e3d9191fea11050c3dabad8857031bb989785d88488e850ea6ecab2fc0af1ee9772a482351a06a05dbe75adecfff0bea9881409e08cfa25bc3feefa5a48288aa155bcfc976819eee255570053a4948deea40d7de1df1cbfc93ada1834f8bc5753d0434656cbeb61eee7a8fca1fcaa487c8b12ccd3eafb91c79369d29b6c3f5990bf1af652df091cbf4e8b4f101aa01880067783d411cfe4f456a6615ef48b3447e58013ad9d1c276c6b81bd6eb1ca9c95daa5448ab3ab9735200b471cd794035eb57ebb4272510eab146f917c0b4aec909622a06910f0a6ecb5368be9480856209d3a23b8d1ec3812bdf1d8f18297c529ba42283962be029520c2082e80fda2505588646e5713900fa4826fd6d55fc097464f3c59096c969fec08c2291ced9f50e147ecd8c56d3d4c0171855d59a3ae657ca130a9f500781bf31dc3fbfaf461e0e2b4aa800275a4dbd582cbd9409d48a96aa3575b27062ca839baa5b927a50d2c35bcb322afdcfce2f777916462aaaf34ef79a5ef6c6f8d751fceafaec4406c0ecbc18a100f27fe558204af89d71737799f19ded53d432b5e84f6610b6f7ea912d877c1c2de06bfea8d8d57863ce0ed3ff679ee641455629c719b8bd00fdaded5e8e43e24dc60172c70f4a403b85cbe514bca8e5bf1af123164ffd664e5b0ab1a32be8906dd0d77275470df0fd402c5735f989deb5a29d03a9279f5ee8332b58ceedc3edc1c659d0aace8ec80439d9b8186ab58bb7eb123355c7b42ab1b225938a8c986397a0184153b6f3030bfb96e18668a9150f713283e1180352129f94e003ad05e6c35acd6aed944fa2c402b9f2161d6ba3db374949c048c5528e04d4a2f5695668009776014281d8fee7a1fc99a70e8bdd9628223c7afa5b8e225dec7691faa84661d831795b01521b4f390ce36223bcfd8f9a849017e70e7d92549127fbb9d5cb82e234b6be65b2d41176b15b8d024c658db92eed634d78c718e8c98c2e65a9f769c2fff6d358b0682064d70cecd504aebe729b350e6f5d93a227c1c0a14ee585ef44e507b8e95de47f8e097ce81fe65733b10906c1bf94857c3dd9a4130815ecc646aee6d654f5a25e4478b428bf69b44d5348dc201a87f27120dfbd4e8a362c76195d574f6b818db48c4e29169a532acd8fb7e3c78a0f3f03e312b53b99ae0cb00c48de6359f1b819db2c7eb4e984268ff678c01fac820ab6ccfc24404b9f4910c86e7a454cdbfcaee21131674b5c94b395b1e87026bd4599e459d7a44b20f59bba3ecd5ccfedee8685793778a2a657865d085837562e8707c2ed1bc308f7fbb242dcda610d6db05ec114a20379b3053fa6618b24c0b187f1ee56ef65a5c6cd3de70e17ce726bbf28bd81cb33cd6ea66808af9a5ebddda0ba7f3a475454881633a01684885e7b23fb71771b092f66f192a36e070f50ac933385fad79d0131685eb90c3d531389451950f5feaaf85dfb4d3ddfb289d8a72d002112265c662bcedd835b99342c91bd37ccc7d21b363faff55645958ff1793708adf5f5d78bebae0a858037fc1275400a23cff7cae42dade70049288061bc0d0c9a3d4035a7050c9d798f6bf62be4cfcef5d2ab4615c290abc4a2ecb39b8a1d42b085e3a68b40a5383e7eb028c9c73dc2328e7ee00568a6db4e643b2b776dafa7d082399a741e8e71d463a01bf049ad5a7945fbf8b0f7573c3e4bfc8ccc091a4249150405188b7ab9adb8406103010efa21e08d6ea9b7e5316ba7098b6460154f87cc845a3654c10059ccb696f0c07d48c29966c0b225a984a22c926b80936dd58c9baada4cd3912ad8d5be4b0ed80cc1b3b176c6e673acb219b0f84726feb6bcd277989c7005a834022b107c236e727055e4f372eac6fd0014a978abf39e755c8fc7fbced0cbd2b9320ad923b6917cf29024a9fd9e8f637e102ec1a67e82296cfe010b89c2c71e537803c403e07b8eee3511621b984c92fffc0cdab644d6a7d36f3ab3a168784e6ebee5f276eea85c1ba913643518cbc844fdb42de615a49431ed06dad1c5005d2b386795cbb0db73c738477319c01ee4b2651debde53ac0b5561fcae73b88a1929178634c7d7ae5026742502e6f67c7bd437748db54fbf91268fd795266e77841410a9d9b8aa3d5cdcab46b4947c50e2b18cd9a6d98be4db48a4035d7fbb5c5ca14f23d689b16f03d1428b0c07d074752e3814ef762dcb7fc3ce826ad9215a1ef3fb987c594c6b67fb6c09d7fab848ef21af939e25511a5a5783fe3a6281a281ab63ca71601f62f25beedbb1940e9883bcdc326786686721625fb3b88cc5a93094b0df1bad32e6bc0ebf36d5f729e1bfd2817af2fec23a8341bd659ff4c53d55d34e749f8354c6ca7d36b7c218b1e2b715835e162281d1127867a9056d7383c51dee0b2b0f69449976a6625fe59524eb25272de4a55691af32aec598e229d634cb63b717459f70ee0f924b937b0204bda62f43220f3c8d96251e2b3cbc0503ff069541e59944f7bbf7d8fffd58d0bc7bd85ff929dbbb6cedf4934f49f5531be343173b1e96732019cdf459329f10d85a5be550673471617ca3880734b2efdd933f1a763fae5564c09181b10ea40ce8cb0dd89d945aa9d0683df62cc0f60107966b948b30be96c922791f59d09604601b9e29358ea5ad60b2bf49dc6519e68a418ab79928a01332b657c26e7ab5447366eec836b700dadb6bd0b9b8734dec5cec913f46d05d294877584e8a5159dcc395dff73a6b5f7570c9ecf42a012f23e6e69167a5279128ba50a3ed9bf284ee9902b4cbd1373c967c7ca43e28b81bd26811bdb1da22d719da9e55cb3081e15f6c052e4932a1f7e610f3ff4df2cae927c530cdc547fb2cf8350e0fffb029f8e9955482b547b5e2f124e34f0a86fd58adaf4c9a66221a1cf52aa8fe71f3f0320ff09375e3b351a56c8d12583f7af6000baed9320ebb357044d610c7047f1955be0482a741da679c469c33631a5883e91bc0e067cf9da10e03fcb89b2276d462864b3a37b3fa7092828b43e286da8ca810a361e6858eaebfb6c2f5fd2392","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
