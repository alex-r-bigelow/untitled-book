<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"60dfa848e80befadd18566301f738ea61fa6dc3a4823769ab2db43659c4c890ad3b16809888599d57e5d0bfb41b49d5c02b23d55d73431520e74a07a89fa3d9a2e8276779d540f0cf47bc09d53e5a715010efbeb773b7590b47d6b58db214f7807ccb7299669e75b50cf27e39726c4bdf927d07309f6a9fd183ada82106ce707f9eb2540b2418ad141214044cbc91069ec15e326e015c931507ce4aff5af93edb5fc9cf00fa3f8c463dd77cf6a54ef8dc1725e561d367cc350128ff33960489b7c495d83d739ea72c0dd8a446ea9c5f3c45ec81f3530a1330ce2609fe3f26e288978ec03ee6b6558e2a6265ef0e04af0ecaf02c19453ef16762e56a69b91d90c3dc59b7432a309d314bb0d00c669b601e408e575f128b0c98bd34898f104d4142cca685bbcec78351e07abfb0b3657a450f9d3b8d91e24b14ea6ebfe21a05668bec2959be4ace7ae984284d80768d5c900b2e0ee372d4941dc957ff63a3c67c6cae1456565a2eec4ba62d81388ac862019c37e4735a636a040a5ae8ed520781f358ba6da677156259d7df4437cd2b87c816c7251617a06607c6341c845ddb815f83d603165f82011d7d315b36f73903d80626f3b5e082409be86f51270e4b99e66c555dbe1d07bfa7254454cd91c9d280def6ad46f379661fe1c85e5e59e035ed9c285723ba0773156259889229b21a067b30f8e80795d56262c15d18f54f6448619419472b7a440f03ff5f9c7228a1920cae1acd717fff27197063567353a70a757f0a948cf5441362116117e4755f3b52a802c6a999a11ce7f86a3b4e45b06247e4b9ea7fc1c229e9fb840aa9db5da8c6207b72f813931e59a2871a3f71f11003966a9265db1c1f4e99d1ae212e58fb6f065140a377835fac3a5beeddb766f4faf02a3d07cf1c05c529f81eb1e373080cd0fa59cce1590009d31582d10af5bf5c6176c02dbb15b07a5b495650803a75829ec37edde54c5e81c1080e260daf8714e25d2b2a18c04e97d0c9e8ed339ef5d5866560c5dc2ddaeb9d117d25025cdeaed0584824b41d690a638dbcda2b1c5bf0c3350ca5631459321c4132aa2138ebee04fdcaf02d2b727be3f2fba4d63435a8dd18231cd6a8d03d4e6f004c661044f539eff5b0b236bf1ad987c0668913ae1d8d4b8454f8c9354d3e80c87a74baf7f70d1ef59834fb4ea314c2f4704bb89a8f4c352dc9390de786cfdd0c02ff2e2c7299b9115c57ee7f491d8bc2207e061b7c4e0bcff58f45458c8850d4870a347311014b1f8d87a6a6f00e7ee165d582efeef13f857ad063d63d16f199bd57cacde9d2b865814c2dcc8d97acf079f2095525ce0aad9d3d68f6c43ff2baeb277736ffd6753dc6d0eefb66074913356a82c573e70cd24ef043781aec80ac8948a1f96ed8a3217a8cfb91fcd0c375aa1e1758b2ea875ba757b3ea2b84c2e8246283392cf648b862d0ff33d89f3b0b805de5873d2ce140e8d7973988e7e8236a7fa34bc8a2cf1472eb9b0a4a0d90ee092625c7ea7b768243b965e9aaa1cd824e4e12ce2b885c00c6ee22503c27fe395c21bf3422c43ab1e908e2a39aaec74d1053de4db2694a13af9a3ff200fff701ee2b2b4c7413bbc768a0fdcf8dd76a07716f49fafc7adac2c75e46b230b9743aeb1de0cf61d5c66ed01aa93f7fc487895aaef2b72340df33e428a1dc975996e10ecc382c2929ac9a5d798c76b06e84663ab5645fe0101969b751f7e345cac74165ebe3a9aee238d0e335542f8dc860b757154fee8156a2d2e9bbaea400f5cdb4b3db22d9814e912590d7713b83c751f4fc4c0bc78db22eab2a114f48aeab3a3e9f1f96ede63a6a1da0cd2d7e67c855c43954fff4634e6553f856ef49b9ba0d7bf90b5e7b8758a23d6db654d1d711cfb4fac12af0a2bad61e8865c7d0ea9db19fee012ace2ef8c52020db6d345e7fe48cc4a61f47545fbc3aaac78ada207401344eb3c438b7bd4d521101e1f5fdad206ce95680880c420a21011c3ef614b70b0e7bf97d91e641839e2db80e5b2b6acbaf05d6e85a31ca16ef6605103ff3ff810b244715d872cf0f8ef09bb2ffe8d33df3686a79b43b7925c5add6948e4ee887effabe28f4b3672564705ab064aacb5ff92cdbcbdde47cc534b5b1181b536b672317b0117bd7e7107b28d8194cac1949b89291b43b841a8094e886af735257b24ec018e17c0834b95c69b5b2d0d7226fa235b95b4534874b6907343ce3765704660674c27203ef7dc72d8686e483f2c866efd8a75f2a748b68c8ca555e00d05d2992256c806a3f82e67b696baf16bd8f7961be56c9bc13d744ac7207ca0fd19c85e1d06b924332d1c305b367b991bb61cf9a39091752e5dec2ed07d051c1acc4284f86179b7ef63a299a14508be7a21cf9d25f1882827622bdb4a9aa5989ea22ca1ae83814e6a2d8ba9ba1bd3c396414df81fce018076a30e3dcd2cb42c56d49b2cd7fc90d02112944c7eec6d0085f026063989642e27d5aac1a767dfe9e2f433b5d01b71157ff693e304a3e625a01072b242e35cb5370826081ce1c314dfadcf3c6ae9a740a4eb35541dc435b1eb3c8b76fa86b61754076c5e35f4dae999bf7ba0f4629a58025ba0a10fab22162933042f9a690286df5923ddef952e030fde9716ed001ae1e343e7cbadcb75eddb18629cfd0a18526c12754635a359a3e08320a709c149756b46e0b204010ca359ec7ea4d3706d8b9ad717595b3103277d12e4a98987acdc0f119f59d8d989fed9cfc42cfbef962c78b9af724d1efb8e19d4e464244c71e6fdb46cdadf559b1633859e82b1131869d5675f6381dfdecf60c95fc1a8175e303bcec66d3cccecd357f789672282913af85d5d4ea38714708c866d4cb78c0324e6f3c0d967e8a01f9452b9a747ce019cabb9ec86981680519f1ecc1c7dcd78298b38075b8b4265303564f000ff1963ac3d1a234d7cba71aec54a3493feda1a0ffee39f17a9e54c11dbd36d07881aab079ba95d72494dbc9495e0fde434cde3f3efcb3c75d70808c65e9fafdfe67a79138e1a50a872b638ce3a8025b078a248b7ecc37df6d9ee126323ed146e063237dbc850a668daba8f9c0f1638d576db130bdaab494140c255a9830ab5100ab57f58dd32d91b685b7dfcb1530ec7096ba619f2f225b81f9a933404028d87bb8a500582b3ea3cd2cd146a6dd5bf820466cef2c11d018c8ea7c56c531fd4c6adc82220cf26702e8c4ae4839ed4db769e25cbff9755d153c7ffaba956cfb115fe91f58593c186d10326ef9f2e05ce834710610b51d06980d2e619085637e8c2032e6c5920a1747de27cb994ef3a9811a368c535642ba05ff5333ea27d4b77a93faf029edc24ff156e379870749e1a1a3c603aa59a67dc2b2660e43d00525f0ef8c44ebc568051e53c5fb7ef79a2b71636f987e3924bdc7c1d1554e5713689a01b40e687e09cbb1098530e2341a9449d0344f94296d0b9f15ad445b614af47b6e2d5d257e16e4493bb6beff6e200e7c34b2ee37b4af8c0382ecc5288307e36129eec86d248f0d2856d75dbaff943963b50d3571df38d3fa07d51a046a06226eb69bdc81f2ae846254ba71679939a934bc2d82d243da61f38da2f4013a4e1239fd7234257d901cd88a43ecb80997e999f6700071da7dc4912b3de1a4648e58248f3263e9389921fa16f4e7fedcbb595f35a440b0ee24c7ff82dacd6aee59499766f5755f1081f8fe180d633a6b7ae9309b57b40dcd2104fc1d2ac99ec8033bedc175a26366b10d78dcda852211043467ccaea42516fb5077603d2ce79c6573836c04c4b42bcc01e0e3b99739b675be0fb2ac10470856394b27248ae3659416dcff47c11a8d570066eae4914c77ee6693bea7baacbad977e8ac668701b18e653d468dc96a6ad1b5fb65dcd7a975b73e979422b7417977e2e6ccd5382c6a809ff9475359fe9d1181bf8438a6973b0b9b651c010a1a6e302dbcbb5a998a4bbf132a3ad59b5cae74645209a60dca75a43c9d7374d37ce8b64824a4bc6bd555060f251dcee58438883ac32722f36e5f52af906cfb45b5e8a5b2ae7d877dbd9694521e12de80d73c24611d9c2de91f831daac05c63efb74dfe57deb6f7c64ba5150a7bbd151ffbb76c5f66196b11f7a20784f14f744f1d56b4f398289abd26dc72c93059c8f16a6d2c88631797de84728107180621b733f972b5bd9dc3c55c41e61520ec10a619466428a165be3dea62fac83b1b1fbd1d98eae8154370a32b02bc2396f567aef4bb204c19a041354158a68b9f45d4249a15863f0fa6f453b071f08da44c9e8f14fb46aebd024f19db69f152b2d9a2453a7af5d358a344dcf3263035bc74eeda10e881f36f0dd9377c94155e5a250bfb748eab6eec0fea0d9367537c12a51749dfdecbac5c0d517da414cbb40a179e6493312a6c0014b4c816d7cd7b1ee523c7b537f2d8cec7c4db240ad796dd728b0d2c493e8b24d72080ac058e03fee84141ba0f5c9b58fbeba60a37f232f4e56b4a2864db7623161732bb51c78ad656e08411b32c3f89477a04da4e7565042be8ae8c212150035623505b1f97906fa9cced46ebcd03606f7a1d567888b331fca28645a0d143a4862e298ff0f2b96238594262ff56c5d0dcd8a611bd339310051e5673f8944700eb143477e48cc5e076f7868b25a33a3481c484256a04c36df113aabeb8bfac3c91b8ff078ae9e7732d52ec964d62cbbabe5c86811c779af0bee7497ccabd51c4a01ae3527ce929569df5063642dd8d1355322607fba5a493756447678fb7436e40e11db64ff922ca596ecc215957388fbb5c574668f1ac523e96dbbfbc04fd4f592f6059e077955060c3d8a6d7b30da8965ea21f5094bdccf62a85b3cbb41f73d1564bb30242cc32fc3b25f9c4e23ab9f489cd4019d77dbbe91578a52247ff90fba8db7a4f67ac755ca101bf2f2c0b74ce3bab7b991e32e5e87c7369d4b76a898a935eadf4558054d1bdb29cace3f0615c576b61e74af4d77b00075629b77c0497d5bcfa7d75985b14a21378d7cef767c95258adbb077e9d5c9ee23a03f427f61311f05fd212778f07d8d0cbb45c55ab7513442ddafb3990e5d5750b49990c87338b1a1e00ddcb95dc4392a8c6a0cc50521294448f81915a02d3485e110d006603f4c962de4b0c966cbab0332e53a71363d03533601bad78c0dc28f941e127a376d4a26099287338466762369c621ed3aa94e6d0f4f3e5a81d8ca1d44b6ae4b03d8f4706d37f3f593fba05756ae2496b7abcbc649c2bb5c15da661bbf1a3c3289a6d8efc1db0ce2fda9b730ae87ba49fe62abe0830109f871c5c85824db7d333cd9505123aa3774415eb033d6bfd14d27629816a7fbe101f164b57a092d970039d9e3fab59546280595437cc63583b8d498ec694cc9e3dfdb572ee9b87523e70af0d852289d91c348191a1f3101e7e2a8fac463c425458836990c5252e39f588172121fe58b4a3afa289f6b897b56f4bbf73266fe743e5a6d36d23cbc42e5cd4e0e4b2203be4a9b1822e75c59782480078f6f24164b01f17f0f548f4d96bc83bc574f782343ac535001c75e2dd6f581bf6a959ec5720bb53e685b47d52b7cff667f8933b1c7afc395a32e723963150a34f1661776a6dc76b036b1a12d8349294cdedb471d674e37370a505f8979b23ce34753234e1094ebee2bde7a56c881b9c3152f7dd5841879b6dd6a42eb667832cfc8b4b8bfcdb48eed33d2c36fc6eba9bfdbf8b5b237f8b9a6046d4ab8a5526ef76822ba638f026fa7ace3929b0a819514dafa9f1ce804a7d3e595a766df175afb46ea3e1ec1ca7ebf6cfe4de26bdf1b0b7903fa4406687ed8e77623ce9031797ab24c21fa93f69f34c46a59b3a6ee9ffe5647b249a21d772a77cb353ba371e91055fe06b66557f472a580c463f38ab5b51f7baecb30f1440031297b14fc6771d6dd5507febeb81ba57d15db9bfbf0119e408621573833194b57716d06ae16a59916740bdd30c7f87b5b32d655e13d14cf6fe4cd4ec176fcb4bc80663a85103cf786716c4e76c32fe31479aefcd29373eab950a2e17fb57776c37954b1d913ec9cabdca7b3a38c5d57a99ae9bce5beb70b2c600fd17715c73fbe2065ec7e01b4458013be592459d8f81febd109bfb6fade3fe9795b227899be65f113a899185f5471c70b74adec3d82e46fe43a8d846cfcf2426df72c1979fe0622da9d9aad71c405fc6d795801df3984a41f7a217dff4e4695f5c3ff9a90c1f2062c8c2cafc30f2dcf7638d31da304e116fce6546e259f218b99359181e5c8108f4765336868e7fd2cb276bfd4eb941c5463c51a3730f7081466ac9b2ae47d09ebb7e88caebd4cf29f4436885a2397765d56450837c6bf4b249a0b02fef3974f994c976a23cf6079215fb006e8cd7617f396bb6ec1a19fb842e4f7e29e17c6b47089b02074fe72698c0eac8783973759be836712348192763b76d345949fae09249aae8f01d6d1179312b49c240a8c6365f1be25ae8c65aae45ab5c38b0f9757d8122992a9f53ac73bd7ccac19c7ab21a8f9b587e71fe3f54419850529b91a46195db0fdf919ee3c8e7046d83792e4cb64764f5b49521b050a9800ccd8ee41f1ac4763c3f303d601b51c162cd8937af22371271f37f246855f41807a14cf74cc62783033aa3629b70ae477b902083e42b32d72bc5e931e6cb6456ea5c0d9c5e7710abfd15b53e6e9979b761ad2e652a7925df3698351aafc165faa9722ce56501cb700b58450e461966ae51133441869d79a57f1fd3e66fd95c76da9e00960c3558facfdf2e90ee11e632e3e8d140b26d21f4b076e29749f6cdccb5ed76945f567b0381f539dcad610921811100039a09be00c96d665eb43ff23ee92f21d02c65740cd7d67416542129e43a2f363499623c28d0289186b6cab58bfa5bae4828ba45f8a5ac1fad020afee5f2219d19786df5d670df349b38ca553e81a9bce57d8793af6226765d76c674b1019f604ffd9589ca137ed37f6102565dd98c7c67e7d676bed04f3627adda2a113dd75c01258cbc47f78a7ff56b5ff864420696d8c820ff951aef380d0264748b0ee68c62982e9c44c878ed211aa9eea957137781eb1b70e284bf785d98d2aef7e27e9918e75f522975498da07f17a7fff3b99a99d4882702ed97d4483e9329feb7b6fe30ca294a350a155bb64c70cff31af6059fa7e2b6b5d14d6e2353c9d593f8967860418d8dca2a8627985657c64bfa6e4de97e9ad69c121ea9cab0e2653302a5d6879ac69b16f210a168f5dabac7aafc68a1ff33ec325d3c4ee669292d2e6c128b35d4b7310851b1397a12ccab3eb5e3bef84beb6152727742ddd213a35a9cd994eb09219a9eacf5da89a6b06f8129b37ba56fe264c47ada3ca30269b5a43b7da7f91b950ced83684f0a0eaaa0a6f6b755cec364e0125c0ba053bb41a4825a48225608d2831115fadb120a658cd64e30b1108ee0a8940f2307c0c436c5390c15a3795373fa21f953c49a16a67bbf68481c98eecff8a8ab544a0484d76c913589964c1677bb70d352e3db5264d75c76f3a548b890327b71f98f59118dcb6d48aa4cc7874120e537102b11c2320a2cad6cbddc5d03a89131559d2aac4732268c06bc69d4cdbb179d8bddd909e8056c953b1dc62fcc9553572a02197a5bbf7628827755148d9d64e4407d3b4d3f466e45c10c56a1b96e5ce3caa073eb6c677dd6f5846b11f560d25a6f7515f37fc40858178d9c25c80b376ff793ef9e52d86e16000180ec182275d73b612b406dd04e3504c3c519ce170faa95e9832c2a84e8020aa4a3c2ed5f77ac76a0162c5882293ed67e7566c9517628a170ada1536bf588eb5ccae4326e4a31108852a8ef3f1d21360d404649b47f80b26c7ad44856c51f8f3823b9af2c9d17c8147bf206466a99b0633e7f963016068e3538b7f9378d40320f04bc0044dfdbafaeedf1ba732f90b20844404699ebda6d42e93a3083eb5068f30c71b245f544b923e8ba6cc2e33f12aa89808dc7a422d6c2170f1f03dedc11417c814dc0ccd9b51597c719dc5d50fd84bea9f71c22bf9fd1358e60ffe1a1f2672003a35f3e39a366efdf280b30ea7d3419c7d86be98b5cf7a6e1a590c180578285b5df6a5731b233f76e0fc1917c337c618e0f69c2cf089fb9f3bac4901986455664aa9527626bdca86e2717849dc092a95e54c68f90d3039319c0af75f5c08c84983b134dce7d8ee4135534a16c9356c8980f89646fea53cd27a7c7b5d019c0eebc6973ea1cb83295f894ffb1ca57a1f55f20d6806af31bedbd6b31e9df4b4e1dd8d7f776077e43ba4c7e8463ed1001625c2f0a1360bba1f498eb75f52b993b9e29f1022523e1fd6348fde1052b12ad338fd6d7995e21d7a1b0f88875dc6bfd34df33bd533bef209fa713e34f16ff32a212d65ca59c697dd227e7dd70bb6b66b5209671954641a669043b8475b6df6790e826e42bae1737a1b45a8cbf164ce78d44538ba18d4820ac1ab386b7f0585e739baf65d059d3ee3f1c93633ee299a84753534b711cb4ce59ac6a5614bcf0ba78f084c29b71e853bbd52134a9e618acc010cbc17d85283fdd4a4511b640ffcaaf0e2bef6062d7e9191a0f0d03534e953c7b0a3a265322d163c74fdf67d84e807435f31a22e267c55ff43b87a9c02f9a5717ef35f296fc6b20605222d62fdd9859866de27be6a5d9a2a64d1ab683c50384ceb4da1328ba5bf5b9da9428f4e0c73ade072b0057a48ac4c337bea2b393c59ef129ae54580039fbd3ed2cf6662c2bfe301b20b88793a99aa6d7071eec36102ab54ede0a2ab815841a356b5a08764eb7585d31fc842101a52b9833d4aa57334781895e9f6e310757d5e19ccc098cbe044abf6d21ab0f45e5f78beba6e782c52c963b5c5294c4a1fc7cb5cc58c044d103c21d4e8f7040cda01d798a6d35df754423a82279ed200ea5820567859400d689bc3338583844f6cb808a9da79494fa7764629d72fae00fdb08371937ec0e3677827d4a5eb4f6ba19e2d709c1b4e882473b817ea2e360fb7c4b335a3ef75adf83a80fdc8691fbefb5ccbab9ee1a8ad5cfd3ccb0e01c583884bbea9cc5d95ec078eba2f4f9358f957f4d65bc3c64c39d2fd1ae0964495c0dfddf1df4c5e8b3e1c042f1ddfbb4fa3185451eae9759c154328b117331df3f548ad2be32c13a653edb51c6846a0f9c77af6a14ff8ea30eb1f3d014defaeb5a6706a53588aebc8ad420eaff22be31d86a5666ec4abe8d7b4e6fa4f89a43d670c4e17675adeb83bea119b2537597cca3b8e63819a54ba23187655fbf05917696c2817e2dbff382ed03a6c62d57e9e0da0d79fa4d76eb8bee0e8120047a936730970327a92627343214b1c3a0168109b7498df4a75ddda1375f5efd514849af21d30d2a8b2f3487979de504a379ba54e2d9d507db85db51c2277c0b1fc54306fe637ae8a7f767605c7b01b3179eb33d1b405a7b838580691770ad3ee2380f63db483ef6373edf3d0636e76fa4ca13b57fd7652850c5fb52773709581b31446db5c3ef3e538284a32ae2bc66075d598c1c439c227a3154600f012a27803107b0923ca3fd1ed8a443c37c3fd6b757ffee266d0c2dad8d44597224f8a5fe8e5511ddff6483f8303d8af7f2975ef47ae020bcc2948765122b87233bab9a19c0c4223bec79a50211ebd1dc2763faa9f78a962432ba8ca4fef7646ef3d43eee06da5d73a5dd4f3a618436ffa53bd173b16e3b47e34a21c75c516365d8fc7c12730d1dee0db4a0aab0e2f883a19950df726998216e507b315b03baa2df662fa970d02381e6a075b462575d4fc3f0e457cf3c4493296651f5eaa1b9a2d13dde5c499d291f863d0aeef67b7aefe94775de7a3b2d2e8c1d6cf846f529cc6ce32d9666810b4ca263fbdc07a036560fe7247e35d78953bf5231e9c220c5edc9aaa4645e4a28ac1d952258d66afdfe9d7f233a75068b08b7c5e0a9bbc3739aba787adae9b013fcf74f8cf79ff2b4e09febbe155099637d188b981bfb51790a763a4f5b2beedbb3c35ff8f6593c14472d570004842f2b2b39e433fd2e8dc95298cb8ec79ca42f6953aede03560f1ced0ae2f14d3679c2cdf20f9879b19a37de8698bebbc8a890f0562219def0ee35181bf048d534563a9bf6b2d7e3c77a017e7403c0d7e630952113f833fcb24885a5e6e05b5eeff0dc8443166e945995832c7054154b5a70e27eb7d119e3cd7c175d169a6840b5f6ec3099ca4e7ef45d077b9f9e6d078d89f75c1674deac5f38973b8925bd584141cad26828a52fe24bc9d7ef369e8956ce18c8c8c300e9e9ea253beccd28ee155b009580fcf91f873f43bb401144d40f88d68a82ca4c0ab72c6b6202308c041d45601b0e98967df2b4b5c28856331819a381ae67317d23beec09993a5fdfb84e39186a8765e1bdfe7ad18842d4505dba1238d1940d873cacdc16c4a6674b4e8c7f166edf4148082a471a554339af13396659433bf7dad30f9769fcae8787c860d334cc7103cef4825530b4cd1e22fe8eb899caae7e2e4b6dc0559c0188a436a55eb39c5c8e75cd8ab66329a0fa0f4d0c9bc2d7e9443bbd5ae11b870899a32e3ce29bf2b66eb3e5bd0c50e6264aaaeb19171403eb44c7c8ce328da690ad2bf3872118e9dc04574c80dc204089821a54478ed9d152c27a2ce530e41b3fe503326b82eaed28409686bb0ea9074a0f080c9fcd25aa10fedde07b06edc41058b9ba4b5b12e6c563adcc9c17ddb53dbb58c605345441e44e39cc0f511d93fd3cd28344e97acbb11fe5a3f94a1059a458eded8ca0b5b3f63c8eccb0444c9ebc6e197cb1c8f1ff7683bde26a0f36ba46b19f89abaa0a642c032d3fd23ae4afffed7503537c17986d5880dc0b4bb7968f3f7bdd4f5afedab591ecaf39405099360c5c07d8d179dc68e9d055e8c1c6c252a1c839bc2222b7582dfcdad61b9b8dd9087ec7435756cce6485a7c5bd0ca1ebb327cfae53b35379b5eb231b04642b994c701e5e00c0f8a786f847f32a5b885352df0ce90e108a716e8596a7134986fa0526cf4edc6f54afcd4f2611ff63e61984f90b17f0dd1962f984ad360746af0ea695f3af492777239d57002f47f2925fd88b9b51a6a86c26a0969960bc8a765ab1a86156b3888ce7c9d14bc72b2e11ee4b2c937fb6fe333f5e75615fe52eda7dfe96b96b86d9fd5fb1652a36b07404e0a8f4318b5c5d1c714bb388e6ed76d3f5cbb5f5e724a47c3e9285657ef9e4fc1690a58f4a5363eaa799e40f150cc4c0e474acab9f683bcdac07e4c1ede815319cf0042d2bfb5fb2dff22898e415991a538d970c0d7e51301ff2859fb951caf60907d5333dc412891e12dde87c84c0465bd0acd6ae3538395ce0d4797736754c078adf057df6f433ed1048d1ba4ff92bcd9df90bbc4220ac4d7e52b6cb135faa43c1b49b7fb15222cc571cd8916357e3b27e5fcd8c4d586b20ef535aa5db2ce3155e37fa1a407d98703a8f5d520f77d52e3caa78b604f1bd8aca63accf125f195f53310c77f38eccddfc7ed0045fd42543c6be9af6b55df3afa809b491c4f58c2df38f95041b27dbab52ebb8b3d9380fd82446708a6607468f21753e4ecf3e55fbf1f3f2254015ef7d9e59cdbee13088fce3e2f7a5ab5b82ef2194c6db1ab8e628910ef769a43744fbb963ab528ffff2af0f009daacab27ff2c63c5b3769bfd479e77a71648401323b6ae0de2990fda5fe467c693992724412caebc0172391fd3de26fdf3b9df98b4418150278049eb77fc409d7b9285ca0ca41ae3d95486e435ccf9d2642fcf6e2679a532c8391cad922e33c409b294074ca65c712fdc1f76eff5e7c603b4bf513d896fe6c8dd6bbf99cc118ddfc238be07ce42ce5437ed78402e07b1ed7320463eb78a232ab6178640eaba27a242bd0bcfbd7c1d57f12943f1950deb0aacf87c1f29ad980ae7acb9d60caa796fd1fef4f4d1fe1a5543f152037f4a7123bbf463eae7a12103579470796cbea04350b12c8129807f1404111431d45b8d3e32bddb360a4d30399fc724762412edfcfddfe943a52e995fafd120bc0cd963fe1605ac01965620f35e30ce803a785309fc35b717088727c43b0be6caf924ffc54ab8267512a4d80fd78a6db87ada2d498025fbd17ae254c0544e793487f9b0d6c59341b98e8a3eeb172a042698b0abbb7f6326395cf8a5754c55b508d06a410b06d2af434749e6e4971d5f339de1ebb0f72543f2892351694ce5bc64698decd83d36cad4139832a9411ff60f78f5e54e54c3925eb5de562715be70973092c9b54c20a74d185f2728194f08fa1541e1f6c3b290f44f013595ad0a01dc9f38ed32213e1430dec3ad0ace2448f55e0cc3d09cf4a59c072511c8b135617c87c52bf9b5a37ad4bddb06756034862505cb825100bc88291acd87c6d07e74169e419433a58e719ac9020081b902b86176d68822f097d68cc34c0c2939c2c3eb95b6668df2a4b990fed81dea9fdf36cdac38ea428ae6fb4b4d191f06116ffe167faf58b87f01dc57e5fdbf4f2484bcf13f067280f22cb6d0db324e63016d666723e7a9489fdcfbcf9efe23a3fa567cf4236a4520fd1b9051aeccaa11dce710b1f7fc1a6f80f1af5fcea982693dae037214218e5f98c0797865de7e92eea05e985166e3c166043f2b2f0f698a05b0549c4d8571ad435302b2728eb490018b00512778e90ad9078198f10ed4f22d918b6c8aa405c5ecae8d901ae03590bc120a6ee61e30c7dfbe686d32543a0cbde3554e610353c2ecc923de516d408cb8df796adc05cca936f8f404ad7ebbeb5b80d3d70c7e26bd6f36511645da5572be0477ae166c5e28b90efd6c669afc84c0fc24dfd0bea075654cf2750bab95c98e7d2ef7abe4dc54cf0d768c567d224ad4de212f1dccbc0f0ab9e24a2b62d51006eaabd033458b92724bf3664c65fc5daab4a7655fd9426e1db4f61e593dff9392a565d83ce4ce9b01b3dfce271c60877f131468991ba5bccb899d39c02db7a448463c26238ee301bd830034ae298f96cc648e7afc3eeb1b09a1984d3ee64ae0ca2657f2f0396c9696aea92486d44a8548af61e0525bfa5750e5fc5f98b3e4d5dc4966d8fc4554a254963aae76462c707171f78a9454bbacc19f285a8e4d6b70bbde6d02d1ff38bd27b88d39e260a79d1d6cc09321399202393caea6576b0b81e2d759d5792d50bb33925d155302460050929f8a391c51f4bc180064b1f0eabea0bd8e7eaf6dc572f324db604b635a5bede3174e7de59da813a1a04d19d7ea7cd92152daa8e304ef00af5ac44366e202d3da068f0062a8ec19429db242042ca549c2d1f0d5cc45527d63352f14090eb6cbc6ca474b91aa8fb2d7859979d7d63d702ca790bfbf06fc5f06c39cbd790e81b2ffce61014b14c69d5587d4f415c8beaa474c62473860835b9cde7864cd64af18d312d74fd4fe93d479e67b10fa075882698a503d2115e3284f450b2ef8898a4f48d2ab79069ef030f7c8ffb7f101a7b1be9b7d86e89767b859a1587f2c95d1a29a5c9ac58af8bf8a8180de651ccaa21ac14008a8d09e78fd75078b145c35808ddf7604a8cfcc53086efdd0b7396339cd99709f441c46c28aa49a4bdfdc81841ecb9bdaa8845d1ab22f78c5a2d5507a1cd244787e7f3ec853c42afc7fade68895e189a1f0b3cfe182fd704f9168aca959959241b8732152d0ba2cbb8e8b85b113fa0f64cb3523061848521c5fe995af367199dd0d01490ecf2a28e53174498599779fe0705782d0589bfb5cabdce2ebfc2354de0d95962f53ddd114cd8da72efb79cb68131caf76a496042541ca141c90afcd5876bd7615820aa8eef857a09bcb2ad94268c0890de01c0ae392c1701c83a4a6fcde9d3c24aad9f56f45b6e77fdebeefe4ad007d182ece4561a9cd446d5bbf0f7d1814b928aca1254cbe3fc9dbdf38162a92c785b26e6a1e3e786d8d7bc472d681a2ee9211493fdc79cd4bc4b9588227d610003a7c16e1f890b9d6ce02665a35ce5886a7a02e9bd500d72e3f119f9dffb19556991dbc9e8e188d92d80d94d63daf295bc7d43f724acea27f99d4fc57a12699516873c26865d4039d36ca250d6ed92870f36269b1fc9afc69cff4ecff26df43f1d4a8653682e4c483c7eb48a6e793cb0451410ac46cd1becdce7e669ec60d80c475cdfc5503f899c185ca5121a7fb6a34bdb52bb49bc3f1d4728fead016e34413adf514fedfe0dcb0033118233a3bafceb8f94c5d0a045f6d123bc50e47e9c9a380711e1a6379143c5e449f1285477dc5bbccd80121b16908e81a1e64abda6280f223b4c6d8910603491ae30c3dc3ffcf0a6cff9ec8045ee09d53f9d07eeb7c035ca30df0be06f13ca79f9fe0f2b9b65bb8bb05737143219222acc2e633198c93a97630844e8395b27f15b02ecc0aa595dbb37ce4c124baeb75daf8a2981ebedc33f49307eab83a37dbead0a1cc0a2977b704693798f5a6145815333cc68f18117c207de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
