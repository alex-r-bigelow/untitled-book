<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"272a01cb96af0e46b6e4d725e73cc9b9ed0e282b429f7accb902076a009bc36d665ab0cfad432f3c7d95b7b6f6d292b920e1ccd642d61de63d68af8ee3a6591e71a17a156cae2fde3a84478c128a4ad78aa7e064368092b4ff020689d03bb5255dfb06c1c749cef4c6d4b3670d17a786c84c87353675ff3473fb876dff82f4d7b03d4c30fb0b412819d85a674553eb238bcb1a3a0e42dc836d4ccda8bdca49d73fcc765ef3d2890daa32d670b2bcfb41ccdd5fa2d5b797f3241b7c89b3ea603ca8171c4b5a8588c8f1d7bf519a643b6af19c06f11a8f8054e525e9d8019bbb0929561fd42d4bbd3c96340904dba64ca1e5b293d7976f568f3a102b456f52f9d0c3b900c3297ba0b815ca2aed8f7be63f08b4f5f590a2aeaf103e05f67eb1dc9af0ead9bd6f70ecd92fb2928f522b4abe2dba020096ff33956b1abe312623cf6fdc709a89a227883cac599d7613ecacba3ad3d39b814bd83d167cedb23aba6c805167535ec6a9476ebfb75a3d183a41ab7635f2b29fd3a10876855a02a33598fa90ccabdd8c79111e8631d66159254d0b87860b676fdf772931de586d760fae8e50e6a1e626b442ad4ecc24c78d441ef7407b320bc66660b5f4f4dccf9897e8a7bbce498f60e53264b77ab6f87760f5ac8822df20594a12723e099c5dcb029e82014c7a19fd09e7278bad4b4742cdfa20202289191397f13e01e68d1db055268f83c9346f468e517338ea7bef495a3f9147b4d289421e30d9cc3fed287def951bf83bd5f87e086f5b1e6640bd8daeb88fd9823471f05821fb71c71740f7222664153daa868c7c785be3e3f876da5165bd82b819123a934624d9a591c723f1ce1f1c07a8feb787dd500d486fe549549e6dc51aaa793006ee1cee3b6950b8cb4b93c3adfa461e775e0f4b2e5768a9a67d45dc57ced12cd9c8e87429c2525e0c878d36c82f7758403b4eabde83c78c3b044f40971ab16c27bf8fdc9cdb25f46f1f0bbeeb72a83fb782442cedcecdc393646db550969f7e96454c2dbe0b88fb381c5e588f08a909a362795fc46ccdff46a8d6a3cc3a5927d5c34d9a214fc7343d4ebbf17fdc9cb1b4c9ac4c63ca0d4222b1a7287ecd432946e7bfe142290011589b7a8d193659c443540a9c861ae612d125a13eaaed014b53766c44a7c0655fac81b4a769f95c6b72c959d8eab6583ba883291f3340cafb8b31b3df52e0ab07d2300d078264b18fbf0010c13856e9ef6276dacb12dba1029d4a4240a4abcbdd5a24da33abc4a9c86968154d6119f8fab082c84db0df5f9ae32f55817dc5217c068e038377b2cf204a871bedc00e7a8685c312b14d0ac5a81c6b15819635eec8ae3150cfbbc397b857dd3dae2530f1612b36df822c1561a0dc6dcfd14ea86908faae87e3222ae4365c494ec140dcc4649e4a86f9c5d861fd82ed7e8e3e4ddf03562e00ce7d4b23dbec3b596adbd502c7913c0c45d2a88ac3e64de5e02afbd19ee73806f70ee9b4e258f663472b87253cc9066296c1e747d80624a144e61ecbf17339b799fa916250b4efd30274f59388f292a440a98ea5f73e93949c635ed18bef163aa8bbeacec8bbe104596999a9d872654929a31967f869a3eeee06471d256ef25aa3e238262b3f9b92be217a85d3a8a70072018793c58c06f38ec1bc4fccaddeb3b86f0aeac922487e7e89e3e43f34b7ee36b6d34c39a80e009dacbd5dac8e4de6902c3af85956d7dc6a1703b7443d8b36710c71baf6615a17c17e9387486cef72310f41ede6453f04347567172da1cacd1e8a49222fd617def661f36e6eef439f0662cc878cfe930601206131d2489b53991de2cd4b498a6f4b05062eac9a1966175303307f8ac09343261db358284e3d2c2aa99538bbe47a91304f70834d627f7502c4c914fabee20a1a79e6e5a160fac9981de7c09afcd7b893ac583046f38cec1a25fc7ff47e6acec05ea82761f74fc46ca577fb636650f801308a8592ecabe79e3bf84a6186a724b542cc26fa939744942c6ebe40575e832eb80604155ca0ac6b9e94af16bf5b004fe49376ebd2c03da69d420207753719a152bdd8ddc33ccb74f3df1ccf0bf59abd2cf11cad049840bbdef049e672cdd2e1a023e9e19bb18343bb6abaaa2db86607d3e8831d4dab7a6a224f8c6db6fe686a06ce44cb3b9d7117313c85faa9aa4c9fd81d8b066b4c9953cab27317bc2e030312636d78487049faf976d5c98d405bcc43ed5082f7f5d36a940c625d5d7581b59a3e14322999087516dfcaa2a175a42aee653d48e5f3a4758e279cb9497ad6435d361f220da4961e304ffb03741478aa797ff98e98bd97bb662b6cb3bb3bc3ed0345e8eb23c7dff9b800569592d8a5920d800f8716de008effc0b223c25835e322ac1267eb91931af2a1526a58bd463ade76c1de5e473f7e5b9dd65f2ec244cc67353f25480dfceb3ac8be551a3a167d159580abdee4fb421a8a0d87b8d8c6a842b42edf49c9230d880bfe46303e77dd5cc185b51fb0b3f806fda212c4a24643797e8ba3e7deb3b1938e41572fe7a747324a86f3a31637f9ae2645c01314340d21e420aa24a72ca4f0953addcffff4a24c92eb646a0f788ca917c5a6fec38c0166943d496c7bf107e386644c141057ae91dd557665bfc1b352fd4857bb498d34dd96c2bf341e5f2986473ff7c3b23cfea064870350f9e5dc5e866cebfb4604a669a6e34318fb4cc60eb2e6deefbbf568af2ade78723a4bb6a496a7b0cb9a0d09145ecb47ca0d76cb995115be7b73be224515c1d321699e05f5863bc6d4b158507fdb079852bf67fb71c04e5f1390b0bc76a7e156fef3630b1d6a34b9806fe1ecb19bd0175ff0838f8c415c3a86db6b48cb255778f85cb502006fa3d0d28060da70ae40d7b6a99d5f8e1f32d6371f000ff73f5be82de255ae38ce9e04e4582fe461ab07d6d53c0ca797279ad7bd89128d09aeab8220a2904ff7d7afd2d6a7611bfde5d1ebba9569eae20616013e44b14e3525366136801a7a2e1e3c480689d254601ac7d178b500de0d95ca7a7d6d5d932732d9c593a71ac4d36ab76bae60cf7fe2b02a8026cf5064b38eee4a685ae794d8a810cac9303a289d9823f5aa988bbc92d1c3c8d840d33ba634d2a50f5861a07898ac1237137590b0c52158b59cad2d34c5c8d210668529e55a618fcdee8d38c4870e1ec88d1a5ae51e2028c456bb7a9603a1ed7ff92feeb47b7f1db6dafc408bc9412b9c63c4585c1f2ef83ca01a82bccd844c949e2414b4f07eb8503294fa9d69c99f4d999ca79ce2361ea4bde1c2ed2973ab4660db1ae2bc839dd4e0f3d420eacdc043249e79f4cd5ea3d122bfeabf6b99dba36f32880741ea5a5f30b3ec671c215a77b1c6d2c69cf5579093d39110f445d6448f524a8e33a5634dfacde04a2977ef84f40e1b6ad66798758f92848d1d13a6ff295392d4f051b1994f4f7177a64b5254c4f68ef3dedb166039d1c0f9a7bed7695a1f3db9548fe776b3fa29436371ef0d3678c9c1586592aac2a93c69e510f60e40eeb2f5ceb6beb6f802a1c3bd80251a4410e54ea6320c902015f988acd742f75a8c2277d5e2c17efd6a5df0022f88d75dc01a73db9fea7719cf4c6d76c78bfbfd2186ca9c4a9f31123aa788b2b69156e2f357d95124774bdf4b913ae3e7be2cd84f12f3ed8cdf4114b1b9f5c443756aaf291ab83f731cde42f9e306c5cea97cae18517c7296e8e762fb723943e4dbb4f7a913269096f067f08a21474f4c5e17b6e0a65e418177184d11242413729c9991fe6a7780f9af9f0bfdfde4b770d61dd2503bc92c5a8818a84bd15171b396e4520edaaf6a63730c4d0a4887a3a402c2a8747975df4ff60937ecb5515733ca4adb5d2c8678b86b441e6ce03e40f1b99dba1a7ccb31fe6aaa84cfa50119f74ff5a206e21d653ddf790ab38bb052f319bb13041e70a4b1e124ab1bfd286474dc51577d065fd2e5bd0894f7aeaee4b541c454882ff49b41a4caf4a6d093597b4a0b2bc97c617a4b3e4a5c530ce18589cf4a9a0ca7904e64c6de6ded49cf7790f4de6c2c48eb637b3798f8c451aff8bdfa7d95ece5105c423c07a6d602c9adf375397f52bd260e724ddf373be865fc1386cdee248c8e7aff3bb163405e960e841239c55e3805880219640c41a773850c1723d9c7081051ca24983716c98a494f315651937f3c912c9f093c63965782fe612a36b3a2acc27a24f506a5153d4c2e68910144bf19b25d96aeab470bdca70e1177b615d198fdb866a40d489bdd7ccbc5bc0f5281ad13dfb5d916266d977568e0cd85b1d185e7e7fe16eac930e7e4f41f52946ed9c1023c35b360a8c4bb0f4035c0f5c7065e80e854a41547aaeb192b4f5fb184ee8edcfa45ea40cb26f20d25a51cb198dbaddb69a0e870e1003f6a458721a7692fd0083bcd348c9e8b597da360089cb5f4788bced902958b3037aa07779b9b4a91a3d2fdcddf9a48ff3a440dcc4d652f993f0f0edfd046de006068ab365ac373ed125a338d67f1e8805502982d215a3f80e9c3462181ea4429683d37820d3435d8f743187ad9c9c0d7a8583284d434d5365fc88713012f628b7b6b1354ff22f2bf1e7539a36ffacf362844fdd97774b9bbee07d956c85f59a17d13f08a9c4aa805525650cec5048660e6150b11f876eb2de4a00a4f36b8afd9b3c32abdb777e341ef383c278fdbf6e76ce749f8936360d857d8953a0fbe06443b761bca1ae4e59448e454b85c9b583bae6c3dbf7cc61c4be76e0d81c3788ec98432bf60bef2544f04887e8b7daa948f6a0a65afa91dcf47990479fff21fc87cf468a3fdcdc6c8b19a71bd719305db745c97c4a7579e3b6aed29c55393afa815700d69b093ce4fe38d1409c0bbf9a44e515cd53400465a47712e4ff6246bf3180566f27297dbcc35ee67d49e09b345708bc96f11c072ff5ab1cc326e8406c1fc0ba76bf57ff4dc7848ffcb76e328ec95958e8004d973d58985905094d792129df9eaabf6b5d751b12f75118f3147ec6e68058911a3198bbfdf74c7ed5580578dd5eaab3a65970cb789e0421727d74f43d0ca24b631ef0f4a702f43a84bb99e8016f1f6963910cc382bb5e8d1554edd144c329bbfd0a519aeb25de53f66ad4a784fc51bcfc9de5a8637c7f44c63f5ae28886e36e0e25c31a242648ed75debba99ab422389c94e1ed8254e51cfa0420d57de6a73d5f351707b6a10d80f5ba930bb6b725d6b061096517eda53f1b1646463888792794531b92ee5e969b5cec856fdbc1e4acf925378ff2663d255daf75ffa93159ba9d841c2f2e0b43f63e8c3a5c23111d782e8ef70ed15d6f5453693932c5dff2f33451d57773febb8bcc467cd9605ab8fc2023313bbff0fa41e7ca9c3e0e0f688431ac7c547a9009152150bcd749706d00581b2e7b8eaca5667c2dc38a6797c717e05a7bd277dae81d11d5b5d76b6098fc2c48055954b3efeab62301af4a54045f50e39d569ee854ee7b314d89c09cbc22a381527bff3d5fad2271424ca993918dd341e2a49b33411ef10c0b0c20db276cc1d838317f778031e488296a6f6b9e81ef4a2b182b116a86c52e548ca2ae3fcee2a4edc4821fcec97c71c6ed99c86e395562765a2d07b3ad4eaf1ff3bcbce1e1f52579952bda6672e658d257b1fe298c4371234360a2bfd2c1a1dc2054d420e90d5931bc214a845f11f83e9f78e9f835261f95e6a90630963878e51cdf389fd32d78b6492e62d71eed5d2aadc7639f95663e1e8b9f07c22985a3f00eee9a7a200b68001d03f23bd1c923aafdfc13793b328a2c73b4edebe1e2a2f81e98a2994d4368048a29c608909f99026c02d2e142724a485243b2dfa406180be103f860e2c31af9bf713b8a98a092794f427b924b2a5049d50a62713aad8f5ec9a8907539886b825f7a8939c0a6fa2f3a2ec7555dbbdbaefaaeaebd9875c91a0c0490e2ce51cb121149e61e0813ad03b191acb3a62de53e9c79ee9eae1425ee894b30cec86589750b82dd0a32c290fa51d6cd318e90411881c49daf102a1eb25b95a52d876e90e12695e4a433dea276d9f7b82742267517503433bbcbed02f735fa17b9c53e0fb3dd4018e072e2fa5b948585988ba81daf825150181720023df561f06ac76fe0747ebbd8b43a66ebe05a0477d0faa8a8b105d1689ce5d370bdd636b0dc75b702bc3a362e05cfc6b11958c28f28d467584f41139e91c9e9c050076bb3badce834c19764a05d9f8687a96eeb324f378f52831552648b89c39178c5320b47048f33909cf4984983728bc7137f20aafce63b0320b3cdf32499f8d54a131670008c13ce68d1f462766164b9a3a56458269b0d9982160a6d33b342056851f4b46860c314d5a53ac88cc45a7f26a18dfa420ced7fc3ebcdc23b9097908ba47c893831e624864b7f3c665b6f6bf7a0ff07831788a432fbf705088a92010d8d2b824e43e62b5f7c5f896052a044128ba9c362b5a44c1b4321af81d33efcd162e901bbb164a7f1f6877fffae536d01faa90e32a213763697b3b0de46f75280bfec1c9fd40eef2d206f1409bbe029d8dc1a9434e1a406d429b86a12f2cfac2d24a123b0275840a73de78b78f88ae9b1cca502dbb00bd63c5ef56e3f4ba249310f6ec07311c6fdffe22e4b810b0e85927ae219ba7688bb08b22636169decfff653f3bbbce38fbd024a05fce2c04e644869ba5591abf0569d59539c2df709e5235e0d61bcc585183a99ef47b1ee1cdd6d8e19f634d260092981a0aa094df032d807d161bbfe4eb801e10722432f470d255f02871d133c14738a28a8c6b976fa754fda3a8f28d9cb184003ca275840c7a51f603f4752f62b627adf65453b1ba3411bc41c6f2ecec5c15eb5cbfee875c33a0584e2af35084768f131bb85ef3ef622e345b342ff102da8120e7d5d25a72bcbd2a849db7f6d59153d232ee01a2252b5a9f8985dacc1bb7c21b8d2253e34606729cc26ce1ba8c6b9f87d9badec0d7c5eff9da3c52671092355430aee12e83200e4f160c09414ab9fd9282aeed284fec9f6beed509f27e27988d7f45a4c1b305982d6a09a9a1fdd0e93cf4f38c63f83785e45aa87cb3c716cfbd2d407b06eb48c57e0464ac252eccf55efb452858e836aaedc0b7c22d6c6e95c03bd33ae8a182efa107a6f2d9549a92e8d31067665ff0909ae4ae445cfba25ea0f43f9a8b6b03e5018a468640bda3a52f6ede863cef50131ea69a19e4e61fd0bf54b69948bcfdce2549f822ed47c902cdea3b55f6613ca03b7ee7edf61c92e3ee44d72fabeb897b0f9e1540b30a1ed2cafefa5b180a495e3225e35781659b490314c6d9e644e8508d1a9bff22814e18f322c2755ac2bbdbf2c2bc92b0d32919b112e9073b59763d82e3c467ba90ec80cc633b532f21777a0e9c6d2c51633f8fde2e2bf0bde0a7bd54b68741efbf23d91281fc955fef1d0f9471d26983314a26376644877a53af0f499f856edbf5c28ae17c8f9ac8e8b9f2546da7f2d3e6489a2a3a56aa3bfefa376339c48ca8af756e297c8a0b84434989602a243e27ce6163ed1badbb0607c5da9ad0a6637342eb0787b70f4d58ec253f771ff2c6d77017d59ad1de4a3588dca1a4465f6cf69da36b133dd42c5e053d410023f517cea3156ec32ee5897971a15419ae97dd3f68c5f4dad768bab6c80c9e0eacc7343875626c54fca0c47a879c8dcdc84f0b4fab79e4b08c41368b3b05b54cf22c44a8451635eee673f84090a45fb63f4130e34c53cd3a11cfcdba13fecfc3bb4a881b4e3510e54d3c8eb5c9a1cfc21a3303370176d2e35c0cc98af40705eed4e77fa7b1fb7ad4a1e34500410634593ffe218df7b16a4064bf0bd9658a9be82a7be50964e69a5ca01cdd70bc0e7b03cf03963f454f8bf4475f83a4eff501c23fc117c7cb748aa6997d90346ba8b73d2d316fcd322da2a4c57786324d46a17586bf6ebe2b219007f67652e564ea16d421d8277b5ceafabadec631391cde9ed226e959f55ba656e2cbd4518b72e7d2457bc49c3b99071527bb8c37df3b724ad3a47531c8caba7da5f9fe23ded22bbfee15da3ef020cb871100a675764ac623d0941d55a15cb6be848d216df36fc584b7ea2adc52b983950f313e17ad634f80e9ecbc1c8881a3072f169f7154c0281866db84de12d1cc21e93755ba388cc9afa64dbb8fd4e68d328107c15780dde685225f81bb6b76599ee81e33663be222488d4fe6b8e0f3bde4a72b9ec5b49f3f5e43ccf9b09301438a87e4bccf3f87bd79098a4d44f34b63138ece254c7242ef96983488958636941d06176f092b9baa1f36037464f059a458a74d174329e0c8ab13def5175d784b0ef74d2990b2431967fe3899e111c4661192753e61a48b9f611368ad543d3729d1bd2ae7a97e3e4733b7d08ef3b4123fbf5a11b4bd67006fa52267809008d1b44cd81e860a208796e136215f532c4c929de117c0029f117dd40cca06a5d653b8f3692b368bfc21c05133acf9ef1b727c1e5b29711d93f4d407df597fcb1d4dc5536433f758821ad311635ee78386bdc50ed8859da9502ef8596e423d3fcb4174749fff07ba987d2b6892a509bcfe72fc1f051ecafa1a40f5ef54bd7343f2ce67759955ee8837f5262b13a1af4a3172ea62dbb192978a7cc9f490578e2aa0253b772f338b206ed5478f5b953a220716213ffaef3c62b3f16e4789225650b5038f9836b0deccfe550785ea13f8242631c75aa563abf2807c14322bb48093c90364cdd8bd360e27c3d18568b406237181366363dc533258fcdb3114a49eced5e027959160929245ad2ff09c9451211920b235169d9ca41b1d0c3fe5ca0ee65113de6a1739a2d4804789fa311976e994709f4de47ad734181ef9f1e396deaeb36e6f59726f6d6bd7e093ac87f50b7d5481f067330fe9ff8e35849b91346f08c7338ca6b9a9641a8eb292cf262fb541634fdec2fc8b61927fb6c64adc25dc5ef47619ecf62b4e53d229e5b031a6fc140aaedc30f4f798082ff50d1c814882c67294ccf9be749d6fabfbb1f7e1d851441fc4502ea68b9e15a1cbb20ccb96d8ccea15292aeaa310dbb36f6d61017be813ba9836798336051cadfc8d6a19701e2c0db5753b94c309795a8a5df9976b9f67a8c26241d4ab49dfe4a066475f850bc152c12df789ce7a6e9c5205ad6e9d47b432e4d244a096f4f830297c17843db9bd26b0ae6e1033081c6385f7f7c4fc301c2177f8791eae3706e42ff40ef55235ce64704aafd0229216d6c566d821422d8a95da12d63c25aca6810e2fc3ba03ff9d07190a07c9b5c640c61c4ac594c83ea56323fcd6d3f60d133472c664b2b1c070a36676b47b5f866929d897561abe30693500ee166f2698360fef26e3ac06ed7802fd4a95916082ffdad8f2d909b36d08c43f6eec8359d9937514356dd07ecb620a42082d41201aeb68ef9a66cd5b0f3f97539767e373f4bf8db24f63780405f139e01e9ebbc8af084a5a1ee00b92a479f93eaedda1d5cd0da183a24ff5c0abb3f760a014272ddeb392ff2db205d5c4fa6a8229a14cd79eeac0b1cd029508243d8d85a982d8dee50b924b3cfb540a86af943a7af8fda2b019ade3bcba47aa967fce926e0a51b414daf52938e3860206478499bb3f3484baf73e8718a57b10dc21c6b9a2b139ad496aa1653355b7d2f554b5c2f063e1e615409688909c6bb918fdeecdcc3980ffc614198d04dae94c06a6ef498acd86883a811f8994916023f9e225952bccfca354015198cca553b440445d216b41bafaae4d4c52fcf6a9bb26d4f1a91cfb49d4c94ebbe5f6879ce5bafe42e7ddc142960610ea7c832b78eb380d7e4216cb1b4615a15b9b31c07494416d47e2fb02d6318018b00a121120feb7d09f190c9117c7033cae0b782906d6cb0e4687c817a08423c5e6a8b37748574be635d2e7a3c9af265a43b946f1aa28fbc9967f4336bc1f226e273d73444ea25baf3953","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
