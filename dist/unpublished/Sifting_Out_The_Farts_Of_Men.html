<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"331ad940c18adaee8018f7ae9f6c4d8865d42afb2140e6a59446ec567dac2f34833debea2798dcddb2ac49425ecd47ea8853340c9bc74d3ed08f1dd048244e1c6ca0647a6a02706105ca118087c7476786b585c5a24e45f517a4154eda01e821413b9f4a45e84f3edc1cc78e92bf09e6ae32b924dfa6bc51396325b8d02d5310288bbd7e1e276430f366759eee19cc68c8ee16acb499beff8b72593e542939e79f8e2918025315cb4efa5013c2df4c060eca5858ef6181a43fca22b12ec63fa73bdf120f2945c2c49c5c66735cf2669051a402e8161f708afadd16a338d706bcdfa843dbed5c1beb659ed85047ee12ed4fceb6c1a657fe66222a0c103dc52054ad58f7d028f318a17179ad6afb708de83dc469be60b8afc83b608bc269d89b9925b875795a7261dbbabc5e8537064a5b1cc22233abd24427a772ab050f70559f7a83f23f6e8c63bca829fa94c0ce02773852ad4855be94be7f4ad63651d349f506211717ed49bbb2fa5ea399a541ede4aa5916bb4a2ff4928445df4e582568cb57c09d4f03a9173dbeb0b8af6e0f414de54ae6e2fd168392d30d8f0ec993cd6d91178cf847b5ea19344d5b8b2de4a5f58d5b701177eb1307845895e5bd800f33ee4845de9128516d29c4de621729e31211c4e7b7bc8557c13529d35f0f079abf6e4d6a7419708c573f0ed013978efe389ac1bc5056e31611667691ef61cc90f8e9bd466b0ec663730344e6d99d712668f06f8323f8e8fd9c271f6e5bc011cc2eb60f93dcbe3c2a5ec3a8aaad37b9cc1e39db7c07415fbc2662c706f92377aa170273ce605f61757a44e48995ffedcb7c2f776e34001988950943d47752e08a390d6cf00486f3ac3ad2b4a42e3f87cdbe0f932b77150a246a2d2a94fcbbbeee0622c83a2317af859fe603304ed7de78c4f21778b4598563ab4d5bcb15a528ff9fa866f1265217fa7496481e2c409296a14f0f27524adf528bbe1674e209464c77d5aa16780ef8269b578a248181afed9352881cc03327bb65ba88d5483dcc9f27a2646bdb2864ed09850624be53c725e1750f013c799a464ab9099bcffdc939b15e327299f4b9c35a0a724f0bd3d178cfd80e331d3a97376a394af9da7ea6496e7939a87a5ca30a4a56eadc10bac352b31935acf440b8b396680c64ad22851dba751deb708a26441000c12a5e040dfb87898c8493222ba0d0e976e5caa04820ecd8242b2193a5fef74b3c412aa8b1eec80b98156ed59ec2e44b633e9cc0ae40c17866c605bf3d98106bd177b0275d09e616d7b924e875ddb398f849ea56f96bf9211910636979d155aa88b0705a2681478b8802a188394f14de375b8b43b802b716cd5c1ed6132d506204d72e210107607a88fa0f87555285a6526e11154d9566a90097e92b9aff723a9e1e9139b277bd5ed33cf699be334cb9a6c6e0e56ca97076192be414344745fffb292978be5fde004b9ba2354b4bf92b88a0e027f8bae05860d7a41c96da3c9f973586bd94dda4d64488c104e24ddd9860a325b6849b8d169fddd5310390e80ace111bf88fd6fc04b7f89227531906217906b337a1dcc6e761dea855e1004c6bb23f869587433a8b0144ab47d8c50c07af28ce26481d41d80bb69b43e9f9411e7968e5ae021b1a2c9268a89f1e8273b82d692006db22cc2d7cc350be3b5769c879d77ada79108446915b24adf116c61d2a935ec8430e99c6bd8abf5fb1a5162169f2e2537ac1f6068807ffd0273b6c0714799ab82700ce725ab508c3d2beec9c1add67fe3a0fe8ac9b9f6778ee5569e376ed85099e4aee530fdb2d7bfff9db00f81a95544571b6dbd003e6e91f4f3163da5351cd677f72d9ed088290950cc60dbf79917add893f2e503ecdf4aae02275f047d443227fd19995c5b9b6d1b550e96a2117ef72a0cc1455260929527ff8434b01f16537b04635fc755dd6e0c11b228507cf22e1cdd5d6db838ab78e9c694ce5b36242bed612a746a8e05c8070ff2765095bb7fa30c0829a549380ee94a28063b7b98685c6ac510ec940213ab74a4e0b50358b8773777a425059df0e0261825da63f2e8ac66d96c25df208893177a30a715fe7f90db247135a0d93fe5c54bfa797aeec314eb6aa74051d828b89bcc9facfcb80bdb6715dda251169628fedd099f2ff783dc08b228e5005a14ae7196a3a73029ff14024dde8e7512de16e69b21528d72448532aff48c03eed57e047ba802bd3b9c24abf466b7ab762a7b4500b4fe0a8c15c5796f6d9dd381a597d889b6c14bf424b075f9c7528d0e794f25b7d01a4f0ec8ba3c8969eed9213a8f443f0b1be87775d616673b99acf30bc3d8c2942d7ed29c59a31cc07610a0f7ff6291a3ffbc6558f91fec5bee22d0768e439707c9bb9083979c72803754b8b0a7d35dad0d801ed5b75fe755d67a35453020534feb7a7153f22c4e2811f0514a7ced48f4b5208b0f99b3a43f8dad01c1e3645715f57888af57597284e16baf5cf242bf010523e1d2e982012f4a4b3b5a6743e310d0f8486c9f05af3c2a8e049f1369e900ff49498b1c4e2e2bd1d5de6e13c54237403eaca187b66ed69cbbbc0835d4f8313dbaa0f9cabf0a032a271559ede405496f4b795b492bce4249cff71a91971a241a75a565125d38b81bdac384ca366e364b8557bf850df4a75fbcb139596d11089117cfb022fb6e554c75b59f4af9e3699385dd4411a2382406fb7d7896190daca3a7462069e1fb56d55de3f9b9b938517fdd01ccda19287d182f8e998c4db0268d11408bf6db2c5ae3d03422682fafa3e07791ebd20c27bb6f910c308c9605564450e1ed2a8835ff19f095981e9bb0cd68fdd1707e4370e121330f60828866f9e78770c94b71ea84c457c3f39a6232d353814a2080cf19fae73ba5312993926f41bb695011734d9fd5cb2b587c5091e5dbd8616a717574bec70da504784cb548183acce2f77716dde26d8e9a4b9288e867cd6412483effa670943f929aa12797bd450c7544be09d94a67bd0387b9f3a960896fce71fa993d6fc5d158ba3609e5d1bb10a735ed0eab38798c24bf65d7d173ac42447cf62ee7b5601c365bad35c6189fb6385680db616d0195891605ed84e4c1c78652e9d3771fe521304afb73dbf57b25e09b4f32759388ef8106a49c50d4396304579d9cfafb811dc0290e26f269315c6a0aee1ad01ad3a48a2e5d4f18cdd4bab9dcc86f8092a0aa6ae889a7d69548200858ffc78ea6991e852573b123f69f83fa1e670e7b3093a23da8378d7aac7797614b957b79630fcde25e03291ab91b129b4e4b5c3dd18e03a624e6a8866e1f3824448274e8c8ee478bfe4b00ed4d4dd5e081cdfa3bec32ac05fcc894ec052eae966e5dc60ec91a4409cafc41812cb80b52415bbbb8da73b2a8c3bc3093a7415f85f7bb62b3ea43c9463b253d4a5b0ded7e3eecc9ec2bdffc59d9bd33f2c09e65f2ef30a2bf9c311baf72ff7065cf81c757bdcf228cda3d9ae769d6182293897add943f2d6a084015349bef68ffc4288d27c42c9b69646c2fc707b4e9956551e40aab21d827ea7c3fe76c08b5a18cd9faba172234e93c02d496d36c2fc0622f27614774476a8510938c612f65899d4ee514138b9d83705a30118b571416d87f7ae58438b1ae943831965e617e2e26f8e52efeb751ce33347515b795e543444f0ad9097ab1aa12d32cdeb92e43c8cf0b340c4dca5332fdfc60b330ef4a8a93b83270d163ed2603fc39d7265c54ae765324e2412a973a44f10b02e8952a21c5a12205dae522c74c19cae3126f43019037f4c2f66a475c957370529510addc4ad9b3ba8bfd0237fca005d443d07db71a135b093e4dae38ead0e54be1d959d85dab4d82b7975e171d923b362efc968de1add345062ce50ada11cfb0fc98119830d3dbd4fba51d35c763382690804c727eee8cf348924fca3800aad6340ad62b8322ab544d06ef606c17f375fbe4892c644a30ee331b9ab9a7955439277a86e27ac3f5f5ec7cac948005cfd7ab913b2e03a5104a56dbbd5e27d522de614fcdce85cf48ccec7f21ef181ac89fbc80bdcb49f32b3140922b6e76871686db09d51c1070da0f88a4370e481b7e2456461f8199367ce1f8b60c679eb45e7a321a935720740f5a8fb2bdb8a25e3205fb86aeac5e9ba37a2da45226f0ad2164402adc0a55c2f23b465a0400c81843ba80155e5dfe842be3b27910adb2fca7d60d310684cd276b34ed8b49021251624f3c4757def8f30b0b7d7403f0adc28fa8187fd57cead83a5f1881c6e0851c6b3f23a224b91978d4755634e67e49a37297dca22e6512a60bda2487c796e9ba88ea164da99cfc5517852549679716b2534b2f6954255132c5ca8137ca019010c5a2ce405306c762ed43ef4e5f19366171454ff204dce7938423ccac2324063247f22455b9d858d7fccb43dc397161f846c1efa47bbfdd6eea561ddd50299bbac572eef3212534a014228afde77188f407a9e50fd4dff05843da811d88d9717c35b3c3050bc75c75a84e780a93bdc0b86467307f3c05e9aaf76c1e8ca22f3390f7dc8fac887905e5abd91fbc302feb320915105d3c3486d8aff56353b4a1fc075316a1b1e8a5c855dca6dc268803b80754dfc60c3e5fa26bad128264092f36ba97f7330166cdce1f030a761613ecb3d9896242ee6231538da14346946b2e7221820385b71a9cee98c7c14f020948503512391741b1aa12defda2fa7f031a7beeb66ee7c139ac7d14e50b519a7b1732e156a7f9e1f99a16f85057f2d9db9e72784dbc47d5ff0bc044bd3cf54ad36e541299eb60bb3e5c81b10d9d2e04f553479a07ce14f3d8b06cd5e1e3e54bbd0fb5ae62e982d052147eac25a745b7bb7c27766844a7e899f3e02aca8a0ad1da54da7f2a9aadc5c83a20334433ef49a3a67742c13978c54de6621a408fbf9644a7dc710c82e212bd9fa960946b784d57bdeb9cbb12c81232c997cc44c91db325ed36578ae57e211deaa151e7def5394f42cafac2ac02697c7729636778c93ff4815784c811459319245113d93c4153f79fc79e5fad46d23ea08069cfb3700bf82ad43c540f8287a7457c2d53090f67edffd7e52f5cbacf07158fc9ae498502e252353e31c1e7e0c42503622c561e0d553be08e23f136c6fc566be251731541dc5a4549764b3b8a97600095498d42da184695a9274fd18d2c0a5350dcfe79e1a30d573f8aaa1f2c70f179fdbef6c93efd8dfdb2dc62d332517fe089f2bf698801f8630394cbc2f69336505b28f132f8b6d75249c035da18fd1a0a0ec93cba1d301205e04cbfaa339d2cc133f63a578e41495788ece477b3a8e8945a170e3531bcc7a287f3b5041617ee4faf3f3702830add6fa54b6b6ff05d1e8c10eafabcf33952463cb062f0b3b5fec38ca2ffe59ae20126f926e6860c3b48d8e4524ed1f71e8aeb3a12a1986fce4191af780a5426cbad41962b19392ae46d15cef96d5c23ecbceff411c909f2ee7384c7c3b569e7f98aab92edff9f8ba75447e0a83486d6680779d111a25c5836ac50f9883fe29191c9cc1817ce5edee4d8bb15fcf7414a930126af1b2e0353e248738014b79a1f47c3138551fc201f6ee10ad1ac58130b4a47c44c5e38ae085f6cf7e4634e42ad7d6b51ee47ceeae172cb17e848957b281f95d5716aa7540c2f95813e196455068c5d391f429d9a03c128d4dc4f3a0c7313907386a771af02535616a63ded19536daef5ecc65058e3399614237d84a2642f94de7123ba142be630f33ff8553c392fc90361565858904a7bfeb25470d2b6e5d9e9d014da659e08f84469de525ae2fb43d74a14ed114c05bc91abf6d5e1b1d0de17acb0635944411931ff20d2afdd1b1a557a5851faf6273c4cf794e50d588e0cb50a2c0f7de463510e51587f3802d7465f04768aee326dc7a902255f365c389acaeacbffe75d1be1bddd2bb5194c362cf7fccfb204eaa68effb5672cc5f64c72e8962664d8fdc12c7d8664ccf674aed920c0bad87d84fdb1350787ebc152306462acb69053a9aa83a862553905c899f9641151e50c32bc7b3ce983dc9a10fedf64e58e76958d4897ad2b049aae7ec16c477aa3d4a14ec4a27b9ae18ee3b4dc5d7b965d0da4736708eb700a0999cbfd6f7200e0dfb35a9f2386c479f6da46eb87f8c1908fb7a27673bfb299d8c6ae1f63280376a302f241c64fdcd89eb07fe92d487b2d2231a4e28818f054770c20d55ea3399f5d615f15521eb8ae45444bed9042dd702fc56dcb525c16964c44312390b0a8ec83419426dbeb5f69e0ff624fc0e6e84471e86dc921ef1d0b355e384ba0eb64fea5fe229cda7ffd06595e97b7b88811e59377c4b678e57988e4a8e940312b41ba74d35d3d806aa394ed90e5a5d6e2742c0be87edeac70c1e924c42e0db59edcc59af8a09c7c88482488a0c4c2421ded2ba9622d325c6d1fc8a9e213a07ef8047538f0343e248eeb11fa226c49b42f1651e2712bbe1c6e14b02a4283937139c856fac0aff1f712fda40b7e3f8e8c16ad8767b2f24019586622ce8be57352470819fdd97d7b240e23e748f00b679f6c4d742b2dd6e8af71a6561222e72bac8f4e145979b4c8bfbaab184ded7f9900cf1c9742243c0568c33431ac10a72b3d82063c3703e7a0564526b47eb22e4fd1386790297e64d0d59364376ebce4e6675c42fff1861b8e6df2ac54e818fe56d75e8f8ab0772682795dee44f6910868da715aefa3deccb7e791a53c761bf1976f869740a56cdeb88ccaa1565eeffd1898e9f5bb66c64ee5d312fe817738384be5e8360e664e59a72416e65b3e4209d5b28cd452c4d1b65faf2ddc310aa5534abc3c09527bb334cb10d503dd9552e673e690fedf288da4c76935eca877e1276c135974b01b2a11079c12337185c0544a68ac88801251d1d32c74c94bbb96954347f6bd2cbc6632d7bb95fa675150fe2f52b182ff2c8fe91ae6be361116dff5f7e7b32b3b89c05cd9d7a554ef40a6bc5a23eb6499a8a03322c77e805b9228e2e5f3bf0a7a5843804cc819599ef70220946536edfae8c2aec392b1b97350b7cfc395194aee2f9024cf8e5f70069ff934f48032c8128e86d518524058dcb9631675571c5fd0dd8fc281cd3f7b51e7ad4cb6d67c3169f1bc3602a416a3b5c4ef0f739b0f1a3aaa2df249f55987217bbd69bfe67ae72ae2c092913fd79eeafb6ea4c3225a370b11e9fce898a2dd62246e701cfa2172bf19f4aa9745dcac28ef453b7d87b511326e3f7348935c235841ae2720ff399dc6f57931f9b33101ce5be9872c5a9e76ecd5d4df438d19de87cdfb812c6caf7ecac6845291a89271b6621d3971143267a2cc9e33d8bec6b8c2318b9eb514dda584172b2f93aaf5c9f0a075e3f02344d11cb729ec28c40f67ab1f44c6408c29aad89fc822d723aeed19b44a59e66f76775f4289099a4ad0f719f1f2eeb1b22d06c184b421e608c3b3e679cbfe54bfe5c7d3cbcf309abf8cf0d594e5e717be7ca13ab1f05eeffb5625903cf19b4b84a625498964d7b4166d0760e28700d00e13fb589dee08ed3752e080ab527ae9766f749c097f0f83a69e16bd5c06e4e5e2b958573d5deee6c6193bfc6660e2702c227d0aea601da0091d0b099d7779163e8307d178fc32e7a3c4f5f2059522a80f88da999fbb655ea346161c5f8e71b586975f61689436e011fff95ed7f9b4d3083b449d14400709dff7ab06d9d7aaed8b3f92e02634547c4de8fa23626e6a6b99934ab711ab587f2e5a8b74b8777b48337ae2fd540418464860ffb99e1dd33747d8a717fcdfa16bcacf69adaf84aed9eba5c849a2eb088d94cf1211e7207d665591005c10154517545a345b850cfb8762f7535a8b536978c70d82747cd985c5047a3a9ffa46ef8f15e4ab786574d3e840810714e4efc3e699786540312425c23f88c9e7a6cd7adeabb73353d63d8b539778110512f76fc054b7b7ff2d66cb3ddb951285449cbc3b135f35fcc678dab442ff4196860aa906ed55d965157466d685e7d076ecd9153fbab82204a6fdd12d6675351fd4202192d1cc181ba2bcf15997196c7bc7b7a97f36089c065c6b56883045546e385bf497ec96f9b13e626f4fa1a1be04b46d8ed081ab78df2037516af9f905d6ecbf76db75f1f31163bc90b4ae83f6b98a715d3862ca231ffc7b8792bfcd6a9e2a0bfd16155a0b3e57050344d8795109144a831b0aa665d15848e130a3f46e2103da7953d3421a416a5c1b9abb8f036f665e43d4fae8b82f647d63764adb9c2424d9917dc0e5d812cc2f6b6d95cd8566d6c7d8390997ef73c6fbf5c8a243a984929f258b5662340438f0d93a798e81a4bda9dbb2bcb6bb4e1355d571b1e09aeae4d9ac6c19aaa2c7982f125ac909ec50b8960c6da4e48716c3cb9b9f580e43ccd1868a65587e14e91be5e7690ea235e6df2cb7fb25b8929eb910c671584abe6fb6ff8d3a2b47e5a5a4533e5340d2171f7dc396fa6b6943f33e3557d27ff3d1575aab5a4ec0a33670395f78ecff969584238902b1518045b30de286be84228c94ca637df210a8983e853f023637f7319fd83455e849d4f6b6e71e63325741e3c683117c9b1e929635b39ff34a0dc4b5de28a059ac5a2062edf37531af7dc943f463cb213d54d72ea6bdb3fbdc03754552434d20ba5ea13b92c4bc68e35e544f4c2c04fc162a30b8f8c73b60760465968239d7f00886639b670306748c089017a621bbebdb2192d66b3ce8a8b4c00045aa96e5d2718855dea3dcf232392bea27d271f28b963634277b29b1406535b9bb601d10a9bdeafd7422a48b70ffe86e75be39c080d6c15b3032fbd52dd348d5cb287fd76f31ed6bc9491f479b2da9eade66166f04e7edc4cd1a9042770c161257ffcb0fec57be58a5be2fd8979314bed64d41b9a3fd3ccee605aecac54a4091600b61d2f8e996c9c1a54b3e2e6c81b0c22036c3a7aebc8fd14ea60895171891078c6c7ac64292681666ea21fbe397a5262a9e970235da0a97f64382040f5837f906d5045902a5d8da5c96055ac8dadd9329e1c663b7ee0a3cededb3dbc0c698e3e7ef09d9d07d9ed7d4f6931e6857ae2e5383a75f6f4eb3aaeb2c33cafbf1a8b71a7a360dbf21a45b35af5269038f27c9231ad141808199257c064fa5e2f82802e1673f5b097fedab08da2f186988b3d61d458229721e3c71da124a5130122924b9bbfb57c6d56842873263f59f8cd4883dd5705cb1f9242dcfa8650baf07364a9e57415fe6d6145cd5934c1bc62b042074ce802446e8bb308476a827058dc38cc94694be810647e763df5f86e31b62da4a38a1d2a8f1bbcbc3bc4720ff8f63444d202b302f3fb321aa9842af5ede98ab9488ce089a20d5a66a314b026cb3de8a89a7aef4ed1b6a08261037b905f68db96197a037b3689ffbc262314d1319e7b0cfceabb9786a2d1aaad36c20d09442a0f992883103fbadb8a429c747526ec9df5534ac8d2b472ee59eeef755f0691a75aa1fb5a633c9ce536af3ae691f11d243b0c480f4e3b4002be32b53ef323f94af2c4b6c8bff59a39c12a977b36f3347438609f9d64700a0586c45484bb74a592079dc2de87750b64f4b2615c65558571ed0dc84b37769c975f36b6f3d75810a275f2cadc039d86785011c9ccdf08c5b219327a5aa799bbaafb1c37779517cda6e983db028125dd8c10bcf781a424e00ba0916ceb5e016b222492aa8c93fe138e3b81efcc09fce40b91ddeb485c14f1c00c2cf32bea2425e6b691aff7233df080c351395569be658bbd15c6e27541583ce137b0ecbc95f9b744a349b5fe208576c9e5aeb374eb4db1abe80f90ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
