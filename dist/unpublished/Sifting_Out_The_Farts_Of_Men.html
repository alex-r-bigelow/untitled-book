<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce4028d77a2a15e9faa3285ce6610e3e241b9c949af982527be9d76814cd23947c724f887006d76abfd5c3d6b11344ece90fe66bba022fddb72076b0ac8f8a76e274f8d80851d91c48c1725b61e118293111f6d5fe843a987bb246568308915c82611b99223e5f6c451747e88889c62178612db4fc64fe7ea70e156f39d50edb36d07338cc009dce9cf27f4e6dca7530548be3409ccf9e396a360c4ff14e9f81f9569d5d4cdf85a1f383b146c28f4cff772b916d5b40c53d041565d9d83190dfaa0f3917acf1ab031ca44ad348bbe584f71944950f2219313889b53ccaeb82aa3855cb2434cb0a4486da1694432e6f6ce56fa6919255bf959ec4c5ebfb47ab7718e8c3af899501b9a0fa74ec8a4953271c9b259b5ea51455130b445e747c1651244f1e63cbc22f67aa2cb57e903071803e127fcb63c7f70e0d8e67d098dc8a861e996efc84dea64045b3272364bcbcd4b1443c0282b6cf3e1b944c9282bd4921fa8393ad278bcce8d0ccfbf0b5b90751e34a514ffecd95132525b25ed60a1f00477cf1e44e239d4d84f36a632ce4c9ae7cb928c7577428dba1cab5fdf827e611ddc7c40ae677418522a53310900f5e655cf0192f20b4eeca581c9b5cab42c3316bc53440ae1e377b42d9a1b390ca558c79b92d65ef0293bc4ca3ceb3509a38601fa055261ce750431315545828b67ba266cac64896a4561ecf0f5b9d7c3758b33da0cde7c3dc6c48f8d63970a083d62df9062cf51d03c1321c7438e6a9d10e7fa57130faa148f84b67e552e1d6f2551d65192e6ec910539a20d23f60914f51098b4fb19c28f732be448d8340a165df3b32e0dc4f55f348cbeb25556345d244ad2a4d6a4965edd13a47a92af9afd0f1bdadf7af271012d758d63d652013dc3f6a2d9717aa648bab6429388bddeeb19fafba3d13d5707620f7400f8ff508dda722502ebadf58b42c729e3109385f3cf94be84af35271986650dbb89961308476d3d97531e7d9779e79965a216cfe279fe61724049031aac154359136133095e7c2b5b965db944ba7c50ed4ee748bfbd2e9706769ae03d52e6ad7f1cb2266cce244c61a0182af685ae34552e90510c5fc68693d8d53fb2a9f2e07fdd73b7508c9a27c4dbe395ab3e5fd589dd9dd311ffcd77e04555c247650563e5a1508f1af294b7be407dd3684415593165194e2b391e0707dcb4fefdc332d8519fb87c7e3f973cdb2a52a2f096a1b440a4aabc6525015d5b338d65325dde784e60f894c22d21a1c2535748655d62b45461828de45d8134e8e14f09eb71cd5eda3a8423e590087e7579406045170e1cef8d4558f95d56e0ba8adcd10293f2e684d9de4d105e4f087bb0964f3df2e1ee239486c180b94ffa49783368bcfeb909fc8b9bf39e09e457726ca8e15c80394f445eb9f10c964e015bcb69d94cdae46f38f10e5b1396f93038636dba10675fdb2f8f0011dbc86979482182e87246fd750b3b2184ad765fcc1a5508be0f3116e1b5d32a60282091bae2235058c798fbfb8d2a5ad45669b6a9906ad93e23740a00c5e360d1f49d8190f933cd4c179edd0c08503d6d2efbd8e1f04fa17ba66a0d6623a9e59660099254e0bfb9d778d9e235501d28ef424f70580f7098a04ecb6af62aa203010a2e98149bbdd82c7c70c6b4cc317e9f20807e64fbfdfdec249ae309c2ba8f156aaddfc1451ac663fcb543f4ce80a22ec1c7ed9f85307d8e445f0d17892501517807dbf50d56c493fa0f36471d57701d343a0ae4bede641fc674da3ce1c2acde2c287495d8a2483d97771080a5daddf63900bbc910c0aa67b90ccb762de5280cc13b788b506b21919ba42506081579922ce519679e7f144fb40415e5ca84ed36fc6842250a2464ce33e24185b4388ab2bfe623c18734c26530564b349cbee83c8d19f24d9771a60f9ee49fc162f73c29892060045b406b1a73ac4dcb5bee2d00744c4f9655c516b21d1558b0c4d3d0c67c1d45e3462d5b69a49a5a4162b77b8e269260a32c79b0810a768e3638ec1b2e2822ef28234ba0fcfa6aff0ead6ea24083322ecba5c6029ca66a75c025918d58eb359c7b461a9c0df5f6ba28c3390cd764c3ff47a297a860da1d5b0d0df075f212a14349463faef340aa4c588edf01864ee105b2622155caea04f5cd530bdf84d2577e992d6b4ee50e7c1901a8c9dda0de29e25bd60ef27f1760d3d80c389ed99cd553fec7daf4636332b98d94f0aa82cefd6ae094f5d203461e2ab7a649c9eb7dcbf0cccb14d32b2d59fa9050ce4182955d1abae41897a1336b6bf64107b277f1d1cb57c63094f569a61c80ce3533021802a69954b0790ce7b15d8ef48ccaab73fc3fbeda74b3cc5e1dab948248a5a2c04e59e68806da15783ed733b1c3ccab59d8dd97c2a7780c050670e9663dfe91ebe2fa40f93cc5ba48c3638e6bddf404356a04338b169115ca4c6e58ae5c987c6326e9a1e91334fc507288b492aee7dc8432178352566d916817e5c80a414a60b56d6bf02a395119d74b2ffd77369bc37cac3d5725a9bedbf8fca259d246aedf3aa234a0ea95dc59c4a0f475805840ac74200dc37771642414b335b3d2c73f7f75d45aa28b3946b908706d2441bcf6b03e5cb6a84f3c5fa8c5ee3f05e269326308232e99115c89257389bdd5730fb923a25c5b28471ac0cd124811e00520f8c502e6f0841078c10dce439f3261b2ca4214b19e7fb3e2ec52eaff9b24c9d56b30b17c583e43aba0a23456060443c1b58ff55b18fc3fca58d42de0bbdda0965cc00251cb86d3575e4165bd9c3ce807bff6490b7ec1547abe53b73008f65a83d52c2d3e451b19ec6c6902bf3d6765e0ebdbe181efded44f41f2c6bba0e7949286330b64d27c802150f5e4a22978e4ccca1ef30e75ba100b6d8f059206bf44ce3f169d0d960e2a15682540734afc4c2b4724ba0ac431d63eba9388ee03ed6f6ed4c2b597c8b75b5ce4da6fd7fc4664eb419cc13337da20e7f6427b38e883028eac77e53387a81044418467246a2c919d8a45352989776e134f908dc72e99b9c539b1cd1df6c99e8ce2d8cc4676a70a3f830210e4390538376107818337230ede8cb67d7abcf415af8b9421d2f14a48f9cfb81ef8d8f836f9f3601404fd61aa87f033f5e92650fbe8a934a7579cfa7e521549100ca3ef631ca210a5cbff524e16d72e93d8c24eecdae52782f29058c542c56ba008fb4c75827f80083fce5c6c6c0c864f1f60ff9ec74947bc617a18ef4b0b9a2f39b85cba531b92681f7e1e7c807449ef521bc668790c164512bd5ce852acff1631d84ab02c5df8485c43a85d3968d83df06fee09d418cfe9dd46cab6fdbf1b9c129d7eafee27dd838daa869999d86a54e05b780189ff71bea83bd772962a02645c560e2d9fa0560f54709e93df428179810a18d9959efda65f68611791f03ac79b7eabfae6b169e41d8a72a3fc9df6ad195beaa0bbe4b2fd2fa4bc97e918e578f17a664010543c3891b8826159824d2d756f60a7243ed844515c4d99d6f8cc376a25fad88ba856deb2f78ccfea2f8f8f94ca5254bca4898f055df82d7e1702c0b3c6c70ab1a53b04184b9c37de304a4bccc435fce63ee6568950a99f5576a9a5024d1cc84a01ffdc11af2ee56b1d35a6a0655107fa7692aeb3724705e83f28421b8c111f2580c309bdfc2d077e3d8e2f772eb6de09d5957d209ad6efedbac08155967b8a64f76fb7a95809384b791b993385ed708f1a65815cb1571bd8190aa56ab156b5f484ff77aa58715f47d5cbbda32dfa5c3595cfc1fd39ee511ddf490958a17ba57340adb91897647e7c41c45f7f358ea317624f66d75672f72a6b4faf371084716ed860ec5d33296b993b7d84a0f05b55642bad498190d874cfaf88171a72c1ad3cb2fb428827220e44dc8a96f5ce3878655d1302a2e472b3f9167c55f308f7f52f38fabd6e7b2fef5d3674c57dfa0875acfe9176f722b6ce4080ab15c7189ad00787f66c7c0611ca94f4594510fc6b96eb0213432d176745f13fb5a375fbfa46319e124371045c7a37af57c0079f0f90de5614e362d5279d648745ff594a4b42fcd2813bcea94e91acd23670e8a3b71353b8e4eaf4da79388e8b934d02a17ef6e823854071caa038321a2d8bf5214a33871fea23890248b6d38056ea166c8ab9cfb28d60c12675183ab06944404d3f32ab3a31aab05ce40d5513117a58e217bf859be733cba58f4e728a4aa3bdfb308b1ae28a187e4215b13e7f51f4ad12a0c9d641d12e49ab7d58941cba4ed679c267602058bec1456c8ca1d1baaddd3220b8cf967487d61ff0a95a25be879aba9f2aec2b5b869c44f22fab4a0edb5fcd7b0c3eae1241300b9d9c5957b3d0ec9fdee7e9a6f55b02c83f9c67245294e52124f961c946e7c16ac0ec812126a4aa394f46473718d34d23e20144fbc750befb3cc5bf91dd2c9a69278063bf5b81be43dacce3c7d9ce7fc58939ece7c65aada6c70f484a4e67a8a91e9365b53ccba8278b275396d0aa225f38fd2786bb5afb8736b340754b6d09aa1bd7f1b717ada4a4bf7e932c478a97c08fa58682ab736467fe6bd3638f00530cdea450b33a5498ac14dbac3a09267b8f436d3270ae6a87470c3ac7a1c73e2c2352b7d90f64bc8db66f1dbf246c2f493395b2ba2d22a9a35753510050356395e6d69ae582593131e958e38ba74bf103540879add1a7145f75fa25f98043d506292026fc42187b82d8385a749e2cf77c996c1101633b31b93176ba2b41dd76994bb89a6294a70f2788a6246da041e5e105c058cb221f45f67e5ebe7a4e19dba2b8a24fd8dd0aa45a600c2261d534cb482a5bc5a5006a9661cccdf850a4e057517a03c9203287746cc1dd7cffc0ab507553b9c6bda17417d7e150ec145c8d42dfb338939a633f66192b4c2581c47686cb99bdcfb58923f61de39a4a6930814f67f7d64877a0e3f28913321dea108b7ff6abe77ee6675e6323bd7a57f7a0eb4d84d08bae34370221976b5ee676f0ce1ae4c5c8b7d04905434aa01ff154e46ad0f978e53f95ea75a1465c84a7efe16316dad21b1906a028db950274b46095433ae1990bd0ba6dd504a101110be7aed86f001f2e2fda018acd4851d1f41232b5664e0abc401f622fe694d669b1297436ca6f179af14e28f165a8efe730f27751064dbf24a93bec2e1c713a91b11b9c15a3fc4e452f82365f3cbbb59c089da8b8218f32c1146f90dc45baae1197c8392dbce16c071ad9ba5703a10f3637cbdb15168d49d624597aecc880b0b6ea3d4467a327420b1a33a2c19482d54221ae5376fd6f7991b80022289de47f4825e5834dff1df7aacf505cac00ef3ce479ac773dc44cba8c95cf472130ea964bccbf652a6403e565313b14804912c1547c54c75057bb38eb156cb3cac49a7cb32f52cbc7cb17e00e3799589499285040e84b2a3e92b0742240b6b6276db8ee90894c603dba60f25fd9b549384521dc29aa2533a75e73bcb18d55a66ffa8d53a4410599ff0b3c1f811b36d3a1bc033b7edb972437fd61aca89a298af6b3fd6a0448f65bfde3bc1ce9e94ddce99ff60bfcc19a5d18ba86cde12d4833ebe8fb87556fdead6527d529337253a0410d5200034c6e679a6c69609e94d9d3965c41998c69042b8863632caf0627543774961070fe5cf02f9bdce1b2c59c024950856ca8cdc1ff9fe55d192fa39ac91b6b882ccf1de49094a6670a932b4e5aa0f1c1f242423fab38d63f437344f38a49d41c81b782dbd91d04886194149dfa538ccb2bc8a63fa4304bb748e22c134e121fb1f5e692fdbcebfb44d8fcd6b5154ce928387db622b2964e8891e250128696594dce7fe642341c18d07bee548bb10edad27099f59090ba8a52f71b8ef58880830668e99d1330c234f0d2fd9d2ab19a1d755dfbe982e2899f1e3c6487efc69608f6eef7c81b2d8386b414c1f204599821688f5b8dfb35dfa2ead60cbebd3ff25a3e9d7af5a01ae40bac3c3d5176c745f7331d37631494d159eebf78aa11b8a0e948ec342b221ccfe3a102b9b9a821a933100cbd8809606426c8e24fb5dce73475e8938b0922b2fc7434a30df473b3284fa94054b0ba73d55358f55afce67c739abdd3552b015366e8b67dac2399bb86c83033f1fd21752838e0499db417a2dda397ce85e87e76d578110ca13f409843f9f3992f1e663ee00fff025a58263856008f9716d8da6f0e10040fc4fe6d4fed44a3773821769efdfec7225dbddadd94a5370d2f73540f44a8b3589014d74d5ec65e94b98e1966fe95c44ced2f49d5ab443dca426ebfd17037f34acb164e0b3ec2dde9a588b3f4ed6720e7638a7d5a90785e1c5fd293dce090d39032a26cf5e0da6faa354245e257ff19560449e2dfca78294bb59b47bc05c50dd7a8b793013ead7d9aea1722d184604ca7fb3a2a11b5d2e8f68e45ca3b14c18ae867fcf422aceede0a6cd13e084cbf4dad4ac17e5444623997e8d09cfc2efe9b4781afb3ca8873f1809cd41f3ddd5db51663bac34eb5f61120ac96612b1d1a60ae06b649bd6b299489b8db86d4a0c705f3a68ac5eeed3965b92b7c09afbbc72c17e3e125a056e44fda634f764602e1fb2114e33a3c328eb875dae54102bd81de5d0078382b3e8788e13e9fd5c11ee8e617c0c7e26704fdb4f1e253d29e51d29b782731b6be87ed8ab544d87d7cff1714ed02fb1520a988ed32b5368639272e6daf33b8b9dd6016aadae82c0c459dd7289c1bade00c242d115c65b9c949af73df873a64a1072a9096b123779a6268089696c4383e23cf6ce12d3b45e50bcd4e8c52462b177d5f2fd6cbc0feae9b49bf367312330ecd44027b3437b819ea9b39df9c3cfd7bbdbf6fd4a893f44a9d5e3193cbad50c73677478e91b5e058dd6b4fbd70eae6539744cee3913cc58028377b1f22775046f6085ba2b8c4ed0c036408614d8bb7fece672aa2ae1dc5c0378a2a31fbfa9a244d6875689ac7c72574c2ceda06ad84e6350960e3f59905b93f7b9c745892b102e21992c1362b130632266b4ce027613d14ccbd3377404ab6ffbc959f9937dfa9e24bcb07d166ae2831710b954ba7e41dc43d9dcc2b66350a4f2d5ddb4e7f9fa94d7aac0b85e35428ac9bbfd9239ec682afb1b835a2f6be96889620a07e043deb4de67a6595a8412c845db3025f00328b545e6545df81d33fc411a900c6852ff6c65fac250f06b257586a32243afd6dc42b652aaf028ac1f2f129e6bda245056c22d895e1f019c4dda957965e10bcd491374a39097d5ec793bf3bca3fef498b31e40a1ea3646ddca187d12b49b36b8150a8783debc78149e30cac4b7ef6c137a852db3a6c6e704a384e8fc1da087f7ad4b133bfdf7fa95d40e17c089bd8fec1a2667ad5951ac39c487a9c93ec03fd285b82619a7b11774e771c07115b3237efa782e7b7a98c37bb751712dc85ac86eb98d4d4254d630b06e1797994e1c25cd4d420475b84bf6832fa1750cfbaffed89651f820dbd4af47c0de7cc3afc57ef647808b850eab6ab7888247a32b2496d31e5dde2da99d6dbe5800fe21ebb522866b054ca790620bf3afa698b7b6c998f56991deda56cf59ad544340155b85a8b60f154f94aaf8307b5e3108941ec9129b7cc876da7972c68b4374c5a886dd834b4634d8a9aa6189ca42f99d28fafba3c2b6c61d35c92132aa5308adc4578402f4e75e750b92a5baba2c116df2349ce64fec5ff42d60337f8349cd72e0c08ca97af4afcd5e808c90f17c27fe167261805cd8d57f54370f85f86ea912ddb25f98fe4d3353e62576e6ce62294fb4dd81797254007d0842d4b7c4e8a9f36f194a48a667c73cb35a4bcf67f71273526321a3db0d0b63ae752688880d220189d7086f2eb90500dce9c44aa41e9fcb3098febd99ac018054c9d8207281fc0647511e2e06bf09dfc4d3a631b9ad4ce5adf7029cb2bfcdd8de9ee882c08f86fed608f098c5a8b38f5b9c348d1aaa61c095d6f9aaf6c8745cbc12d5bf35276d777c1d044e8d49fe190407ae327d3911e1cf1cfce9d183227bf81809097e32f2ff7abbf635b348fbfe4dfa0212389347558d935df40d4d3aa7466a3398c8195229aa962fddf2301ded1257747091559c7973e0a1725035b24a94641a30e8441b2a08c987423d289574d9d659534b7994c3b09de68dac0e15564f0dc62e6d2fb32810b15902f9e9453a4c7f39f6458bad2c12ef7fb41c8ca1467b3ee119548d30318c1cd47ad90ef708081a056fad508ae9898a438b61fca8f9d5cf3365f501ad31d978e0c964ecd86349591ac2e00baea02b628734e8d27fc33a1fdafe4bb683ce3fd75c637970f7ba28f69740ab8f8d8017a6544c567e1cda1a58d711c1d09f2e1d4170d1300f70f34ec044233b217858326c2929b068fdf3ffb08d55bd67e1f9d211871af05914a7b9c66668670fce02357b6313be800c12ff01c38c0cd9d443db07ffd6c83b3e5bcb11e6534d918fd891ca30bc65b509b11de5db2f807a3905c893a0ecd260e0a2042d8a07e493eba46d8954258f1422fde905548567317093a7ba014b0d84ca70022f30ac412a6e450bbec3778b4f9486d3852e5deabedadf21ca81a245da565a230621a439d3b6d0f2dc616226176cc41421d615e3f382850a74bd97923ea14b5f5a18f7edc8aadcb07f61e06b8077bed8a8bede60d5a1cb9cf04fb77ec8fc488363478595652e2a1bcf8b378866bac6ad968cbf51568cd53289534f26c365aae62ba2006016bd585cf7a7b4dc6ea5b9f31a6856192aa2be4ba749ffb38ad838cce74c27a3a0e7601c8d030f10d0454ca608725a7c57e4313a662fda114f54bde8906ce38b3e6e45c746a52f603e4915cc051bc79de615cd5214a6f535e873509a6f37f9f707b3289241050fd60ff02b36a7ca045620159917143abef0e6b083adb8bfc1878a572289b0469b7f7cbb16239e21e5b36899a6721e6c7ab8b2843576feb7bb4e0d40611e0152f10bcbb239fa942df7a7a88ea8583d0ce24ce7c7686dea13d90e7ddd33f69205da89ba0824f3a643874101cff079d1396d54e5f2efb8b9d3426eb636db055ccf759c95044a5ce1aea3a3846d650608c42015197f12fbc5544fb0085bc182815244ebccd927396eab258868299b588d8645f44c031941d9d59cb0734bcc5aa047663696228f5ba6b2e42bcc15a34ef7f3f4e4bbcd40ce73415d5cbc248c05b423902d32711125320b9ed572af14c60d0e4b43d2e1d01f12d3cf775edc704f719afb60f229d82199b315be44e734370df95261c906f8935998522d22071f313f6fb57f9455a84e3b3d2abfc93c37e95508c97a43793bbe0618078ef00745b24f5e992a790b9141c8457c3df52d77fabbe5c53e8c6757a5fa42b9d6171ac5e416d1c655180bb987f23a871b599738e2c88ca9d728084050cbf7b7e3bf5b207f08c22d8a4c741c4347174b49a5c3f38b98056a041004d1b67a3763326fbba551c0cc2fd1ea2f2297d2d01d9cb3e730353ed0f754539b290b9fe8ab175fd75609f30dbeb1dbb58de3c533386f6b40ae6ba3142f9ef4ad94f1477cf3bc4aadb7d12a27f69993ec573f365c27a1ea3ecb3ecc32cbb360546adeacf95770531fae77cb08675526138be8c9ca39c824fda15e167270d1fe935982681eab4cdac1cc91ae514930db79e109d11f61f346f9360046468ae0df1597c0d9f4d1cddcae882a3e35a1f7e5c0e19bbc8aa1ab36fc2d56d6b48669d586bebfc3de5a6b77981a467b58ae29d9c2e663b3d0e910af5ffdcee8d5b6ac320f934de3d8f9ffad866e65572fca1b838933d9e04403e5751143ec45cde4cd75cadb6ea5229db1a55c90465613562667d88be4e06a571b10fcc4393338bfa202a35d74f4ec7cdc3819ba452d80f2b6ca639ab9117edd746f27008a8b929ba06f8be4396241ec7716d98557cf7a1a8b4fc8cccdfdd5a06f0ea1062bdbded12773b58857eb404b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
