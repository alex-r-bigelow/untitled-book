<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"780e743c78983173a0247a356345fd6db823020a2f5aafddac5ece2f4ae8b7f2ea0608d62ba0728b87b0760d6c2dca6a6f7d0c9f36412415fda983834a9a92023a25985d9180d55203ca0b7adb5fa54fa86a9b8724beee462758b9a405cc8aed605c582a710a4756db831e37f04701e1dfed11b6ba599da05fb14598c88a4d34cd0007a867d196ecfdacb55c0e7ec98dc1acc4223da9f8f2c550433db7ba4ad76548056d274e7e4a5bb64fbfef5a7b2ea7498b8dc1d52c773266a2951627868951b49d0832b254620e38c5f09b33fd45aaf74afc9522f627d5df2674503b588671717ee22accc053b66231118a3d8f949b408f5f468050f47cdedc1334c67b6b04afd2831330a07099991dada421799bc281b7b47469a03a21df0ee7521855392f76c029a9ed012a4e1f9a8655f3b31a86b9ecfa3b4da6ece3c6bb7880792025ba682a3c9911df234d78a8132707892a8dbefe6722b7da3c8e1000f1c60bf6ea7af58cb15c39f3c3dc6ceba2967c1bb76ae6abd39224b6c05ab5c5ebb9773f69af63d1c6bdcce9a843e2ab4b925bdd1dc6906cd203418fa6af090b1cb9c8b057a05b9ccaba20e050016d4cd135f983b5b1bf749bf31a43c721d5cf4c3908b1e072acd60aad14ceb6ab6bc925e5a53fc50adf59365f389ca911925bb3dc3b2c66a0966e68daae5340d874b647a4f54cb4edaf9b9c8521488556f61d39e21f5ed2ba728b19f77dc6debb9ee7f55e5af507a7d1f42a1e356a946421499bf83f279967495e11e243b1154a0af83a9d9a2ce021e044723eba9f5138c7404481561811f94536d2cf96fe9ffe9351842b9caa135da35944d982e08530af87c8f3158fdedf060bdb21fc0ff47b5a4b5d8d82d719fd5181c692f6deb47c0a5d391979656aecc20b8ed7e4cdecf076243f5d5c229ff8e2c16a75a9bbf0000384488267c97ee892124fb53e627ab404cd4259aa24084f87477eb7024fd2d82778e803097753392972b3a0970de188bf345c08d89c1351219c36e1a809740b30615433fb090832b9ecf4d7e945a8b21131108b2825a7b01ea73a6d19fd716a12c1eb86d32f4220625c03f472e83cb836b69a914812ddd04e52c3c14dd55c41b890a3ff67dec6d43b12b9a69cb3dfdc044d330e9a639bc4a44b666c2474b9a050d6bc6c14c82bb93b78435d5562a216e726f87bf9a5b0e71c2c904a43807816d979396d5c0b5d9c65f77a1169fcb8aa972bb4b2665f92af6203d90089addcaf46f8fc2d6e1b4888fce3eaff858a3417b3b3f26c12d2a92fbe903d58f3771a9205081e84dfdd1765c2b67a795c77aba113f185edbbd8d80fc7ef59a99661291a479995d9a686e78b57eeaa7bb75431525a11a22b7ffd16153a11a5802f318890efb90ad7805ebdb0b7b90e75000c55eb92440c1b1dc94f9138dbb1ea6267be12b41103f2fc02e7cc8c30b8c65fae40926b8fae153b3655a114dcd20f22a0ec569420cce72b47b3b550c4987e372c8e98adae3f45c9b4e47a38e33434a3614577801aac6521269a9d108f1fb36ea83d4b6b97998b2f0414c8f8f6ccff048ac9936f2d481dbb6fb43f95450f13f598650622cd98a0fbb1b0f12fd5e799c1d953c2118466b921900c1ed7f880956a3957d4e6151db61738fc24a027eebc231abe883585d7c163830e194edd0274d27156f15a7f55e0bd68de43d70835cca2e578342c9fd9886489ed69286061588271718cf7e99d528be9056132c2f78c76ffb89f3722f78606d1a10d7b7b2ccb3127f37a6a0aa496ee73d5bc1e685c29b3261f859c02ec2186b92684ab1b9424d766404ea99f086531b03ee68174304d881d8fe3159ee42250a69d365be3d8826d27c36e8f4913f687de8d84927492bccb8342650fd913c633f50258d42096aaceec60ede45410288e749274469d4b5586ae695163f5b74e63bfe9de9dc302c401d6c44ba5ac94d7e10018aabce8d284fd0e9261a0f864462c1ff9835aba7d5a9e9378233c98904877b2b4548709a954dd8ac254c86e4bb33ff30804a513521a7cf7c05ff37ff1d7e8475df0694e48527ed7ac0982fec556b78150de71ea553e3fd004fdf0a71c8cb9f97b277b5b3b741def1a149602a08ee2e2f13428ca8b6d4345c813e39fa3b132a0b6dea79bc59e192d1cb4fa507d89f8583d92db9750d5180565059c15a387d7a11682c6771b8f6188c08593c59cdce0ace2b3f32701d41cb5b3c28178c32a7c6dcd91af7ca5ae71f6d847cd7466ef3c503859aa04557abfcee658b3695f81f6de057170955259aafd38d5cd28feb212f00e6b41f3ad295f2f710e73bbf55b10ec612073bf8d5eceb82bbc604d14e16b61ad2b699e913fc03cfc1d0bd62d6577763806352905e15189d334f7ec8c220955095e69dbf1c7539b0b448d2c7f146f41860ad7df3ea3928ac4b9c302461bd76edb52fc52ab50693bad3ec6e48a57fca1718452c50b8932bb5f0310062de19ee02b546488526d9741d82c9a0b8a0f60a8442101a2f677d20e6393c36807bd10d810046ca88ac8c5b90645a8956ec7f5538f6df3d78bf293027e7eea472c0bb27fc19f6d993368bc1830f536540b03001ad7b2c1ec890fec149a0248e96f362ab90603ac9bf84e8fdc5ad3e3c1dcf0a4442bbfd78e104b836d71fc9bf6de586a3dd3cba7a157d8e5c6f52ceff075e389b8c3b937341918ed05d11eb1517a95cda09f403b730b6d7896eb422bf253d66f0e988317e6dad81e255086d623c0d4f2d02bf8bffefb416fb589bc588f6541137bf04c5ecd269c753ffbdbf325f547b0e2fb11d99dfc68b9ae0dd568642d1ce13ad2602a7e062fd3300e06af0f9d803841630a8d54fa0f4f2248baed17705a30479eb8fcf03d4b7310f28bfce96e15b5af6a22a856606026cbf19c2f353a4006f767f08f1b2dc27274267cf144d4c93a392cec0246814483b9e8777e58f74b9757236cfe0fbf3bdce29ad472f3dc29be89b1d098fddd128a20909d50fdfbf714ecd0ba646a91e0a38da26197cea06e688dcdbc6215552f5055ee4d13ec4421ab8260fefdde1f1255609ac5d5e5e9d8e3b2b7497caca97283221b6a23c3f0624caffeba10805c3def923d290d364d117a4b5562cf96590b87cb559a081a3b15854e94020c33a1dac5e1f6a33fa8ed26c0b1f44a981b9311fa8012a4df50c67a766316da91f09299ef15211ae16104beab3fe251e9d04f0eb2213619b355392cd5d807ec5dd496d21bb576a373b1d9a786f081583699909e1fa78790c6ce06e171d8342c0b6fa20af9c5178f0cc2b4bc3aa5e6c173e9dff00c10f3ea984289e0a1928e779f5386016c0a3e9b96d65a6bbc4d60d2c68bc4752f1ae61adeac0fc9bdb320a7e7bf3cafc8c82ea6305b6f197ab8c7f0272c5a9e7eecfde6c112acbe991cb46b832553763d8a761345b01795648668b89f1e82ab2bc358f9bbb0f603382c538b7c8997e770f987b61e9aa380c50e22da870fd147f919024c934b8fdb60b126d01616e58f48bb45d5e1641c4f166df4815c5d8990f00622dc15a87b8b15975eec877eddcc2f4b8e3d3f86c07d7af4c1def22f26265b1776de608f15b78490dd78c0abcd90a7a6491839f15b4f1efd5d28d520b52816c02e91727cf56dcd52a98cd594dcbb041b3bb3d2f59b1ec02d0f638ce18d4286643e7bcf85f971c2c7f4409298590443449f4065ca7a2cd5445196c52736786c270fd11daf426b56273a0c34d88dcdaea071eea7d1f40385b6980cf3f33053d53203b661a2c6e39a8444441e7ffd6a99acbe2eeedfd13d2926664dab4fa4bc9a2e79938db7c2433e37ebb31af12b3598c3bda4d9f2660b3760fbbcb2cee0918ddd592e52ce6f4f8cfcb690530119f351deb5f2fbf8831d0a9adfc02422349a018efb6961657777ab7cae523dc807ec8aa28ea45a9122458948f77e156dbd9a147936fac035feff62c878b4df47b734fcc6cb7b8642822c911090843a6b603451f2b41df0c5201452cd0fe84237293da8298608df4fa3209f60bb41a4490bec67d77287bf6f7ecff369d1a1058b17196184fe8eb8c7321d00932d83dc743732bb0a16a9f091b2466b6275059096c609fa71cd6786b7ed1c009d9015e06b87666755c80911d47c781f9253443dd5855218cbc6959ad091d91bba9100bcbeea5f12ecf27fea53965b95bcd1c66c7619a24a7021eca27150436214e6b776049af6ff85b1d093586252a1670dd2e7c0e911046d94c76becdd0576020e060ca5f58c2766d8def1bffef21b79bf86f762b62b172b79d264a3a2d760807818356a90af949c8677e5284d5931e99702365a086d3ca0cba781046850e0db6eb6ea3f5b55d401258d7bf8aed642f95ac770b36be2f5fb7f6307cd9aafe131751bb2fcf880dcf6c281adb1d5dc74ee705fcc1bacc4606ad269886a6d5693c3c86d5f8f52ccbfa48779dee4d9ba2f150a6d4987ce9280385b291209989a37939dde34c3d79079735a09ba76cc4c56c3731300edff1626a160734adf187bbb86222489a16c992aa35125bdc7e96e32422d847b415ad70d0dffa94470f1ca4571cd0c9dcf7f5659473a94ee6ae6bc1c57cea9956ca69ece5bb57c07e5b5e0b81e400df3bc566b802618cb6014419abff1030ac7dc8b9bb70a4450b3aa5a46c9ecfb711baaf88b204f6022c834a93efd62996a789c6099aa258f847490356966c2c974f01beb80f5f66c3ada4f83175df5be2724a2b572fa4fc7107c6c70979658b4fcafb6912559d4534c459f75743e7908e96bbf3dd60ecd532aa548baac366f821e05c3c02c297e67220b908808b08c527ec32c67d12a52d62dae1e75c3c8c8273f672c5b0ae7649177d04b571350551e72c9ec1a4f28eb48eb0a3e2ed720e701912ffbf235b592895ad9aa8f7bc7a1774c895867616a8bc3a5d3704cd9340d1a0c0bbc6cab4d3378b105035dc239a2dd4044db2fa2c30d57500795c085de7789a93e562b7bf24799db5058febe19fa83c805cda2e9389b80fd3ea1ba7f507ce5ea0f69cedb34351ae396570d89fe53b4088551c549a92884407400d2a087041b4cfdb05415676cc45cb98d90230c3729f14db7741deff5ef5aeca6c83f6dce2b79b425faa356db340393075c9a6223263a15cb7e3ee134f47936f3ec35e09abd35f3d9093694c3d6e9dab7c189158c573a8ac2d8ab3e94a0e5028e4109fdcf97fef8c8be1cfef939771e7cbd86f360160b4b7509aede9254e6ee05a3e9b44b0fd7696ea23e2b89dc40cf9c0e0cb8e3a5c85c2f23dfac07e85e45dc1f6f6b116ccb37f5d0e1baf9040c8861ac7a96fc5d65484cc7f1f1d9d504c023ab8102205791932caae5ffe6401463eab398c51860f4f79d060daa26e2f539d368f1ee5912c068dddd062b04f1a8ab1cfa583fd888988fcbcca9c58c5ac0f41adb0a64d4fad95118a0699812d607852e6156aa1ac4af281f4b91a33b34ba1725bc28d37f225660e81ab86c4c4a4514604bb9e4954ac44ce550951a2e8d07b50977a55a42deed00e20d7dc3eb768b6e30025b577714a4233b5159dd68436885197a343fc3415e5fe04841f48884567370a65b9abd47befcd4cf2aa0df5cf5f2a2378b2fec3fa47c921a2a98ce2ab9808d0fe5c0133e586e3145ec0ce286648c45b7bbc552258445066b6bffb30ddca21387750b326930a23f02f5e1c57c1f20446b41be473653b2507d1048433caa1f8daeb7e701d49a61f6eed023152988cba0ce19895bbc602e20b222cc87d103fab0bd0db015394005a236abba218b5cf5e783ef8d04e4681355c13ce3ced4a44115f399b5be54a9222b7eb43d5a27c971c9a63a4bb91392abeb31892b537fd0c1bb31327fbe97f78e2c2901f1449fb38364ec3fe5ce33966091047299c623e610b03be17411ae57297debbde96283ab38a34bc3420686346de5e99dc9f33e3e04dceee00516c2471783a0eeefddaa0e66d1baf74a0cb419b05dc3c31c77c66c54ca86600c82165850a96c89719102e3e47bbf530c4fafa42c13175c4d812f86f292e5136c1034e47ec90cb6b5fec43da67f3e152b0aee03d2b9c9bbfbbd0367c777c82b599627f16c748429728d22097544f04c0fd8088fb38dfd987cd94b95c2db0ef3a83944ff1f9406c8d0551158939400fdcf33d5240a43b79328594b9602b894f2caac271d6d98335d01e244e0b52248a71582a19b3886156bbd7611aac5d0ccec220d84b8678648b9c555627daf7a16e2d0d18e8fb049433c34016b759830a73b0fc09967ca80a8876c1717311dce39a989ae4a8c76f502fc13b313cb13fb5299bd7d1995bb8837ef70ce244fde7ea9be1747aa724147331a383e3df268faa7fa5d7c79e4a6de8cf62efaa2f5093e03601cc67c75951fb35214016858a9e5c961d14e00129b7d8510cd4a98792a1a1f2821702aaf4e48ba1672a62d3d0293fa167118701f2cb1f04209cc8fb5185fa859b3163490fa48e657b2d963a60c8ef2dd7e71d727588d41259f9a5fce41ea94dbceda6ebf535e21ca37411b56ca9b42fb81e51cf2d268c31d1b83b98af031117cc169173109bfaf8b4cf23857717eba79e8d2725dc48843e4463ceb1f18c349f0cfd9c5e93097ef68e714e3c3a532234936398bef3a20813c156566c257f98493b73fcb699b1e409633ba22c53c8c2ea859defce5e4f20544bdcb89942c6afa92f3e898e491cf1603c5bbf9084e78b6acb1550356ba40ac63adc9dd4628ff2aada338c0c166ac34a51ebf087887808c686235bc7c349bdefb0d0db1c4966c48d72df2c1edffbca1dcb0b153f5466e74a74d298b53e6f95482526f6aa9d6d87416f4b4c2ecb1c31b63bcbc0ea9e2481579f8bb4f4fad560773339cee76f9b6b7d428e7cb0337d297b7631ec66acc372fe1ac3286e67689c175de5648596d179e6db189a7567c925ce3325bfc1d121df70e5b15f589c1e7013b856d80cbf88ba04e4be1e2689b040291edf728c87bb9c400befad3bc853a6f9c9930c6ce00b83a276a427543c1cc75302d686ae7dc4c47bdfd3189c5a8c4ef66597e76a5bd2df0842eec07f9c41c3905a7846f14fb609b637944e8d79237014daf9a04405a84c443d6f93813e0162168533f3fea81885280487577d84daae8f98dc8ade824e501ff51ba319a9f713e83377dd5fdf8527f5f8f6916a18137a2ca7c364a78dda567a1b02df3c04e7b4098a1d439fb5a10bb4e7135162963c8cdc9614717318b52317e38df21a9e0bb9509db5267d921ee7a9ce5d146bc28cdfd125fdf573f92a8d41ef29831b170c5378cb16e47361db0eaef5ecc93fa60e903ae5e5792131426c52f7a628395ef8707699a524ce23ee48658d85403cd499dd292ac5f994987aa2cd3321d6a337d1e19f8137698d574a6231f94aab88d3f81c7a8627d61d6a8be7a0a841d6aad18d94ae036a456be6a22faaf0e8e3cc9870fcfa75bedd2def7349165eebee96c72be030dc6fc6fe7c3c62c5721172cf2ac2e23893a92d4ee0bfbb538e41534a1b8a42781cb02a69cb894e1b88e05cfb053accdd835215161795b6638aa7c67db0ff2f0bfeba80004a8a340db31ffdf03da3b8b9a61e4384bf8529591d6d752119d4a174cdcd7a993bd41faaed1f55805f694575490687142d8f5e9b9dda2d29070c7a93b01f1020fdec577a5832174df122d4a812e36dc0cb4f78d211cda3951fa87606c9f0146f04adb1bc5883bd44dbe82b6e383f4bf743e36a329254ca47302c40a0479e55d8e015ea100a2cc0b9cee4af93c033acd3787f19e7c2ff4b20cebfab47a910797a977bf9a6bf572b54000ec98813d15a48d0886b4f0b97a862fbec3081347646323c37be09b965cc19e869a1f38179c9499be4b8d005ae9cb6c18a4ad56800a231d3e50721b698de2b09c75b911f0fccedd06b67b722d36fe85dc9ef5047e01f94ac2a708f8b60ffb9189133af44e6aa0588eafb01a8c5ea676fe2d12a35133ca0a9f376959dc6598ffd1eae85297475982a34f56d75f05986216e21dba2d3a55399de220291b2d1781e123f5e069bb03c1b54731fe2aea3d82ea39c906ef79bc0f31d64289352c2dd18b27487ab855b111e8afaec35119e43850cf1bb3dab0e4f9dd2181e02d71efa2a355cbd2d4fa5c23e90a5d38ea43f4920a70e7ed301e74597953b448ac93f04ad48e4b6c515feca435931edcfacc547df6bca3e2515dc0ed26887703f532c540729b69cda3df812072e4e922420b3b6aa2fefa362f376ccc3b4ce4d7f71ec3d968f3fea905a9bb0603c4c225b58ddb4c8d73f2d1adecd07b5059646a7eca10dd5685576e8f433a8893bcea2628e61b8d3cd430637c8cb2d1556168c1592b26251ec9724d205306dda9eff6dc20dec89d6011593c79ae769d6cdc34c94b30758baaf47d549fe591401a1969a6031b5ad29080f28702cf2ced5f4fc8cf212a74d60a6f09c42b6477e29a1e2f9f86a4e8081920d19df6a02ddb764ac21afec85a34bfcc761394a06f2f1126da677e87bfb419b41f45656aec87e4ac51fdadf68c8070b70e99165ac78f605636eff472dbf92a6637e923917fa75d591e1ee9a11bb7f0259c2c10639c98cd95e531e33b1c4eb8acf5b8d34033a4efa1c8dac82a6ec7d928918a883a6fc778e534a53bce540a92bf21f7bfb2393794edc33ea478625a43220a59e3577c6c995fb4464b1a8f491add0464e07b9435fbe221e88bcf467a7c56ac7222830059d56fdf2d944c2dd8a3e799ff396b4e18d3eb0f8b783b426a81a31b84ce36d8c5f9aa3ddab61c84f8d0d0511918243bbdb97f3407bc2123dd61a7b52c16b41c54b59a5c4f0e3d2415fb282ddc185c25d962335acdc7d589037ffec742e0bf3b967ca7a262be5afdd4839a8d02a1b5e01ee28a7f3bff44d6d47b1e6500825ed7cebcaeb9fd27f980be3226cac6cf304f94ef73017c16a507f3a492221e5c95f13f50063d8154e929ce7264b32a16993391438c25f8fc288547e1d8a7e297ec231d42c32e5dfebb22f1eaf73153a5720f3c30331d9f53f643830cc30747b7583c150e690b78535cfa0a08777d2860ec43ac11b00fb39b64bf26d736db1621dc22ec2c279e7c18b530905f5769bd735296d67e17376084d3134a9c6a19cc8439a002bd477810557554a5c359f59cfebfa02556d14fa71d8fa6eb0a4a76ffa5d537444e2b9d611447e3352c01ecb055c60719a180579812c74a0f35bca33f9bfbee996660af85e669baf47409d511be0750de395e88267a6dad862a0e1b4fa454ffcd29e457f47cb7f0f45d90930605e4a5db481c962ec0a8382dcc0e3a05c02955e694d8ea80669fe84c6bfbab8af0beb47d6d601cf7ddd29a41fb9fe9bc441261369e9107ca2fb93b796afd6ac4ee123ce4d9fc65f2d5c14f485ec3c820b0213731942d0b1927b4287efb3e8f3cbc0f15bb604d38530f4e0fbd70672b2f51886173eb241ac87a091b781d50b9f5cd7c2691502153101d58d90fc13656808c4e8398e1c6269fb76ad7d0044aba7fe8b5dd79fb276b5664d1c48f629ed26d82cc42bd9c354fcf8b033619d43ed425aa62026521129afff046e41456cb43beda49561771bc2110d6cdbaf34bf9935ec15d48fecbe095d75cec56fbea9adc652c7736bf360ea27d48306213ea58b7267fedc03f153a7a340f7b7247eea89ad54936ba008b99a9820fffda28f485aeecd8c7123e2458fd0f3559b8aef8ac7d13f7385d44a17426407867cdf23985789681e8138a0b39fd4a1ca2514974e3e19c95dbc4ff2ab9c157a5c912f26587993b2c059d81366619e1d2de55622bae64ae7b3b998ffad7d096b14da834a6d8c9c3535b37104953a17747d647e999052d4ad561c49db50af16ce93696c0b0980468cebb2ce985d4dd2a1255cda4a393c555b484c66628cfa0d6be67bdf09cf6b3ef65a528748a197f30b73869245b5bb1e408c439b86f7eb816ab79aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
