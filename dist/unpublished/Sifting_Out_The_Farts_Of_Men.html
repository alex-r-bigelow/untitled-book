<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7006ec99103eeaa97345d2524e9bc6505455776836788e12832f57c971643fe4c72098daaa6fd51de1800be7ca44f9e52597b56405030f1fc120639e136b6521b922a50f2d58191219b22407ffc8bf6253ea68b46e326d37dfc5d32538c31cfc8a3a9cf5a6f519c0e2377872325cf2b513fbb7f276be567c0ea54a4ab5095d70decb29bc0940f617069a0c2ea956449dab1c8f5b88be0f1f2cf981a9082a13483a6f8568dd7966145cb13195ae834371d0118d6fcff26740dbfe3ca6e9ce331b643df82a3fa79695552f7be6d5a38124bc10aff1ae38402ed907abd105644c50999a918d85455cebef71de1cb93f767ef447b5dfcdb4b14a6895c5fe564755f2a2d92cd32c6e9e600362047ed59476bb2dc11cec856ce1c688f97631daf288fb2e672f131d26b79c99d299b9f8f69a82f6fe212be77ac33f62a5889fcb0f3b8f966732efd156cce81f324800d78efa39c4862dec1d9e88e9a7439b4b4ec6a36c658e6840e6d1626cf29055fb8b37ee392a2aadfeaadceee77d7b8851139b2350bcb8a7f5588f99c3de28be9f67b7d0e1b523878f76189f014845a3d4b7b902e508596368914a0bf4e968666627be45bf05b4f279842d03cb097b638fc6f57a589d2aca2fec375b3dd6352d079899cda24ee91d6de0d8b31c3b6eee8fc9f5dadc32645e71be1f9c3904c5f605ad6ea1780ee57c7f24d4b4205e98d59f7b9cbb93b72ff6882dbabc3baf95d623a1d7abedb5c9b0e2a83bd133b36d7d2c464278ad7426f30f124bc0edeb18dc1bb27f0cf418d179d6de1ba7592e3f35f3a6682184277de5cf46f54a75ee910fe52c28df74e730a39dc5e05e69b499b293c574d7dea9f3bacf84f6897b0043c00a0a25eca3873b42ee2dfdfda956739602f32d4886b534ca543f2f8ed5413529aabccd6fe9189b511e96582b3b4d2acd84f7efe148dd53dbc5d59bec6b948d5b1a87436b88ae1b29205871018dd96ef948273ade7522b45b7622bc8cd420f97e4c68e6443291f30c86baacba008fc82b19044b4fa047f88bd350005564776eccab5c415d821c2538d763a6c9349713166769e2d7cbb818f8ef43eb936d0489e468348fbc8094563c7c1a65e8a3a724e1e699a4968e7ced8161dab8b40df6330685a1bd255e0a06d2c4f9571ba923f5b8498d10309e11933c2aff1f5fae02681f8836131557ae48374050a10449148686b33000cc7923a440fc1666d78b2880cbe9393cc58300ea2d7a059999e7b94b2e937bb4d8c9bc0fcfa5e06edadf42ad9313e5f732e7b0f9fb37c75ce834cec1506cce143f5688cf5dc87fa5361f5b7d6da2b79a312b706840a926f719665946c55494bbd5a3ebb5670b04dddbaba5cd95fb8e9d755911fc975e369861221f11de664ea783b8eeead779a76ddcdb364d802fc31dc6dff25e5192bd0ce44817587106e25c89ac480f758ac55c649bc5be57a1d985004c733d69491feab2476336e3b0e76c71c266436bfc8e87590cfd2a881b63d782a26d0fa04777003db67bee49694a145ce7c44075af2d640afcf92cf8c06f36ef5b5179ea381e92fa0362d1db60b366e0759a550b7510b1e94bae65d7de3f9d2bad17e9c924a95183e7b92410b10d5fe906e00385f1fa18b6d9ba6b48e419868119a27fd2edf9330dd1024246f0207f69a81961a8805b6e67d25186a9a1e7e475de8513516ed34e70e2dd2588a30ed3eb24a0a1d079107159f2a14124291263e98caf99ede62b1b348fa09ab4916ae0e5b901c5d735b9981577cade8c3a04895538ada4277d95bcdad61db4bdf2e80e3134e8e8d0681915a2b69a272e703fee70b3516ab9bdae6d03a294c1d300a2bcfe0d05cae199b8b26029e51d383ecb850875db9c60c83cb8a87cdada113183b5bb7f1082788db6e723e004a898413308fcd2bc0989088262c5bf2ba4acfae148078d79863f9167a55c0098cff3ecc772421cd19d27de7efe85e113087ccbfbdb03cdb594e33f1e037de7034d6a5c9515d63a07839c84d2eda6bf019d1da215aa974905794200dd8efe820afa879d530171d9ab43d3dde7ddbcec0407f4d89d8243aefbed75e61396f0f879b7ec604750aa87afb7da8848c1b3c14773210db28d3b47046e89e7605776e5d6cc753c7bcf4f9ab5d22ac914efa869c8fc782c16f9e352af9c89dc429a6dc64b08dd2efa2504472cf647a733896eb0f260a19f3648c47a704826f45e2f7913f4898698ddeb962d3937a80ce429f9984a73f5c4ee6415440372174c696a0a7ece867921172ee4c469a4795b59ddb20cf6d42ea7a8dea54d10d60858e6fe9d6bbf6e9b593b137f396987fa1c8d6783f22195df4583d8cc9dfbca03623507146c7737dde693a2da8e0572e99fdb8404376dc01697375148cdc2bae5efd7d799f09a3d7ef7d6a8ef240c59d9c6ae4786af518184284297b728e143236e680f49a39f9efd8848e8bc0bf22e7f0df4396f23f61c522b64b6cc0debab4798e0e4bf63958e4d7593c35176f4484950149afd9637ef90779afcb8708f694faa5aab9db4d9903d7812c2a676dcec52bcba6083fcbec6ce320b3a088fdfcc8b2d7692129f2e3142532015168ddd9adba99230dc43e4ec685ffea78488d46a80e447d5688adaa8108f445fe664293e532d17baab68ae69d71a58a95edcf03c2f02fd956f17ab57d4150b50a02a3a0bef86fa78cf5d6643173970dfe2a1a448c683c37e46da1569cae26dc65f15a3264ea289a873f76fdd35790c596344b926b2981859a61e8997095499edf6d435df7d753209dbeeb10cc4007933d7f2eab1ce6a36187fdfedddfc4e58922e0e6738ddf042b6033d089ad120417dfda8b7c214ecd67f7806b298df817e3444d0c46ea5670f08e2e82712da98374a6c7077d1e5acced9550132a23d68d1ad71fcc5966f81ff758344649b3ffe7ba7da855e85daa193c318cd821d6075390578aa9e0a3dea0d0b210553e87d9b4e30409d725af2939484e66aca14559255e8a96f538e1a5e2b2ad6c6f8a901565a3a27d9f0b608ceffecb036c3ec210ac61598e07ce7c3c9c92a2368d6952c984c003b03db31c9dfbe898055826bb218691beef64467c97002a89d1081cbc16443b6ae78a3c1bdffc0da26fda3ca7256e42581e15393acbc1e32f6f259401ac4cec7384082f4ce5b315270a4df7f7afe682b0c1b1d7313a958e65d60f1a54fe169a7195be92428fb9afcb51adc1aee7a1f8e39c86c32fa55e9501106100a46fc91a97df81cb64fada22fb2de25748e81f63484868cb072b433f934f252b2995294611f70e922efb1d3d944161e2f23b91450f784e64efdb3239fb1bc9b26deeba57366d3d5e8b4b15b87f375f4b0739d9d934115fb6efb7635eb0fb4729d53dce6b7f9cfa641cf1d70f54ea34eb16d60bb80238a73c2bcbd92f7c63647d90acf1bcbd339278a621ce255fcad66d7e896db91c6ee5b20e868dc8ba77c9a33e7faae5aa3356acafc1502d76f949d4d791fc6428ae854e47958dbc201904d8bad54107d9449920294499295b6cc16d4f2e355ec20eec1bdeee6c0ab3257dc16844f2019cbbd55bfb46e26b42df44c807283dcd610606b0ccc1a5242cb3c57e395a87cc04a5c7dc29617cab91d63aefff8bb1493c1b687bb77b192677ac73f0ed5e61eae925dd5a618d27c96e216999cc738764461e2ac6ed96db74375706126e2b18c81e90f14bb0120dfabd7116e6253d313d6e01aa2b37769557ce1375d2131ca14e52159cf81fe194fd2c48b8a7a8e24be406a6f134d7d687eb6dba7057a1b59b57f6b9c6298bdb493e72b5c2c8956e8c622944fecf7cc647ebfe41ef22d6de1b91554d0b7bcdef3c4d21135997688368f613cc11f67f4fd3e35aef6819fc527d9ded08a17c9e55c92441feb5031d1e43a59ff941c0e9c2c0badda38df0f31c5bdd0445df20b474fdcba02d9ff9d02f077db67775afde70aba453427a826fd6338ac67ab1039658bc329ca1c1efcf99f7dbb54f53191596035a1a231a6dbe4210a8ac5b6bcaf6c5e1d6edc4770a10b2ba355750a9cc2d8244298b65dede277435bdd02d58c71ff3e4ed5dd6ddf4c9c283df329ec96a6686732fc71fe05e06ff9a1810bb21926da0d5482e7f13fe8e6c7abedfaa06a31fbedfcc0b9e6b6d0b8fdcb29532b9e48661e7c12505f18af7fa2c436ed7d58ee5722ae46ca3fe7928a563dfb57c5e16c7de117e96e4674561cd63f52341841ee8531f90affb75693a0a9ce5750471c7c1899f2bd61fc1013a90740e58555ad48ff3bd0d578f9d052e72b5599164757b9724288ccc97f966808d16f91398b5a03e92da68d4d99f85349a9facbed26463d000b403a83cecc05195cffb7015892844b953293d5bee91d82d562904af83e3f50e07837ab3cc4c7addbbde0cd001989e90def4dbaa14687735aff8b194b4fc5824dcdf0307c7e1bb05285f6eb460e048b215c699fa8f1ba77c2641f085b331b98b30d8466c8af9832747ec8ba51c24a7374f4de233251392b22f69f41c93fce3dd55858c30eee2c5d573b39ddddde918ed8cabd71cf9de7d35a978de35d69aba185400d5c4392adf659a11d7bd8774c68606b7a9252964b7d5d5c62e5d73f4e5e626f4405a6b0c27e501aeacb6c0207a62b02c5dde88cc4cdd77b69cfd4fc1616d31f6c42eb399dc8d1b72771b03e20ff13242f0842485629f316c07fbebd34ac77485f79201fc674d467283748dd0640518e3be109bbf54ea8876666b8a2d6cdba978498f10ef14c693ef58ffd57c6e6f2b24e62313b19f3abd26e5474ecda2227dc292275bfdab2600d10b7721be1890f517c89eff195540b24868b20551b862d4f8864c74b1809bfa62bde9b1e37f00ae2368f1ada5650c3ef71d31ec0b3ba800469f7abeb05ce137627ed788d6f7ba1c12a6d724a831625608ac0ad9c0bc43c2f1f889673c601ff50a3b4aeb61eb92443d2097b1aa4af50a1f63aedd6fdd9cb4cc25530668c073c4ecd9e525c86c81a2a6a055444ed9e26b710f99e84fffe1a42a21000f960fd1a9dae4b2afbe7ce583ad4d8094afcb57d6e601e8a4237a8adece60afdd5572c8b74eee000545e11702207c0e9164bb0944be1e6a3d4a3a0d76f7b8f7497e79e508124e3c576220819d148a941588291289eb6127270070fd72601cee105d7de2cd3e3b442cccbaae491b94c3ac3317cb4cf809a6cc7c71258cff8b8a1d408776e12ce75e1231cbb0b12a9644904dd6cb98d934859b9026f564a04a8b21cfe02eaad84fd331799de436c8096edd20ad637b57d9a127bf5b0bb3fb99c62bc33f09d1cf6ad8cdcf693738473752878f3ef2c8400ed0fb76b36c9774c79f2e2fd14258f181a061a543382b1ff4f55ce2e7efb4cf57369ebf0743605de8e3ab46bd3e765c908305325195c6458584f2f1246fddcf3f5cbc66f73a46505692832d9ac4b6f42d52c20f080fd81bbb4f287a064d5d43c6c3661bd54a9221b778cbe47aea410ba6ab0f5582d24224016bdeb4c1c6c0daa74874207c1f818514a39389f93a048340ff6ca315eea9464191afc41b7e3fb9a2cd52258326999634d256879f369797dd940afed3efa4c54e48678d14a32801587b3501446568d57f5e9c0d6d25069683c5827c2e47cdb928a7d0ee274cac586407e66f4b1f078e762e22a33ace5f4a0bcc75821849bef274c272f5bf9005b38d886e94c86840bfd6a4ef1d1109afe2cc9afef43ae5a970e0fc343b9018b2bc2ec77e3705c82f5b0150d0984a0839cab0125773b9c0470b98e6e05c039b7fefc89e9d1e5a347388a0cd66b150b0a44eda0ccb4e2dcd5e1f0896bde63ed4473b9c2abd1fd63a6218af009116201c3dfe2e197652d7d725795adf44ed8f18abd4bea20083740535df407967dd41b9857d8076e4e81066cc10751a451c85a368bb14f94b2fff8235ae1f18104126d63e4a9f31a7314e808f97f0a0d269e0407e6e9b8f935be40f2cebae59422afdaeaa941b26923c3355ee1f678c2753bb27bf12561f70f8d24522d956570821020aa39aad33a7e6807703abd59b7252ae892448de8b63ecfb7c4556f92ff035c907283c8470649df8b50195a25ee82bc69c0f8792b505e030499e26309edade71f3acb000a1be474ae28ead04f9c3bac2537f1c9ed62ccf22740982b0c1fc3423923e9430b01e7adfb095c838382d9f797b22da21bc5bfdc63a72f92ef7d6240c9675ad509ace2f3f01e7f10c6aced2f2e6c5ffeea6606cfecfcce284657f6c50d9e824d686db0b35b6a154b313d83c3c05b87c8f6f01a06a0979b5fe7d4f14355b748d7e24650ea58ad3dfd94ee3e83a2b68f5e2c6a4d8321b893785dc0babb55bbfdd22e9eddcf21eece84925020ede6e5001d0db94aa8f4a036aa42bd799c433c6138bffbd476fd0a3973976b98af25760aece7b696b962218211e47538f0008d4ab0a1a1cdda20e523ab67120e82b4562470c77e4be0a12efcbdbf66627deaee35249cf00a6422233514ee1422043ce1c84ec4fc64233f52079620ba35a8b3a3e7f6cbdac93f874758537c485be4086be8824499bffc4b71cc8c43596bdf251e99d7fce507f243c3c92748ff208bc11f266a2f1acbd7410c3185f90599041a326656df986b6c7f1b53f6675f959553712e04200291faf00d58707ca6271ef9276fd836b97051db0b7f2952d7577cb24e73aca807c2cd01d7b085bdfd3e446cbcb3e9d4524422558e371714e3bfbb4ade1b623d49edd9c37d1e1f933361ae86f987ede842a778c13aa3d2ae9c7004cb2cc6afd52cc18ef0a821e51f3bbbdb10c7dd21d86fe52b8bf0d7d8a480a864a7915f8118683a853ed8b65870c42264467aaa5b01fb267e47ca160bd01b5d9cc85c4f166d9cc1a58e50c7f9f50de10bd1b430e3bfbf293127391fc9fe131031667c74bcf9d6a8680c291c1ff782fe372bbe693bb62af14c119f7d6a2e575e17facbf624991d485726675a8faf353c6d23070d6c88a2689a4803cee72a6bafa56d987d55617f3845940d95d7e6d9e360d7a0fdaec8af9e71565982c4143a49488198064c823c4c618709bf693a31f006321c95ecfb92550eab8ddf8f11840f90f63ecc659c196ff1df5013b8eeb257f5ee35bc607b90a942d7219c6d1513883cbb8ef3018bed119172c83b6d9dabd9782960ce510f6bb8df518d8f888a8679877a1ff01ad22d0611b28034360d6a6bfeb636c463a826ba5b6983b904f1070a0bcb53aaeb9624565b87096423f6fa2b637680c08e7b154aca708876e98fd2a1e67bb1dc23affe20fb020bc5e1d46f85ebef2bb5d1fa187c56925c22cfa527f80373299fc9416b175ce1cc8b19d42eb454ca3264a5773ea86b0bb516939dff673a1099708f6b7d2fabe8389c0db0d647f96d9ffac09f89324ded31bdc13406a229110e3e4e4690a8a163d048c350847111202943d147f92ada5ef42bd04121a3bf91bd46aeb8b1bcac81a6f04150256cfe0d11bb624a661d0f0d4a801520b3341c901762f6098a68c5a8f24f595e3ac0f3659cef2d53f1cd4fcc360f0e83fe5081f5058cd48014d02da1723009b73bf0b54fbecd6dedddf99ab6be324b5ae6d283f609961e1c8da43910229fcf125ee3f912737ca770e2b731529418a7df5f1c4069c136b1a0b69462203c07773ca3f65e7ec53d44e95ed8432432e9b47be2cb952c3f841e020a095681cccadecf11c2612e3b53ef498a97c8eda2ec364ac8b16fdf74dda1696230b5fea356c57fb750ecf435a823951b00a7502546c1bdcb2f41d862e6a18397e95671d3600f728b7a317cfbe3d2955aaf88aefed7ee0068e5eceed87174e77377b64e407ae023d6716997a5b5561caef2959e01dce4f974ba1ef6711d2e81dede796421b875b41ce0098088fe23f818a889c3ffcf368dcf58d53a6114aba4dfca788f919fa44441f6d49b467b6f1d09836de78160a94f78c677f9a1631b3827937589cee1b36e3826b278a396294fe059bf6900af7f76d48ef954df9737f28f173d27646676a9647c4a8831755e9132e3c87cb632b43112a8a9cc53544bfe5507decdfb6ad95bbafa05d434bfbf1e2242dd79b702ccfc96ae128796601ff5c26a1ab95e5992b24619ad3208e42e95f70748a92f07c132d97959f887be60d7857634fd2cd1d6b56faefa0fb414c2d9a56eefd037a36e13bf75acd43730f35692710f67c67d943688d9ff3667dd8d88696cc5d40ac697e666a2000d423116d10c023c6a706d0e1ebd14fb1efe5e721874759aeee91ce4edebb3768c46f94a4bcf3363a908993680218ee6e9d228d88e203b1930a068c482536c0dbaf14122e69db85d3ced14cf042cba5ae586a78014cfef27a985e55153a2beef3fc602f20e13814b8ca1ccdd5e0e146577bc4aaec0d3f9d7335e52353eff21e434ad0ef1bee2f98f81108fbdbda2a2075b3df0048ccbe5e8acf0aa6f92e43592c1f59a2265cafc61b9ee8d8fe86521d02b9eb2d340749571689d5a4f8d4b0df657a067d0e0f18564a07297f389c5903744a40f86f9d9ca226d88be9275e2770f521074d0fceb309d140cc6a623dfd80c76ae4f0efe0c5e5a04d24cf3157e8cd36eb80b2bbb0c19dee73966d486f1ff2b9a60d083629a478fcc50930af7ba88d132e9450a429799bb30dd7207796d320740630b8f94af85489d49f54df8cd0fb6e800b226a4aee04ac907fe989bb6f46fd837a2c9e51e2646b2461cbdea19fceb830fe74ed099a079b93a57d79ae116deb90ba7b2b4fb405aaff3184a9a8125bbd75af592b93bd4c0f6f9b162764b2e3bc393f29d75e8188d2469eb0172b6753a6baa5c48f15ede36d9ae361996bc33cd7816f272ce2ecc8f1b26ff7924fc292ec236fa6a8ff0c10347142fcbdf61ba3596d4106da1ad8e98a44ea79fe1d75a5e58090e6d9bfb7e2df1e9956f746d776f57548a06b0b063a697a93df8137525e84c1a5003e0b456be195a4f24603dd98b1cd684534fe1a73966fdb9a36eca54a0d5e6c1837038dadde6f243a53a8f6a2f8f8dd651f22c40c15d18ad97e77054d920f2bc40d7894da1dcf2ad45b78e495d45e6b7f6492b1e14c2aa63ab88b753dd9f7e242d16ae2a8d62d8710ca7ee34a88c10357afd7a882aa610169e13ed0e62b06f17839a1eef64691db103f9edb8317a29a0bb414a294adc8db2a300d47817366cd2d943434c91ac9f326c5a185dd8acb9435bf490a51c77f025b526dc46263da2867390dda4f15dfe311424fd8f61df140bf12dcff889c6196a7361b88eab67f1a6da6597c3b9d80d1aaa17d4b37a1abb869e12c8aa39315e8a4cecc67351a417acb170b67b82721c39ee24d118378f64199d3984c9152421ab87027872400355098d762e3435cdc67d5961ec450b040004bc282c83676cc60fb0b213c59e5bc8a4cd5875499553ce3d7c8015cb51b8e8d7d01561b5aed256be985910d5117c124a4b1079b9fcaddf37906a3dbe3201126e4daf13c9262c6ffe9e7d872d12bc63f5fecfcbc7f6d9b2d805a42051f7dfa8db7175ad696c61e72da9192c93629ab76bc18f391ea55eee6fccfb453b79da85b131f87f959b73f4e653a54895cacd85d88f255e2160ba05a0724e5eddb47b66ce87263a0b211c517d7b34eeece81dcf5aa2941b754db331cc9285e020f3cbf3e0aec5e9f1a8f5886485772dc747b812cefcdca0def77ef48eee72c9881ade4a2646b2b5fb2e7e75f009ed9b959c3c32ddb8c316d107145c9f8d234b8a192853a771f23c0b0e7238e3e6983727c393d54b15026655ad7b0ecd32d20bfcee5416e241b09919c41c4984e56b2dc93a8d4ecf8f53cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
