<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55dc08b9251a78e40c93d105089227b5ba9cb1ed9e51bb46fbeedb54f9f13354e625780c3f8279ffded200ae3a709be6fbf833366f6860c083bc3e2ee34301d51e25ed484e5d3f456fb4ce7588a5d7bdf49cdc678d2faf2bb4bbefc6fe2eb4bef8ec377d1fdfc37df8fc2ffb536ad7e8ee358a8305962c3c4c58eff6eaa45d90957ff4b5169389b074358e8b39ac49f24b330783bd2dd5c551f8cbc1559d43fbf2527497ac382dc5d77429efff1b41f1269f2fa84626be7f89cd8eebe9389b3e47bb053562f53e9291cc24a56c7c0bdbf3d81bb4b9148181f1996f306ea45df4284a85236fa1b88e5e055267f2ed2f83504a43747edc916cfd55299eabb134592e8d4eb54f93459e0a5ec3620791ea6d7da22411d78f33cc0020edbec69409883f51a21fa724e4b2345dfa184caa896a3ecaf31c6c020db4035554677cedfeb607e2c138e1633b88ff54735e50faa3ac992a6ec9bacc765968cac8b6e74a5d2b97c2e60ad4bcfd53b17b1bd1b09c2e64b534d675eed7a29b57270b35112746e8a0a750a828257b9628484f734e281308d13b4e2de522eea27275f1a47b25f48be426528a7cf0b4112e7170b6d237e2b0da2f4ca56f1d96efdbbba83435a461ee0d5d79d9a71c5ae51fa290a428ca47742e2d05de48b573ad68d1c53f11eaf47da40d8bf899ea9ec717f3615be853a8c5d8d867641c3bcd98ff25f6e420197eceb9ecb6af28df4e58ca298e88b4c9837808fd425e05dfff4d9d662dd6e8155b549e6e623f632cd94209a8d12ea80e896a67dfcba320f7974f37ba381492a81eeb21734addb0a9ca5e250085417314fcc3dde6b61ae24b3dbf5205e5c98d2a90b48399597a76f406b45689107946be33d89755e5d1e942cfb3baa35d3931cd23e42193e929834e41fae3618716b2b872d4b6d821d826f426a7a5cd1839666f3f379ca547199b10df868dd6b949cc55118241afbaa9228a27263e3ba81789d55bcd1f73083e2d48d11331195655b3f6949f9ac7a62d2b579b68bc5ebebc71333478e4ba2cb7229bc0e723a81e369da90347954b3edbd87eb23c65ffd38c216eff18814bac22fd5cb1fb100baceae9634a4d1c98458279ae1e6f95fd652676228b61661b9dfbc540afd3304b4f305da5771cef0985271531ae1ce119de3ca1d320b61b5e86f129fbae007f7b8f9e3ac1b1b23449d114fc92b5c18dc95866d7f26f5c631fb7200b356ff168e994a500f81f72d5f121eee9fdc7a5e8c849d1f44538fd0ba9d8dc0f6c8f32790fc945a3af98d55f05024ccf82e7b41c39396d74c64ebd31182a682031c649fdb2e4bd9638486b845a30d4b8753157713f55057ec8c9163dd1832284e90c55f0781941d918b63f8a482a98be4f42f0799b0e3a4da5a2c3571acce5676b54f59e51f9b921b6b882bbfc16a89a4153257d755816cc534f8106610c5d80a13152c15ceae60330007512d0425104b37ce563c09b9b5499e56602d7d7d9dcaace39ff26272f6c10fe63280bd4a344788ee794bd1958a0ef6f4efb6cce901710a50dacd99ca9e235102d8227801406157ba333f27af338cb867e34293bb83c4ef4a0d36c448693ba7ac758dd5428793000fd9e69d473fcd2eace9db73f5440b201c0eda50590d4fe2852278b9c9ccfd3b55755f56775b6a2b0dcdcb41252498ea00a0fe00a6e493046ebff8623490c9c8072d361e8a5eecdf3753eb2bb2e1dfe98e73b8126c275f4cefe95ce8b7387021e887acf60677f899225805d8cbcee4202d8b7f4704ed7868ae2c35d4dee726ceaa2d0aa0478665c5b22d761a2418594b0a9292d7a343f524602d1425283ea4c7f67f4c7e35f1156218045c64df4fc8f592e522ebb9f862480cdf12aef6c030149ef2793d770af082edfb8a42fc05c6246c918710e0891f98b563c13140cd0140e70f26cc26153b58c91a54956d052f3cecd9c138a26aa23e9cbfb77573311420efa476254f5d33de8f615ded4783a4b4c6856b86485ee0a237ea92a75c0d512d9419b6092cbc23ca1bb83281f799e4b6396efe8bba4a691bf289e54703f535ccc0a6fee116969e6da30781c11b90ee502f49cf8cfe62252ba4b3f14ebb4e085f0e534f762d521d8f2189a0f96b445995cffe91131497f3ebbba9e9c50a1e19a6619546bb66ea34b550e24ddd5cb0d202956602ae83eb4c6accd3d4dc0b70691ee9ca22dbec99174e6c0a49084d4adc6e93b0240dc838a7e5538aea075114937ff7702e2e5c265eca239ab1542adce21cecab6179f0e0c4c25e163223c62b948446190a76691c016562eb15998fef033247f907baaba9e51f09f7304a6d3a4794834851f13e27603d5bad4e562faa8d98d61c6f3fe3320c4b9cc9ac131d78dc654470313426e779e25ee83b35e6a5a3de43c7ef5a2b2bc63def37bc28f147aa810e6af04715af8dc5fde1ceb83970ce9fc9de6da0d2416635621a3920cfddf2d0dbbe067bf7003b7f75b94ad353b386de8b52b03e62cab14c5ac1b1f3bad404081df17d50db07a8de656296cc644b10638ab273f6f3e8e41f289a550734bd53eb18a4fcc2c2dd29fdfea3764c65875be5c2dd7f93597bbde0a5934c271fd68b0fcab5007bb6fb7865c14de88b767e75066122458b5e8a883c86e65aa5a1f1a2346b95dfb594fafc1d157cbaa5e6ac0de91c5a5e0afd6e35d33b9ad83048412181c73eba9039c2ca9517af52f5e3883edbe9a90d50605b4613375a9fd721d3219d90b53bf70a5fea89ac3fa87f590820a8def9c59b1c6ff99ab7b2d95c40779be592ac9caee4b9aa8b770eafa832ec9775eac0913346eb27a62b287c5d638025b9dd9950b9a8ac2afc0e848ce0fc50c4d43fb9d158e0cc424ed7a1375e02a0b1c22ab222692a30799c7ca76b66f1ee4b1ce74b991cd1ffd13b9615562fa0e5aebb1ecc9f178e17d971b1e06cd77cf0e044c048c540b8a5a067e11a2b24753c29d7ea7b4fc5eaf35c58a6381a9533393adf0597f845b7aad8d0d6d0e3f6dc74d9e5c598653b38db189878331758858e97729fb381d5cf337ad6030390dd855a9ebdda09bdfefda0f395dbb30f4bba91fd192b0cc32e14edf2d37198890ae5e6acc31b0cffe8a1aeb2d8613221e65c599aa506648ccb4ed5d476f44f6bf9a9cb1c16e4b5352c0a999502bd8f565b03d8f6c4a3dc3fff115213cb074f82833a8ac44c5ee1821337caae7be7f347873f0315414e566c8480164c7d366df28e585c9106ace5dbedcdfa486c92cdb786fa9fd341581040b65a70c8c49e80f22b7ba6eed2c99fc7af82ce26041d06abac68f27562b5465a61ab6aa7e89087dc53ac1e7398c21ec56be2794840d43f9b3442794e60283745a7be05694314f669dbae2566a67566b68c3191e0e3f2bdc1121ebf671d7db61681f8fe780746a16a37305970e762b3cf2ca2f0ae3ab02751e311e166405466057079581edeafbcfe17a1709c63e0a3d00dd86d7571de017130aa161afd7d81544c29d171b8e36389529bb8233e151a40d5b580d2e59daa54b8f482853f5b62ffd7aefbdc249e7a6be4738c999975d8b6098777021980689c477686fc5edd2b02fbe1ac04f314b2f63a4f19074a31cf71e22d356833202b28d1393d17ce96eb2227eff5d3022944bb5bcfef59df2b73b41cc87994b81aa3130feb848d8b7c1ddae1b0402d53b6a35da3a44752988af6ce36c477fdadbf540400f93e152e2afc669e3255f9856735be1044ef8606ad0bda261a18880270708cf9a67d6d4448977c9333206b8232d7c7d6904ac7be9535f63e9d8348128dc3778321d49f813967f9bbcb033ad98d562dd1e739da09939c755c0e3b23cdcf3d4c3d9a91f24ef73baf68168f4afb0e33465061ebc1400557af3bf25518ecbbf4caf433da0081b6a062504c0836ac41aca48e1f7c03ca7afc3f309484942769a6d37949e1ca0bf8f2bceeefde8bda18de9b8d996105fc2703e27635d2dece7aa5901f7427015ca6d88155617cafb2263d1f761c1751a6c81e0e56bd16af9d727a1f9d1bcb18c20e6ad6fd2ced721817575dae9da3f7c88bff1d1d7156297b3f111db8090b56f71cceb4ba793a50524b37b7fc96e0230c1763c68097167c7fe15ff52132bb1ca8678c2b05c9bf24378075ecf040c4927dc54bbd9a5a207b4f3554f528f09aa2c5437dfe62cf406bc77a7ec39b09b31bcb1cdbf1be6ee51a6fc2732a0b699ade7657d4cabefa9fb9169505bfb3999a31c9dffb74699b494eeacbdc1029239ba2b36ad4d69e3d9c3b5c5a88bfbb484deb3a5555d210526fca1b8d972f417c513d4c03c09e1e8c6492fe67e37890212e5fea0807ad996b4a15242b86eb6f98afd385fcacd2959de07d3e09068c7425b5cb3e5e3322aafebd6b514c0c4c110d557fd48a254f2127facfdf4175ac62464414a4b1894a7f22afcbfed495a76790ef3766ed44ae40af86682299939c11519829c852e6a9a72532aa76b108760609a68294dd7f02908ea5014560d598eb48028a338e094e0b048e2ba5c1876669c5f21b5f28055d221b5f5c6e21a84acb372b1110ca01ed419b2a94dd48fc04922b5799dc4bf032db97ffbd14e416e65ecb940cce3529ff795363a760f9d99b4505bd50bf0b0b826848d9b1b5b15716d1ecc30d3268674eb9b01a2c1826039461184f02a7825d030ea0f37bfcc5f4b4fe0653d92d29ddb4776c42d8ab8c9a47e0af1d123433da17a730d7af0358f5fbdf4953fb72358a1982092e8cea09db6ee6a9c9a00703cf8fbc397a3024f72f815b219a24f4ec98af411e2f064bc710246f67fd89394b22e68a74441528aa01d0cc49d308ba1ebf7b161639519dbdf34a065009b9ebffe2bf21d781d03cdcbe497ec8a709c581999427d380f21544eb5d165d3ba03d6013dbcac0a0f9eac4e76d7fc0f08e4f8767b25e268aaafaff3ce975303e92109c672f89704968629223191da9cb14ce6179f328afebfae162cf8d40eba15e98893eafe80f0e2a00cf0b0296cd002334bc6350668b8894d75b5e71e06accb94ca996426c58daae67c9aae7e1586c9fada4c90b32f26abd7cc8a056b35e07413227ec56d2a9ea7e39145e4410855ae95490cc97d5120fef153d024c90cb57d1028f14a87bf1915efcecfac69130e392cf7aa034fc14d4d041e7b5c0da6b7ac93a263691ed7ac4f153557333380341d7f107dc191327ad3350fa249425f9dde7788190b2dd1c61ba8ae699be27e64b506cf9b53aaec5a3dbffe4505178cae0071c5bd7883bae8ac1539dfbc3ee6f92376dfec9487b65ea2a2085351b2634aaeb71e6576c8590b2ce9560c8104c5c938a2733b785082bb185b73bcbc1cefc9f3f91fb2cee8d2748024f388205814f327742f5168c3ad94ac2cba3ff49000efe873c6b286f46c66e0a0e31d7feb5bfd186706a4c7fc103bd36a3c493e759aedbbd3a627320c67c91272532cf82027a544e9abdde33422a5a322d6cae9681ce6883d1b8e1ba9248552a39a260dbb2d10d71b494292efd050cf071d03e70f228bcd920abb826f845032a10b6edc6045b7753b420f2f0b5675da91b18aa7217505b779075db631f15b2c54383779d87bdd79d4b1cfe3f270d5c88ccfb473576c8e85e07242f9d8af22d887a885b4e6c92dac982a30280c8b0409138e005e0e0b3edeab18c1be936b23b60da9747e75de0ea4e5564862eddfb3ebc615dc119201e601b2dedad052666f895c920bed44e488cd104d0453d8ae85a1a8acb50da995bca2581cbfa4cc94ed61235e5d3fcd7a224ff23d4b5516bf1b1142d882482f7bdcedc643995a275b7e84d42a8e6024147ba42a1ac7058860159c9c581492a8a0925b46a4be8a58bcb10459174f8e8560565180f7edbf3ea1d10b34f6bbeb0a3aed8e9223a4de2644acb29df3372e891adf9802afbcaf7f41fa4a91a450364ca10ac1a2f29fc30e5303c12c4ce3ddcdb5de7fd226aa9c52db8bfcab648cdb705b0605610501d8f4945e23260b31c3761f89026ddc96f5c9a1b478fc11f88c9ca5262e2bf1514afe15e43eeb922298790878bc9314f608f1ecfcd02318831944ee578a9cd9729c773994efaeb912eea3af1db5641a6f8532b0162bd1830ce9bf696c159a2ffcc459b57e584ecfbcd5842ab25c990fb19c265cb1cc956681f706c4e2761ce670ad943f1d96d3b5e2b877976a5f6629fb8cfe3ee182db5a0829d232e53668d217277169c2d434679a20f26c2887beeadfabffad99698db3013ecdba1a7916f1ab88b93cf4f5a5fb92204ca154fe6b3933469935fe614356f63f42fe055b65ae3f33786db6a90a3ccd40ab800040aa6cd899411b8f6c53677b29a8d13270e03a3614f4920ed7bfdaa565da96c3b5578c4b0a3fec46f3dceb71a9096d7ef675af6e57a1d0f16fdb31171f8cc107ecdcaf198325c7dde3dcb641cf3ee0b83433e445e57fef0c6702ec940754f29fe7b7d2f8f0acc3db0e5abb7cc18b04129a54401bd12db851238d170f68ff71aab1100bbb9ad9ea1b2af5b17a156b299744ee81991d43b8bca89544312cc9e432f734fafd4a99c28fffa9b45bd6b88bdbb801cdd7fb4711a43e4d89cd777bd2a46141af66b00877ea250e548903e29833ff3fc8231e4722147ce60e78a9ea4fc99ab26c5ff0c488caefbfca7fdd9bd4d246ae7e4b7e25c452288646f59b985928982d2251668838f9fdf0385da3aaacfd5249fd03685c4ca0e27998d89eb43191fada60a4f0c602168dda187dcf48afbeecef691d984ef4cd9122964065d05f592edb47f48cdf9477d9ec36d59b1f1f07f51968f73b23059158624d5fe0d840a2e7a99d50c80a7871023618edfda535732bad6f268558ef755160e41d7cbfc4278f708d6a4493221ce18899b15eafafe66dc544f70193c6ca0a990e64e29247c81b797f0f79ef11a3da6dce516e894cc3693321bf0345eb0e5003c984bf8bd9f5ecbca2db06d5fad03e25ab81245b3e4c02dc33deb1897b4575101d63d8cb2b7b204bbd6318b816712851a0119d472afbcd2f0f0772e3f16b3d7687c76c0bd2050bf5e1c7e20ea4f3db05706922aa33c64ebd6a230b3f2bce5bf23a670458c6dd35044216f1dad933be4a45638ee8b823bf64071881400485bfbeb73ea400a5be84bca751ce826b41464fd115d780db9642a74ace6350e37ec2b45bded540bd9cc406a56472b93f8e0ca94e8e06bbba26a3d6109bcd820c74f08231f22b22bbf4dd1140de3c8b891d5c545e12805cda3f2c290c3205bd8f96d1e5d28421cfc48e3d0da678b8cb6752b8fd02b74403f19a8b546a3e2efaedd50088206eee3e24761843730e3b109cde8f676004df92539086310b783d548153cd761c734e2f5d833dff69d3a5f68b124da337825494636b3cb7783eb14e646053e115835ddbac746768214a91c6ddab4280fc26dbe1cf91f057f0c401ebc603073f4a78c76364030332ef23510c5b2386b02192b30b7ce66d52d2a6def2d7fd00cadf5d1c9a7f3e8ef7a901c9619cbef6a8810120952d063c614e8bb6f97340f67c9a2404c7a3fc69f4687b7ed039045f64d516857dc06f6c1a97d31918e3b90de2f992618129a53416c25f11ab00d022a15e0b37852fc61c6299491f7980b6cea053e73bcc6d99fa195f0892c9180975d04b932d3b981c6bfd4c114cf8617e2c3fbc2bc2fcccd5c99598dd7fdaf91939abaf41cc1eacace3da9e4f410740a8a178f180325846ce68f94dc223e1be256fa445a77c5dc5e7f09021fdad227884cc7f1f37c6f91f015a427b2030140fd336554c24d42d5dd940180997cfea38efe405b6dc2224c98d71b7567d08c50d0bab5a2d9c1efbc85e9aa2c29a3b526ebd6183151ccae897450b8559bf5890c89bd426763b9f64a802e0ba090b256faf578182e610673426b0a02b8b59557578a841c0c522c1298114db708604d59dabe21f685e592dca0036a95bdbbf34ae0b9f8fdbdc8530747be6dd0c3afc110a5b5a4ca8ab0936d1bcea26ab4bdd0bf392573c5ed5879affd5172a2a02378f52e1599152d5cd5428a463ef59c905a7028bb89cde1a675cb74b578c28ad936cc3ea16c7072c00dd35f15f67e51dc624882374506ecbeed1863da3ce8e73459fbd020c9b3a2d5946c12f03e705d6dfe4f4266255919dcd1a1c4ec297544f6de95aeca9566d107a71ff8efe40df76fee3f3ca1a541167a960e289175aead181256335439586d24481a9f8c6d4580237f138f2c647d2e698edfc1cffc7f2d88c2853824859fe33b81db5fa2e67881355dc13ad095bad3bd9e04efdf2d16bddd4b88d923176a9d5c4c5a6434f8106eaa807ccd515d8ec1ec0f72880cea86ba5df70f356859e4171e3ccb55d2a9ace88be589ce9ae9838e0b26706882b90beae0d70db668f61c71a4dc371930fa99e5ecafc365a95b35f4536f3835bbc873ba4817f177350de81a7e8cb06f74cb51b45325b90dd41fc2aec6a74ed8dc2cf1082f121333de90b11dced6e4e198839cb193d98267ae310e19bffc433f7a46a8c9e1f8ed4647b2be31e916beda016b5a3db6a5b37fda6f7bfb4869f6a7f264a2bd2ded51a43a797210f54d0e36f05f3da37f6b088fde5993b34d242b2f734d3615128cc9dfd3c26571ac9fc0c3332d0799af66dffee3ff6122ced11d6bfdec86d1717cb1d8edee013a51306d47d09ede79617ad280fdd7c3f44cb066bc3cefd6cc5d53c107eab4ec9e4adbd89a16f60eacf9a80d64d61c0b365ab5f1807a9ca401a27e9eafa845e0a19999be8d3d9f62f5827d2e760bc54d5bb5dcb7028a4bbf1009ce14b5e32986d90bc8c3a7ca3461ccaa80d41b4d888d6ccd3a9e31f5b95f63d54e5db74abe5fdc087de7b5819b3b1bb54f7e9a652808c551cbb1a3864b48077d0a137adc58a39e15efbbd588d0144dcc4711bec1f0855ec682e6eee8f34f963bf63b2ada0c3d8aa64d4d9b90de5ec40fabcfee50dfbc757a35545e4679b93dc34be3370f58d6a7726fe47b38ad5478a3ef5e022d87324ee54f93aa77c0a94e7fdb55ad3fcb4eabae6866c45d05758234527426de51ce9b36c87df4eb9f356f28144a7312147679a270b32b37220ed9ef8275e8337c721dd78e484e1931e4e51e0d327bf48e0c8ac716b2efd936cd4bc5bf06c7ef14acf445139ad706204cb519d0fd15698fcb32f921e38f5a53b91db0e06c74f17d978ef1a567279e3a6b62e1af596b395d50fa8182e5b21b97a90c562a1e7fea7e7d2ddca38585f7e0ffd9bf84b6d0cd17b918eae2dcddaed769a2a21fa9f78ddf4bf3efc00c6f3257f208383eb30d3c49c72038d781a359285c618e81447544f245057724622d52c25be030fb588bc478bec9c638beac29cd93ff3792e3d84a1ac58a7b7fc4160109d55c53bcfbfe7ef5269bdcd2c9343d89b8e095976f5abf3411608cd5f857a9c4f146c7956cc8506d60f694904b22cfc3665bbcac6e3cd9d825773bc011fb708f772bcea48f84a2c728d7ef7d996e2c574263dc954c1add023e7978f8e461dd929e744d17ee4f15fd42e7f7e1c377b9e6c1a68cdfecf81f7f6977919a5dd85cb92980ff59a47337e9bd5406f6cddfa89db2b15c24b972fc252a76a85d44062482b21f0fecb0230185caea45811e3c314281898fa19acfe0da3754038449aff73c7d810f3de8083efd249c3d8bf297304b72de29ccf91dfeb289ab699405c56f8a0d721c52290f82b5c92040e004192f4fa1adeb355100d96020369c7b6452e7f106a16daf2b0a0474ccd1a2a1ddb36546124970122e196b697cb757eebf79666a8542caf56ca3446762053505a010b6f2007aac8ec3f61ba612bd28c4c3d0a0979d8aac4fb9d49bc7b72f4e26a138c780d959526c55e289ae670baf8935f4cbe2936bf3d6925004a2d42cd0d9aa0e7cf00fdd5df9d3523d8e5f919c411af4fca804acf02d97c6800e49463ed496853ce67d2595b717a6c940d6f8e087ed5edffcdffe52dcc69c4727666bb297790b36ef7e018d3478d930d069aa8845b5ff6d2d2cc75a03cf4c285c1bc5e105f2d413bcb48d21ef9d352a8128fd1e634f238e47d5a7c6031563e99eca64d6eb258125b80a208fcf33f26d9b1bb99ee9aa920f17a19954d0e70a607cdfa8459065f899c379627652140fa8c59de00d78fa16aa5fe76d45fb15a7f7e475a86708097dc40cffd46c8f07749f4ce87cc4991c15c473c632b509a160f79dbaf9793ce85e82f187d16e74fe3a30ceb933fa8e0aa9eedbf5e2e120590aeb0fee9ba1718ae88b4be17a5588a01dc8a3fd1bd3962c4ee96e0ba36c6f1acf067e6dea0e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
