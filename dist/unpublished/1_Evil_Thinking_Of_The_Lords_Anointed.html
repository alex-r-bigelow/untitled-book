<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fde82e2cb3217de3561fd7a60397414eacfb7595c6bbff8b21990baa5b395030c25593a8a7c68c18653152fb5669b4c6a431c9908374739822dbc6fea3d5eb705a792b8400d84dcf44a62ddc243bc06423bb7dcd0f7048e36a470a99ee43791fc3e14c5dfa4002a16ec3c557bd3f5f1b3526245be631bce064e5baac59d5e3d35781104aec0588272abb6c3c7e4cbcd924bb9eb00ea8ec064f22364c5dc3efeaaa6233935a030cbe4b1e73dfcae63a05142ada79664977f05f862aa8f55a7922e270c9234aa441414889b025876b245fefed29d5f4c5c9df5fb06fc1048343b3a42b6c152a44d139c8fee2bb4d6950c870993a73098408c8158cbd8234d4f81c3739f2507a1a2a9128111ff96298804641985cb6f56261da5bce7a8f2b3883fe9e5c686bb96c43ebbb449751cf640c38a2c7e340bbf5b467c13c09cf5a965bfc28e1108943db7f2c5e0833c973b07dff78275584bf84ff316a24c7452cd71457a313748bec21a27598804a300d2906b9c7d3d3b1e93cc6992f36c8a009d307e1bd44dcdd0bb377b2f9d15eaa51e0729a4a48efb7a8504614523d99efea485965813d624b52b562a8bd9ebb2bab4bde5d1feeeafc6615a741604d85aa464eba6a6f9af2a7ff7026e058d3e7cdced6f1de37b032f6927db708c49c7fd9a161532b6d4be1fe154f7bb5f29777fe5e98b695c4d3aa2399bd5536043ebe0e4bc4c1f9d74826822be177009d46b42c1b63a1aaf0065ead02dd3c0eb89f73dda8f6f7b37b4b5d76d9b00eaa9cd13ac429d7144b9d976cd2a30a27cd8c4d79cf9e902c4084ec61c33239b2efffffac1cebbf51857f6a4263f2ef902b9495f36b3d39621b4cdbd59081f61d195aa8c5437967b572706b446159c454c092f63882509a5856852f23e757542d43967b80c0bc7c107be634a52aa28b1551fe226ddc1fa870e46c556783c4bdc56c0a3103976f26b6f2a19288764318addb3e6b91879f262ed2c82d56b752788e84aeb6e387dc64f8a0b8346c4b9b375bc5c0b6a514d87d05a1cee597651a4586750db9fb2f4f5814706f601149e5f09b420c75b522b59d7e130f0ae5654dac8075c60f63521f684a7dc8e5b09c5cf803c9d8cec2128d03f1026930e4c087dbc02c76d004670248c15515c58762f04b883c04c00e036c8776e29255c3797f161088b688d60f626f637e71e1af62ba234b781f98398a1d85e1ba7a97d8e8c0de54bbdb663e087a3d784530a354ee274358f4b824340983f1de8f64b0d5e50fa8d3771da148952c37f4d6b05e70f0b66e8340ab94908d11a1196218322475b7c122d3ed45bf1b25194cedbcaad7c62c6e4697ee1a6c575ad539235c1f4d9ad1153fd67abf3a7f07c3e460f8a2c85e3f0f21aec17399a6d783ac952ba76d0b27c87601957ddb1082bc7976356df84d3180a6c89aee0f8d73ff3bd98230210dcf5be44633bdad607ce98752a0b9b4a57f696a30a8dd505195faf031d7d348a042ea05107ab080a881e71e0257e14a6ace5c959d4f58358974340e89af725bc5d78c3fcfc3fe6bf8268757e6e74a7ced73a18d803f440871fff23c2035f9317ce8182cb0c487b4eb892c5c06ad47ce3b3e471a611c30679d751d026ea52635429ee885c8b42a20b46ed9069c2a6b420cca03e3e2f4ee852bd318af59c2f8707ce5c4bb646a659a15cb06b6c1e6528ade112028facdba4e52ce9dbbf3db7fd2feb4e680bf0a155b2be9057aa1b51639ab9c886570786ea2178763a64660849b0d29c638639310e8adbac4922be253ecea6c1308ea484fd21298051b6c4a5766e74ee65029c5c5be2439d4b9b940a435731bb12bc455c391d19857c13854f016155422bc1f065308ca9bc837d62bca142108ec53d3dcebef64a26857a1472ca5b9a662d37215453964108d325b4fab555a1ef7c7267f707d5fd18abff72598f8608f12dacd6fe28e4be250bbbbe3a287f453d8f665565e77c32b152cb6eb67e360e74f377e3d41cef545e7093f5a00447c3b4cb0174be0a19a4fba6958da464f55780267cc52d8eba8821eea3811d2baae6e5f4d970c6fa80edc1d93c4f5c75249f0f04271a16c24ae625b2a6566c4b04d9c899810809ca7975a96707edc671ffa89f3e2d8d0783bde1efd81443791db3fcb1026a767b770c0eb009735b71fb67269119530e43f7b372cbd4415829fff868c76a2c6158215ec198556d6943fd1aa0cfc975113f35f6ba2cff5c3ecc8431f27ae2582d58d7be1600326c09899e6892ae42caa88a280acb6d508b3ec19481249e288e9a177ee7a25af1e8ace06ea389b91d3a0257846b6e2b9de2ed8456de9a0267d5ba0d75dba216559ea998f20c49ad41664548eb9b5f99cd76fb7aec2ca9f4fc7f8345e426e5eb43242b722ea528cf5da389b9a1d36a74efc2f21a73d9a4d28316c8148eb06d9732942a7948d58d094b5f6ed19ec13026d9ae4548cb22610fbc52e2e6e1045517dce325aded049704ed08f5c88bf12ec35bd35055bf1cfed7344bca38e34f6be1303e2561440241fbb217bc9adcc5cf297428bf1bebd4e83a1a616b6ed98f7018845604d784b3c10ae79c689f6c5a78804460e9830eba6f4d7165644b336bda65cb683f93fc6f317c1d898282d516525f2223b89a680448f9774e12bb3a34d873c17778cbc2cbf77ffd17e94eb5b09f640078be2332db84c12e64476d25528022be1af276c8bdde83336c7ad44e42cf6116956c620aa2d4831e53756399fdb23333559174d3e7d1be0f3aa1b2b36290a0433aa47e52ff2bf4cffc81c1cbdf8951971ef303f7285d75228dd5c4a888389eeffe64a4c4cab5e11c285892cc0f7afdf38671fbd239d504b7ad33556080071cc6694a8009c5b0704e001b561a2e835826416551fe69a4cba01f7f7213bc3a946a27e958913f3f4b4194a8072e148e3d818943e50d9db1bc5008dbc4988549ab40e344e6640edc20e95a3d538d96731413be32ee773512f9578833ef353ad4f346ca48364464d2a6cc89391d2b8f3442e53f352b1596dc1d56b3c88c7ef1ae41ca689cd7179c130ef008d0da9f5c5a0688be543f0c13ea5f4c365ac5eb9f1918ef3b0ff0972be8d3923f5d381a263bdada4c4a29fe76dbecd37750648d046118b53c54b3919b6d076819967cc751b1dcf79f5f5eb6d165db523783fd7c9e7a485b931096fdd3b550336b60fb421c92b02e4a74b56b8f2c631e3de98474c46310c1fea4c4e4d214558e69220845a60e76d4fd8b454ec1f7e95170a72574136a146eee6d8bea8dc685c0171db542c818a651a88aeebdb0be7260338be50a7a11fd8aa37cbfae9b81332eea20f67dadbf3b1c0d639820c77e25405a68f657bc1ffee3f1690f6cd5ad44e21d0d69c85e27c3aae80d951043dce896a020292e6f3ec92bee9a7b03880eeeb2ea678ace97118ba742a2aa87270c4eff58ab8bed7a2beaacfa9663051841f8da11114e91a9a6cff7355f68dbec680c2b96a8db7e8c7d348f07a90c2c2ae3a927e74824517f5966f2c07312b7bf22ab9cdd6bd1f23e8dff4057f79cfb6b967c95af63095d040c2f7c34a0e15329621c14ad984a693d2e4da3fcdab3dc58352c3b8b3719e5eff197c2a6305d469297893e3bbf4936762aedbad03e50e804316cb532994d57bdda28e9d37cd591c78c6c7d979579656ce36bc9a9f4f537b8d1398cb790d3977f638a9c5c0e214fda6af9969230eaee3a510454e5c8e9596df08a8b8df46b90436356a3cd733a856913479dad7c47f55419d4bb9ec8a7820c08d197bae1a8808f2f6c1fcf57dc83643e0a439ef2e595a85e4cb771608c95791e801372c8df09bdcb676e1c59c584f0c22c46b696b29399679a16f9ea3d4656009ddfa3b18f293d07fd11f04fb69c5aba32b36a3b0daa1fa1e26eb576a52bb16b2e737e0b63febae2bea7c343b8ef7be44b09968e34c0e43c8fbbaf1dc0d1d904a990b478749ca8a3b052786dc33cfa1b41eebd394a34c61f7b0602a40c34483e7bb3a63cfab2f0df1ec6ebb50478192f057c5714ebd3eb2b9d7688801cee84fc6b7b9688ef8f042e49ddc169a208e07b3a70b22ea62a5256cb23c737807a377aa96f7113949a6db1df7532f03c95a5635486083cb1dfa66dc9d26ceb93d521afbe500e4cb071a89b9400838bc9333df85abc9c4bca9fe4033cb658a255d78e560786a85d33dbdfebffc87371a554defc477af101eca4079ada04407b523441bd2c25ab69d9b58fae9a50807e9e40ffe3a5577e76721f313f470e724b9293d472edd073a393e99c5d3e0c5e0ef839e64fa49e1470bbc4093b18e51ac9c1f7879fa2bc6aab28b817857399f6de11864666c292cc802d880eceb9f53641ea79cf13137c461a733e2d1ff955875b80471373111c2e310206e09afbf3f01d97fb6a5a5cba1769ec4b4bd8f1965583281f9385e553de3f0a24d0ff0a3a696d3657f9f32e31b4d49b4bcb4896b3c0775184d6c98a9dd4d89ef51e82306e0e1895918700208a7a73886950e2d09eb492d8d713b64dc2b7c2b89d700c183d7de4313fe7f36627a4aa34612ea90626b68ca7f97c96127e88fc8e80e7eac94d913975012e777007b35a837cbb2ae66e44b021a84286a6e244ccabc19afecd99a07322be64f7eff40dcfe7646198358069ec5835715f006016e6db76246cf8e6937ddbea738d8dbd3a7fd6733834ab252d7e86fd33e12a585b27974c1054ec060b9cf3ce8cd5074a314f4865884d2e390c7ae524b212bd5e10d65a01e700b770494b8cdc0141512ebce5c8cc795957311481b7d25a8ccc6424ea5681bf4c717216dc7bbfbe58251007c461808bad59ba902f3a06fa2ad224b1293fd78141bd2b7baa50ce5ccb37756ff803b0cfc2a6eca89c30ada951011948cbc042726195ca174393c819ce0f46d073a56afcb5a87786eacf5ac2b5dfec70d55c3f7851ac05b171f78245e23d39312d275bf1bc787dd68033bbbc65ae8eeaeee5cd7f1aa72e8e6c13b3251c3651319dacbdbd427ca93122c453d34296fd9db6e877d4c59054ea42ceb46bc9a7d769d7af26b47d574a3ecfaa38d92dd6c33a604bfbff7f91a5d1e516f54c4e0bf936c56cdefd078539c09806c5053a5a9744c1761609de12faea4ef88458ba859c08e6a96ddfed940037388fafca9dc023264909c6c8a24aa00ac4db1593c0c54648603278143be5c29fb78be8db58b987c52be89d09d4364349f8b5628ce1a4368cb24ec99c1be642b5717a7cc927272cfce20443c6f417d7f763474bf8faba458519b5a4b3af3d410494510adc961dacd76045777ed0736665bdcae8ba5f6454b214f574c71f697973074ccb80d8ef40136cdeeac50d35aa5a7ec94c62f51ca0824d2ed08779e2e5c077204293269f750c0ae4b48fca4757025a345ff30d50c9c0eafb4e904d299a6ec91a0f8d0a3c3bb079d1bdbb8e6cee6fa3b42b4c7a40c81cedbed90cd279420f7349e857990e7f24109fdd45cc034b11cce6fa612ea868ee1a057e0c154c1aaf659ab22bb0fc5b23e7aa09fccda4e82fb01fd072e7877f66271d44bf8fdd2c8f5c5fad39069098f3fac2e24cc3dbe1ddcb15a32870bf533d9931f5a7325f4cf6a492fe00e4095e518cc52260d8e021003ed7973a892fd75aa3040c2ad9db651532ee4e0c38921956d31ead7c55fc9a308effa979db3173d6834d6472513eb6524927b2c44ef0b6aab590660ee536fad8fe616512408fe97782650aa3472d7c34eeefbb0390077b836f870e222bc84adb1bcc8520fdc884fd5b961c17fa3336b76d18c80354c5494790039d882ee0384e6481c6e22d532bc19d8384fb7e43ec1df80d4a6ca1068233a5d2785871163a23dfe4ea0187af7afd96c8afa3f30750fd8db56ae1787819b88431c81b43c15a2bc09d84792f7e79f5f4d6d807119c49dcbe0ce6c8fca50d12f80566362656e1f86247368efd64a58c92d67a595e445e64b4de347a6dcb1286193ae2d3d1085d8f516f5417f4c924ec9bbe9102f98a0c000fe903f97524ecbfc1c75781e69f70c45bb0bc7a066df20fb36596fc01c4c78bed640befa3101c1deb30002c82f98e666b7784de22549ace6144b9132f9a969d543f820f01080a6a29c751d5658e93d90b56885fe3c480e6f1498544435a633da9a1ae0be763c47b1df22790e2766bf840243f43ba4c3e7e4171b0f92ad7efa0e49db41ff3e5428ed97005cbe9c3dbff3f1b05e536797994910176cdb3d6d11c0ba2411135a63a07f22818cdc4399562cb7ecf31a4c865e6e574fde020147afa0dab10e0eb04f340712a55341f484280c9d7ecf3555f54855fd04c8e86f438457da60c1cc56cd7c4587db8d8eb3825962444162eb9a9a4ba3c91e947bccb08ddcc12d1315a6e98d6e11af3cb9c35b5ccb5e8ac2aec0615f4af5eee11223c4b163cc1b7231405b476c6a73377659a89cc50fa8f466b237859c3f378e625b141779777bb6a136807f52bc7e2019e07a55777f66319a627d5f8457ba4e8b136c40a2b750edbe3692594f03a20f5b90207558e9e0a05ae322498463c2b7235e78b6ec668010a9e9d97b44050965a918bf2041396515565c0160911e6d8c302b7cf8978148a0fed4ebc09ab941a1b782cfa5f1903e50da75832a661e0fddc2a3e0463ee92b4ad486b9c7ea805399be138a5c9da5d9b3c7f85b23bd8300439bc706c1b709769ba14e422d04e6fb6102dfdf6b88ac7d619a9d9061bb591edb4deb756e76a82e8ef9159e79b8df4be027c1effb0167aa52195a1fd950aa8b7d219c7d556ee415afe4abc51b106d307dcdd70d0514a3c62e7030f1c0f51dc52d8bcfce6c3468e3ab2bd49a93cd6f9d1f5c9b5cd85f28b17b07fbc9f03c4cf8a860fddf0ea30a4c0af4b8aed05204530e45796a410ff89f6b84bea49d7b2e7feea7bf35ce21379c77601568b6c55c3ca17d62e34c244a63ec18d3b4a8cc2b227cf7da55fc6cdcb106015050cac892a11ad0e4404a653eec592c6dc02b655f405301951d853311a3584d90cadef47ea03abb85134cf8d272c9f07e2f192fadf3914e834f13fee6980f5f604b58f333f11050d604c1038890dc01d9f2c58e56bbec521e0a37952250a3ab73f352f0e4d9c8a1e95d7e10d0828e5265a39d32b803a51aca763eb980b191e693779dad1f509e4eaf40060e118b05de04535ee5504d6eba1773050e44dd49608a9259dab6793f05b04cfbe13a89b1c590eacfc83d49a685bdf1b0a9cc3805946196a5cc24c320143c90a6d83f4ea7abf250011727b0966d0749524f1329149994ac09d29265a2ccd7c9edd049ef2d87037c356f95c6d3791144adb2077e6dfaa26d05e4cae4237e24c57597ecaa60fa011a0f79d7f8e387c3460a4175027886388638a0b6d4d802298eb5cf2d6a54520ae7b6784a14923ceb6b45655e994b7e1c37b59cb389629021212b6349db0ebd634efae673bddfb79f31e3ee3af2757418e0c35ac1cb98a64460cf6f6fe3365e300cdabc0a74138ecc3f79ee75982abd3eb435261d9112508726857aa26385e162bfff84f9a45dbeb5f0e5375d93fdafac751472dcc27553e6c5adc0ed3a9c7bdd0f8500e5aa0a1edf7a58f20868ce3ba14b2786532289d3470105a6227a9b5f715b2489563ecc1b365aa075bf3270d585f5d347e3cf74d51486ce5fdf6bd39dc9e11710d4c3e9d321edd56978b5aead217945f674b43d9c3af15b0097116d8536ef771ff652871ecfbbfc2537fbd668d9efa3ac18cac442736844a0ffa7d170b3e97967e5c842a4e38eb3cbd1c22fc024b8e29ca8ab377209cf17cd68b1d660b7f1ac04ba26aea642d380c9aedaeb712fe062a1f1c51eb2813414201172f5e8f7e1231eb00d7a589f802c5d379460e3feda9665d35c4c67d5bcdf87c20b64e7d680ccb95efec7c170ab2f3f11a034b4cc10dea098e4dc2a9d68b5900edd97a422eb377710d482c6516635daec38eac8bd2056d0102e2641ccac489224ed51bcbafbf76d978effc8e985b046258ae46bd9572612cde3cb43b5020eb056f38858e8662b451779e46ab61a79414ced4602cb6c55266e9b9c357fa08e0af5e9b87e48ad3ec2b6246465a03e89647ed264a9a59e794e827ed20ed327a9834ee4aff75e3f1d2dda1f76ff8af527290935e8f6f2778984d37a5fbf5bfdc6f411f623964c1d81e75879b968acd745969f63e0ff7952c45191dc05a0a023f95ed0aed462d7db4d6f6436e34f98500057ffc9c403e06a8dc0281e860e10377fddc7707fae490a9577e8d0c6ad7d69c1cf1cee053e5c641859120bf8a3434607b0e53959db2c474f81eba582b89a9199bf0f89401680e140814b578881b96844ef2ff423e41eee9b1e3bc4df372e6e0bf9c76a924ad328de2584f063b22fa0278d337ba653510b146470f0def5fbbde173f714cdad2784402751150f28c622980562817feabf53f0db2fa8809e795de080be8737f1dbb8841fadb16fb72210c107d3e1ea9fb6404c305043f0024bdf9fb7c303715fd71beeb73d4ab0bb5a17835f8972e95885c6930d180f95401a04e99e3d8f98d4a790e89ab176f2cb46ff6ac6d5b24ef9e31d29ebe63b07b1120b233be5df86cc855a15955e1f66ab59e3ffd9a53fcecb0d35b29a44c1e77dd889e0d1887f40f45abec4497299e67f78fbc3fb41cfad3da220ef267fe976e1521d12817757f68d592d9e6a1bfddb283b7672454ad892a321eff888dfe5cb7baeb495ade04961570f8b4f59dfbad0ad29f7d15a212318a1137823af9847a90e899e41cc76383ba03699e90bfaa32efd2dcd1e86c5001769761b0f9e63003c4eb78a1fedbacda82f87081b7c45a0a9817e2b8912ee9c88eaa2a84f6ce34eea9c10a4889547a1d70e37022e9b1c7d97995e41642f89e23301fc2e4caecfcbb2df957c54e9a3d8c27e4e643c5e971cdadb531fc5b2443bf7272867bd29633769b11b801590728398240c997f6745f7555d9caca0c443b878f64ef6f1a041fac961228f5ab9fce3a1cf2e319420070bb199c344eded44f78059c6b4d884c2f90f90a050da0a48f0802111e62dabed7596ca9119cb5fed93814a2dfbfd71814064b2ffcf5b6713053ea349c7db7d6f38d1365aed8df1b39399a8bb85f52227a0ab45ace5b33af3db266410113323f121958c12e9ba2ac07723f1cfcb53576efdd2cd55561215ffe77bba8a73478cf891f9e8b6ebbc1f969e0ac66b327bf1a17fbfd76c54dd53543c46f871d3ec8d27c705173f9620c1ef6e46dde52307801c0422533a7b8459ed5ecfa24288046770fb818bf9da269c53c84cda0653ed3dc50500cdb0b71a12f710e57c265a66f61b6102c99bb4627209cbc4af77465d3f8367aece674443bc8b039a9dfbfc082d8e413e7b470a8db9974f14ecb969e434096032a1c7a05a8151e449e251af1f4660529e081fe4b0d2958e35f05674879340783bc2562120e64348b0854ffed335cf1be7eba36d422c7396773f7af6f4a9ec5ed26d2a0754f41fb40184f8f5998ab59427949d7975ea26cf044eb07b2bea04f39d0255e17c9d4e70359696d1f48a3ab48a3b74dc3e7b7296412b6a4f04b7d1065786f855ffadf446fa75ea6b92f8a854cb813a1f323e0e5b4e3ab10e4b186326ff0329cba99f45b7b1d23332d41143c69fa1eb8e23fe8e3207caec17a54a308fb8fa7bb8744c540dbf808f82c6af8b5647af50f809c994f6e91e84f33c2b4fbf8483737d0a013dae7847f70bd427eb296a86dd4852c6c9e0b1838d318a023c95b5d2074e66a3f698a144f70189da4bd43420c3b1b3d491aac9d95bf27cf437eff9c2a39176db9e586dbf32d0131fb76bddd85674ee12e6773d579e3c684ae5fc47c8aec639bdc15bb53a30fd5ebe3b5416435dc5aee93f607a64a8cd4f7227773ab1192f58b0f57f787f959c2bc735c0afc6363fbf654f1c4b49af0c741e147de95b38e39353d3d5e0802e48587d94b1e953b6262955896291cbd959f099a68383eacba33e9198c1595e3c52ccab298fc1f0149161f81e72967edfd241a01d726962e12fb68b4d2133c8710cf4ad959d71ec57883f04c69fa54fcca2236794dc2a8e80db0be20b8e8ca066d3d19336eda3cd3ec224b62d621ef38a864a02dc2547082826a65bff2b8d17f93e5ff49d6f188adc1fe583e4af85dea08f132fe45247d7f304907aaec00adb819188fda0fac14f4e033fdcf8978124014f5a23ba5e7834419a8d1b5f43325aa8bd677f9884cb87d3da3558c5f1fa2bbae835d0306e48e028facca9d3fa8485a13e79f534b18b647bd0406af68d4707e19f767b5c084418ecbbcdfcb264e88a4152664a0eeec2de47103b12ac39612cf39142bf9397ffb33382ffb02a72aadfaa98ad9f25b970d709f320f65341e370b2813940e5daea8ed39f3b78d1dcd322bda43e9aac6699b7f9fb67f759176233fb93afca6ffed78fa8f319c83d8e2cfc9950f1379cb0450b04e4aca46b287305c2354a2e03da337ec3d875be3f052b8a0d5928e4caaa96e9925c470b2931037653e5ac92abcf658add3b468cf900c24a477941331be18266409bfc5ad0fed6f305a3aa7b3020d04e9007b1477ee45ef259508a55087f00777da4485d5d615f984a6557393d95f4e6423a2205c1de62bcd88569973bc664e52896d545a702110d944e10d0385104282940fb29930ab17a316136c58c99e0c5088b34c13c60e375e96209734725f66b0ca240f30950b94a8895c7b588f32f8a8949d62aa38d95a659cda01c95d84fe45eef6c9c9f96653bd6ecdc417abf656b05b44e71823f7c298e46f4cfb50d96df6b631055e43da8b78734308f49ce01b2fc3bd7ab6c9504a5d4ac63dea47f306c43915f197174476433dee2afb73efd84a87c8bdea1fedc37d984e337aa23017a9a791ada90d40f36addb1ea0ca71dacd4fafb4cc51291bfe220c47dad3c0724ecab61f33c53e9dd852d90ed09074a3686fd11c5baa0f277055ba05e0545f9b8184cc8583dfacd5ff1534acb5ef9c6edf159870be0268d3aa81516ad24677e699659a6ec3cce5ab90ca2ca6f12f1e75c64f1c2a0eec807b71b99adb26f631a2698eb74da4d31412b15bde8ceeee5567bb0f05407e46ecac714520d05cdc91187afcf93b290368951d4cba55c9add1937696d9e27dfce5ef84b586e09e1b08154cfabd7c199ce6a17ff1f684d0a6300061079053fd0d722ae17e402bf6eb43d7c49d5123169b5c4875ce7961f12a1552a919bf84c778bbdf35691a18954e5296f4f8fddabf20bd22ac800953d7abdd863d26fcfd9f3f972a388d99bdedfc9579608e934bac135f78eb9d3121eaf5bc1fc9c7f72ead1d4a1641e47c1481fba7732a450890158719f9f6a3864e4bade549fcd6add58038776cbf462593b64bb152ee2322c5de5a30d19927753e2696dd2f57219801d6af8b8eb65b4c0ce69050accd3a4480c99069cb9a628f2e65be3b3a70c91b9dd6428d470fb5801016fd8fbdb152142bd350ade1ba2522422a055828fd0d624c386f8218572b6b90e8679886616d4dc80c42fbf6f1a7b0ace7b72b63fffd1b95384306eedbce246ac2b5088410c76511f65d2b5f99d0574f3fd84c2b957cef5e4308822cc488d1f3f21c733b2431037c65a4d80ecfd0fa634e5b72cb90380d05c30215c0d52588ea14cad581903dafe334e4353520de69c7c6246f90645031d9f315867318b78f26a68c56f042e817767771d7390ff3fb9517e877370f08498eb6d209e1174eb962ab2ad58aa344dc1c8f968470706341b9268c8d1525342f624fad54944daab399b8d027c948d06a8cc22654f04e521275035fc2c28bec01a27ef7378fb8f59c1c9714e45224c15d6df99e9c54e3507b6c66b0b586800e7edc45178f1363c1d1e73ff49550cf6a63ab75d77426bae1bb1af24b64d1f808080a84e806ce28ec8bef72311dde0ccbb7864464f8df9a7625641613827fd62eefb0ad8cdf628b1b3a893b3b81be2533aac0f699c7fbe8628a464006decfe592e558f1fc98466e55706641fc86f02fe84bb51f10fb0bdd74e27ba2e49067ddf72dbbafffe017212a9a554e3c0269b40a880fa1dfc38e5faf136542ed6e07bce3d1298c433b2a89d2610a17d0638314a3d4494be0647345651a877ec682a1f51e1cb40618a765395934a3242800a184bcc21d856e76ddcc6a76c3be01d57c1f7202a3906acb59ba300c25e5e6942e1d3e7395e92d76c06cc3ff692db6df8005f87a10019c43cd966d62814cb60ada360663414d73b999d5c89b6797afd00484be8f9735d976a7c71243eb71449dd97813e0e2ab94aafe899730a3170b5de6a28a955c479da451794bdcc3c6edd409e4db80d9190be50d6791a77682a1b23060cced4aecacebbc62ddd5529736baec89e9d6b77a9a4873474232bae80c22a07eff22bbcceee36c91aca46f15989d5732be04dc184936abe6457e9ac7b6e1cc21e203248ac4aa5e635d89e76985a2c803106d82d3a0dd5bfaccd9d545ff73f2273356c75774a5c3f12d16be04507d12d3bc0d7c6a0deb659afbd5dcf1a558fa826e70bca346f7b85ba9a3c99d3195c80cfeeb9fcdfb84fd2851fc161eab95bf6a05b53aa9d827532c6c3e5d5b0e9983494f7d120ae2d7d9f1e71265b843013a90b8ee12d6d0aa8f8a350b3e9112e2bb58c4ef8a492389f7fb858b156478ab07fafc4048828da3f27bc7c1cbd37df7a44b81debf0e3e89683a0b9feb938efbd43e60a43f1058d160698fc2610b44b4fb589e7b761323718e1df469f4de37c73bdc36be6471e98bc891dc952fda7e2831443c3bd29a13d236ed096953045f2b21b42b2686a1c86e1eca5208ce025f7c44a267878bb4fe48e2caa18f6ab8c043e8fad243491d10088ec68d54c4db619907e3310ad9415f29ddf5042b2a9791dd8ebeaaa73893d9d3d62b8725d64ea55b4964f01a1d0d49f868c0f57bf5fc5b792b9b5c22ec4cddef356a405f077d534b7234d575ee801dc2a19670a1ae5ff6671e9eac2aeb10e3f054706559cc5c6cd8423619ee7e224fe052769e0c86f6ffe15b2779b7029e94fee1327bd56e7c70567dd4aa0d23002a012591bdce87d63a7d3d6264c88be01cc2b7113bf1c43c8f21d3bfb63472c441358814d2a6d759de48c89e69279cb94b9358ffbc62f7a303416a96cfde09ba007c57d8b8f50505f99b7002d88603f2288edc3044a4ac74636c6bc937a1a281dd1952e9dfcfc74bee7dda346a34a82be360b4b1d990265be607260c1e1c6b1e864abff59675f2e8e429ca90916a31a4cd4a0e32ba944785a04cf3f504f3d59b83465bbdaa0441ebcd46394f653ec2bde160a60a1af6b35f8fc508a349374ac9cf0d6ff5483050c385a479aa8378e7ec7484dd1304de083cfd5cf1e947309d40af776e7b58d0201c3e3d034d288215eeef48eae65f81e6ce34070ab1c72900d6b025f3fa7e4a3204e62da79d53da64552504871b9185450da4b0973d8a4fc4223c602d5a7ce057e25dbb124704d3768b6b46b039fd97677adc17729161e6d82293a5757efad40636326339149894a9997d47baa8fb37aeba6aa355ff32f6ade38d23227c2a7a07b24465613822e13ac1938537358de063e59ac5cfe8bcf95343669caa3bbd81313aa78295c9fa27595be92a4bef6da0505dfed949d3f72d5b5ef2bbdf4e63ca6c98d855f5c2f56152ab18eb9340db8d764521f52fe80f4cbc3d0715a2321b1194f0172ab34716179b5bbd041eae9a2faf6f0012290cf8b266e1b17d25b484a10ac8e36d472f0dd79f6d8ca040bab289eaeed38c5a2056f0ad710d3f6da1edee45eb8d2c9fa7614534f06ebf79d7b7e3e1598425624ba9affdac2eeca83ab87d2196f3b5aa20fe7e952d57af1c444ee53d1ad03a3074cf24304962773c8dd007b0529f0c191bf53ab80a86ca59036b0410d2b9576ac06020497069784aebc6afde994a21654fb1d68d4557f410fe33d5e0096be7dea7a6e0cf33e6b6469ea4559e262b7fee420413f356775de900a1b9ec11cefe67fdf5aba28f465a90c941e208f46d7dbb072a245c4bf4a3f0524555b07ebcb1a4afa358aca180e1a2d4133156868ac0ddde8e0bf2bcd5383d6a4ae8ea0da55c73f3d71682065300be163c69ed5afd47ceca59c95942d60bc1d9470fa5cc12a60e47b9e2179f6c7e55af43b3f0720d43e97930efbdbfd565e9a159b552527851c40e0b4851edb9c4550fa458f7d44381c321b328c95a89801015d11c2da1b1c9a71fb84d4a1950600c1dacbb5996e4673ae1a0bf02d5977e11ac4e397f6d5407f337256c0881694f00d7e27934d73f6533eadd28d0225c425ca7b685a76ba427d3dfbc123246045b49a47e3c5aab7a7d91ae86abf88cad8113009100d9ece20bd1881bb3d1c232fc8e9de6d67019218f35bcd686b1e8025a687ad1d2b2b7fe1bdb79155cf6bf3233335613649641c4f7ccae5a15016eb715834f9d4e4248ace739060fe422f682591bf979eefeee3f1c7ef425c46b334fe9a1daeb6ad540d2f4a7bfe436a75134c7937b9106291126885d439aba6f5d195319c502c0b1932e5a69ce80af6b56fdeac02b2671b369913f7ed6fe2e143d55e215fd21d9ff8e6b280e4342aecf4dbf3ddf9e6b197d8ed21787736d0d74d1fa56753ca80887364b9691f730ff4592ca3c3a0ea20f42ad43f9194e5911493de70b95377ff05fdb5bc8025d7d1047cf5e08458aab984de2d6e2cfe6fc20071badb618ecc362cc788ab3dc6d2f95c4d9ecb60e4f00b7829743f3973386a5d05216281bcef9540e4b933d51d6efee654e69b9aeeaf89d5ba780796f49fb69ee21630b1e5a9ba4e1db8cddf16617b67859afa5ace1cfdd05380958152807bd7a14a8500392c528724647b710a9207e43b00d5c3ebbb51f3ffdaa4e66a44c3da6f0777c02baf09e318f7936bdfb26ee0e900d03523e29547129c846c8fff9e053e593808afa01f0aa3d3a3aa8e26269d7ecb0e62e8b47f51f99642f90ceb4de894dcc2b2cff473f05d0df1beadbd121f9a5595053d24fcf219e679298c4e20b904b1b5c244b8298b34dc0f518e5cea1c4c7fd2463db06b626c9dada284d593912ffb953e448e5d8b3a83ddad52ac8f40b8197a5fc18b38a5de005a61ac67e5512b4957176ca56ee06fe6ee72aa3e802591372db4b51f9a08a6df351052eaf4a9b283b282af6efc63c9cfb29012ef7888f7d85cdb92c8f188f053ae6216fc0cf0a30f7e429b6217d1c620423ef457fe688cd57c739b24927ad9ff14ca65ef70ed73b66d275cf5577e3d5352c7e25490b61a968b89f2354b86153b06967d6e15b16368b203bd49b036897fdc075f97ffbff7807ff247b327f62a174010967d53b5e3c22b86d26958ba9a135801285fd23e941af24cbf38803c8e0467f092ff3542eecca9f55ff644dac133cb99eefd4a8f53b9538b344551dfd8b774c322de4a947821e95ddcbd42cdc0faa793b7f2247811c1ddfe1800779249217ad6c8a1a74e08afb4c9ce1e632ee0b997da4471fdec982edcced0636ae2d39ee4f68fbee1bf0818dfaebcc89c190f22f4c83d63ff4a881072e0b879d8a9799c7d86cd2126e67f9d624431a64c0c6bd9b7b3d642572a3284ba9fd6465f61401c0578ac254f2274f25a311c43c9cf997a6db3cce80296383c5163abb7876c5b4bae27981f4ea7850610a641c05e5a81db1684f8d94f02c7f8399c97adb85dd802708f2ce7d3b64539e54103d23eecf974d4058a5bab7c59cd78fe82a9d8bf0c358d34b95e6703b1c140d9822405339f34137ea051b836d55ce47d9033053c45c3cc8c66fb43c8ae2be3f0043d67328da9bde964ce6096299080defd1a048e37dbf2d22efd1562263fdb336aa1dca891896c6f5ae11e3c56adba38e7d62a93ef8b2b20b3165a4d3d62ca088c7ebd3cfee375108893a0a9ddb3078ce6cce8d1dd0a14078f87d47a46e702f49b73cfc98a85276d2d22329cf0bf8b5b6069dd32e1e3e0990d589294cfd4be3e4caf8ef6ebe0a85c68ec8e02b76aaeb4811f024cbc0d48f710fa4cc7e7d277dd5eca648dff4589e80524a49bb9a60a18b459d6b0952f82ec12a8c910f1e0cc793f34fd2d4601b80983189fc0fab6176151f26abb499fe0f902c59ba28668b3ebfa4577180fdbde59d0a2613d0e55352e60756a6b4013a07eddcbac0b89d9697a580996ace34b14220216b1bf546e314ade9faf68eb749c1b4da70456a1ee706f40de935df15e01161b82767c83ede9e07c9d1b36c12c727bc08133e3073b8de0e34a17dbb1dd54e86a7f80cdf88d43ed96bb921b8eac6bc0eead13e31c066523a9c90dd412e21521f502b6101ec4c667d6fd6fb3ee0343ac43ae0468628cd1a1d63b86906e644a28abbd3c46a4a0dc364234572dc12bcebeecec26b2581a4769c76cdd7e4d92341b15d1316c22969306139f935baaa38672396a6a579a7caa90d287def46cbc766ee4447f29a6e5789977b1c8427c586a31aff2b74c7035f1c0a3c445c83581f58fd2a829275ff17cb09d5f02e655be9827a8ac1a33e48ecb679a91cde3eb00e1ef409463e1ab434aae8eba43be34778bb379c602085d25096523e582814b2b5381a1fa7c8c59bc4291f4a279e594f35702acf86f49e345faf02b179b57d02e3d139f9f94410b6fd5289b6ab88c8968832f6d354ce5c2a99e69018fb677e21f06ced82ff571173ccec6eb72e25372c83eb324e9872941e6b11d99a659698a73bdfd0d3fa725e7b162e7aa1aa6c0ee59e727c4e7cc8d51c8011cc4ed6ec99037a8e61facf8b5bbecc2cc4d8a5efae29ca244985941660bbea08becaf0afd470fa43d0388d957ea2ab7f0850e06e218d57d2db2bf7db8e39a55fe53769442c88de0a01d4ead9f86f9a05179423cdfc1d06d91d7bb6986267c5d74feaaddb41194acf2d38de6d43714e7bf655cedc1c311b236d4055f2e1914e936656fa817101c4ab262b9e0288ca7c9899872e6c0727b4a24f5c81bd98b50bb20e1dc20d65b0a0edd479fd1917bdac71456f30db0977a4fd46d13f15bf3417e249d11425735f086eec7da106476b5a6bd10a6a6317d78f17ae5ee72c7373a4b12c426b5dfae261da78d81d5f964d1aea450347a9ec6d723003b229011289a3ef55db4e8ddea8c38c5821678a42e8b6da89df0fb5eb2f09e118e4e095c6e3dc01ac3403d68d9b39d1af390bec33d3e8deaa1fb727556d3d5323b6d79dba28dc7fe459992854af6c424b8529ee146c9a5ae06f08e0c1d0d3a1072851f9b681ac7ffa534ba57cfc990d98e1d152ca4079a9489d5a4c8a4e0b5464bf788441eae11f7f4e5d28ee865882bbc9551911084aae739e0d13d4036ab8e4df8c65b48968cdc971e064e5b35210991b64903cecf3d1594f92376fb9a47c63f063c6dab5aa08ee709cc53f7092d215b50684548adbf3b2aa84dd44e0defb11e45b4525c6039409a58e904aa8b0f2d69210a2278abf945c03ed09ce8a64a006a9e895b1c7ee8a1d4cfffe473ca9b087b8022a072869661cc340ac7c594273a8c06483f0c57c75a02b9b3630da53532b4fde780c6758d06f726129f88917677448c47719f114e2e82cd36c3114ea62dd03bbad914927ca37cd7f7f3a97cee1720508c269fe7fa336f0e65c4c3278e25cee0d993ea9059216dee3a41c0694a70583d430abe4bf96577757cab0976d67302360f0eed0e062f52c66f073478ae56627f87153149aaaecc3b5cf46c807f5114ded7bb7503347433a137db3f8e78c393c0a6d4c5e04f26cfa048cc727f85ccf448aa5695e4164d0c6d5855b23adbc30f763b857038c49fe71fa14dac1b8d9606f2885a8e7a9976cf5eb9329ae4509cb3da1e4c576136ab9d7d65bfbbb48adb3d36adc25ad7ca6f8225a715f05705750c76d9e906a0f832800725f5be5732e640ad41a30a99454c87ac59a52cf526bcba58affb0c24cdf1870b579883d630572a60df8687a1c1151da97753e99ada0999074c01c6b9742caed46220fe13aa26fd72ccebc5136abd0b04ff216edeaa6d6f59e9a63ca5fbae751fe7221723dcabf74069558b23e3c94f09904dad33484acb0b82f4995c4471ff3db4881419a45648ec885c000cc2521581b54f46d7e5a52bfb7745051ed9b34fe209e0b35fb70e475a8684ef0371b186d5b79977de399a5b25c3c86d9ef22f53a0d4952677a2364df842d448b3654513324ea68c2b22a124e62dc9a114089726446cab7268480c8620d3a4c3b2814dd759a1b51144184e49b1ccfb5afe19cd0a35b338b1ae19072321ae8ac52be6930ecf2899b0321f3e5e3c3c399d3fcb184e2c80a7b784a32d350671ac5fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
