<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7efc9177bc1a8e7542ced9cbacb0f48bc09bf6050e5d8fcc3548171f7fbb92b014ae4924002c91e046e4dd27f21d53c7336a9cb023031c430b9fb353790273b64565e47668fc9cd810ad439c606c282fb4974423e86e727d66b4bd4c2c5779d87f4b25d77197222adc12416459ef2014471bef0d594a7b4aa7552399e37a390df65c49003e864f198c6b6ca7f0f08f6d625c0cc120e2a7eae19eaaca74b7d8bb44c12bf5d3772a4d9dae08407a5eeb0b74845b57da01b63ee7602c7c56902b0b12813c6db0cc94b4c10bf612e2d72fc08242a82b263cd1ed94f0cbbbf6c98cd84d3ef690186ad62924d8576f055a6aabfa9fa5ec42f5dcfb293846f731a56ed3163d55b4c683e195443a339ef28ed2fed98c0b94f6b311f1291423eb42b394aad72dc96906634067c841a76b3c9c0aaeccbc69ce18a6b6a31ecfd3ad3b78931118479484439849dd2bae72355028e3b75d2495ae3de037f0281144a89ab323fa2b611f36aa84245cd3b28665afab56e3cbe62613f29c2bbc8a71cb1362779e356d7ea81143d64abfa710ac1d6acaf61716ea0c3249f0dc3d9de9d9b5a68856796dfc2c341776c5213cf4674d7a0f786f59afdfc2270b0dbd33ec6b13407c0eee9f5b32e32cb374758b1225081ba01a151ff273ecb579070a2984652db681f90421adcce84c0470a880c64bf6dc0ecc124f7da93886802afabeeb2e6acbcd186e0a7a3aab1376dd36dc1a2547e2487e23ca78a95bbe51acd364603ddb03904ea895d6b135f04010240d9ced29a1e65372687804f5c62a3f4246b49f2ef3491ec4722a708f17153169ba632b27a76f74ed817fd1e45875a36b9c96b30b895be9fb19d0dc889f980c2a3d6aa5789d0b760a6aef831d17f223a10abe7330a9e0d2a2938aa5d82547dd546d864bbe67edbe08a19f6aa301a91fcf3ab3c1b01b0709343918a35ad6aeae7b495b6c20d63491e9761ab882c0f686fbc207f1f30c9cdac706f99e412203bd697ce6cd848aa39d3f0b61247bb735c8716ebb8545062b17d1008029f7395c907ec67e2460780134505d358f874eaf660178c23ee7a24ea8d1269407702958f8a0c6f4ea2272f1402a5b6ac9eb6efaf9da5a0f64b621fe55c6f07cd2e418325ac53306613dee1153bc685fa00e9c2ffd9c4078e82996cdbe7b201017c0e67f5ee9d1736882921527a15f4905844155f517d9d2986fdc2dad30ac71a735dd230c1985dca35c94f64f72c4396caa616ea300128826dfbf33aa7ea01e9300c5dd90cdffc6b2f1019bbcee3281cc4769e2c035b81b54be766781a4d66eccfb7af7906366bd95788d9e7f436cb039501ab3997e29a03a8fdac0086c0bdb1ddecbe920b6bef3f327c0fc26d309cb2e488536ff095722e5ade4e0f708c30e3d9a3ada880ca294879dfb0280614276626b365d896aa512e4039b1f9cf3d3b240924fdbfd4b64e77ececa41797459923e774e29da1eca08e51c77125365232cd3f1fdfe189c74634b626f216df940283a4e1da55d67145cef8b4dc5b942398f0b544fe0dc9532d8b1950fa69c42faf8efe0f0f7e53e2b1310f10f3a8e9e313ed51120643dd189beb1cdb4fee93ea3cc094b21e5fd7e8fbe791b1b8784c1ad0ae4fda7ac1ae21f6709a9667ae80a5a5a33f3b4d523fb681400a6c605e91f446311a5c53d1ec98d4715e7c623c7a8691a147db3bd30874e5b705c22763cb361dcf8836158f207dd537035c36784b51661ec500e58ed37df10d67d2bf375dc159672c9ca3788e3c31da7904cf0f67cbf787ba02efd94e23bac261631858d6201619e2e729abe0af96407933454f2581a04b4ad34d6bb2e4768168c725ad12b4f1efb4a08b881300d22799dfbb957d8c1cb0c21d90412572452237ab753d7a2919a6c3417539c3b830c9a207b8dd665f28980bfb6516363986bd6fed76b853aabbca9484939b269bfa18d406a5c6991731eefb2ce0bd9f20c11d3a4cc792f23e6cff8bdf9b898b1b246a92ece8249ce80a85fc48eed0d2b2a05153e0eb901de0ef8e4cb74c63ec5ce9684f234af736f950cd92b5863934ca4feed809dcc3568f75034d85fa557b689503052b734e46b752526a47098fb7431d5ddfe51980dec42669d8fbb5724fdca1cc41a10a42324ac0fa8bb8f22596f9f183e0eab5248edea3d257211e797db2f746b048f154a7807e582cf5ecb75a1a3cbf6ec73102d9fe221c4b4718b0202a87794120669b518ad5705977905fd1deacad90c903cce26e5c872837b17f02ffb4b328722fd70b5a3e4c4137f0b4dded1a2f91013a95eb492ad6b983f3420942171c1c07d8352b2fcd6364173812279305273a8ce4fda039f84c2891b0c21f5ad7bf2f0dd8f43ab7086b3c8c827e9a06aa8c3bc356f6efd7fe8227be035af6f2d4087be869a3f482ef9e27dacc29c104c28397550a38b54817a5809c57ee4e65fde055775aa56478062eb8003d5c388db4b86c25621fc6f46516e07b4bc2e4c0e73900c92fcef190758a8379de142a45f58ddf816ff8a30d7227f5c04584ea442d28ccf6b23b65c3cf6e177c781db5def52514900bdbbac90892b00f69bd03bca39187bc095f3914cb2454ec789c7b41ef2ac79cc89b2b4e52529e8da2f022b6bcf16fbdfc25a06673f442a16638fe540520580c210d35a64ca253299e692d321fb42e9da20aeb178044dcc3febf6521554440ddefb75a25c64d81324753691363e1b928c0e0055c5a9ca09229d989df16374ff63bd0e9667edab2766774b0fe0cd02c71a33017a513a2851c7bc743498edffb24503163ceb45adf5e0cb7feabd50356f686c659d32f0b46088f6eb9d389bf5214881c4fabff1bb2e3ed339b860b65e6e23b0196e351623afc2d91222462cc002ddf5879d66560776dad3def25de5f696c1e05505bc6618945e5fd0d7edda3c6f83a84d977634efea892381d9d0fa086267776ab847316fe77a8a605c700719ca3bcfddcc5260f9a0fbc262a074840a92326fa09c4c31dc3575f56a235848cc7574c37ff9dc67a6fd59026ba68a7b7c4256c8541d45903c9df962e1dafe136a9b9ac3b43b556239514aa80a859ac58dd067c217d66e9d1ab9556b67bd09738982409e72f56605b245ab225a91e939b1104fe9aa7574d2711bd62c18c652249e93cc565791353baa31bae94076637206cf27c0d05c4d92a754ee9d8e014965b1e0314d9d3d25bed50422d65aea3167a17c1bcf8d3541cf3b5c2bae0bb131e00476c163bae994db85bf0aab02b1de850187449f7c02e2a755a546e0f35e169d69f773f63329b4ff29195c07e2583f0dfeb62c9a88fe203bec4cc6e8e1cf7bd56fa98767082b0f0b2de852e892dd0aefd00951806fa067a8e4cac63e8e0a44b8f51a81506af7a6d7672bd141cb50612d5b9d4997aaae3f098dc19bfe0a7553d2ea8f36b4b3d845c48cbfffc370e72e2769cc590c2efe67984111b749b79621ec14de372eb1509292cf6d3d5932b1e2f9c81f07c4738eeedfdc8b976723b269f51b1c67828b0d1f616d15286b7f9ce40ed3e3ca47ff0d248b0f0e77f4bbfc3b7c072437cd7c64f10ae0ebfeecedc0ddf3c1e22af8c756bb3aff4d5f0eff4a60b398c0880628636e1a050c80d9b2e25d4667007192604eca3315cbef2f49293afc2b549862301a92ac0e26213cd6bd2cfa39c936146d98223fd992e8967ab319c1677ed86ccac62659bc45d3b18b75771545ceb42d13c828adfcb08c970b52cfffdbf73e4e1750be80de625d5f727396bcd1d0d0584909316ab44e4e95adc098b6931aee66b09a158b405e7a9f42c69b8e138b97fff69017057972fe79b9afc23a0cc88cea391672cb1a5e7ff8982efab536a0f291c33fafdecaf603e4d77c1e66057c5472b8e69ee881a1c78a748f0c5c6ad0ea7af2272038e8d5379302bd8a42ce4b0fd7fadc96ef3fa7b9a34fd8ece814680092fcf9b4be94f61855bcf4c26f0c0e95c24ec4632ee649e85af4a415fb0dbc2a12514e8099b3ceba420f80c47b5fd75184f68b25d07a1e2fa2566260aedb52321dca8bb5f7051f1f1314a29f6c50871f0fd0b2c885ad4b931002ad4420def25a397cee18caa5fde22f0ddc149d7be75bc5f71435f0e5e6ab1bbb51b2d7ce08a25e7204084a22e845e2d150acf881276edb52c5b0d795a08ac46542bdd098520a78d928b2257590b0315a0738566cc5dc5a49cbb1f9dfebe207949a25dfe987b9c39a37cbcd2bce891a2e1db73ecb2204ea63f69d47de321375940ff831a249b40ba71dc4581661faeb0bce1aae5f3f791acb45fb2c5177b680b5369d71eabb5498bf466935b3e420f871fa3122c71c99b3f6bf3f4faedb2519b7eecda578ccabccd73c2e77550e3846ff7c4810bc17fd7d63f5672ae6a8aec460d9f4e64123c2f729f872a10056a55e89c68ee8a6b1f01171c1010647ad0c15e162ab2723b2d0d012d28fca52910e5ad8337be661560e2f26f77b43823f6669a066ba51ff06e6dc17c0a651a894cbfdfb23aa4fde404cf075fd685233a45e6a2fd1aa2b05e377063bc90246d7ce661a4777f6ed561741771b5f0e5782694782237aa50dbd8ca2525f97bc3b881b29a1823a670f3c036575c0c6ab70cf4ec591320b0d97ec73d3f6b07499a4ba947a22a784b3967874872892b377cdf5f7626d71abb6af93c53a3e5bd815c255e8df560149d329401bf8dedc30c5f5386c9526762642b8d1b3b96ec5078bc9fb9560724e4f91b9f0302f328bddafdeb11c4d643b3fe3db706b96da0f7c9bb6adba9c69513344aab18c5d022dad47172c2e62b8edca1019116e3933ae4cc819d9de3d141ba7fd625f556381c1f1d3f01610ac8e3ce5e452585165b38f976f509b07ce40ea64b5b28c4b4b2f27455ad4bd254b3336b0e360726cccbef5ad49c328ba8f43e4b68521d0d606fce30893aa07c0b2331919286cf789410f3fa5aac59bf5601055fda97d3cad3504af46c7e2af12663d1160b298fcf535ec70896df3342f281f78f1dc7cfb4891ca248fdab14de8028e68f5d69c8c1a90948b0c781527e3964454dffb369b395821406fcb8541d1bc5a19bd5ca2c1a168f310bb5dd12f52dae756fc6033d690817e27e2dee15688a0b0ef9045e0a406ab43f0247763af4fb1f3299353521d118bd3dc59e1ffb7abe407bb5e5b41db531d29710b21060bd07d715d6844e66058b258dc8107ce06017e1c77f200b9a4b54f5f159637f9caaeaff1fb28d2621c65ba937a5163ae20ff5d428aeb29978e427b08fe4f971e80b64efae1f8a86693c825c723845e816282c1049392fc3b1aaf8fdccbfa16a0f7b272b7888d1681faf42e7d12eed5712a1c635491f56275ee0e99fb50af756ac60af445713593b7c8f25ad1207ea766c8e3dc3a8ee849ee5965e5f12e64c075102b20f7ebb668246fd99842c5c8a7f97e324ed0f6d09ab1d9d4f20ee6670e6f13649d3383c063adb4af76ea8baf8731c355d182d2691ceaf2b1fa4657ff53a454b3df7254e107f4bfce3c210ea97760e90ed15ac1516c75c3cf142ecdea57e95002c0bbf16969bdfdad872f46a8b3e5ae665ec98ab74361659fc96dfe46baa7086b169267261c4f0d8ef31b29f0ce1bbb1c42c1edfe93966e3bc4a75a42f023599f8b1869798440a17f82822a8143e85a7fd737a6a49c939cadd62611aa1fc8df93bfa469cd62e11e89e603e46e7c26b6e8b66c941160696c02a512fca3d63cf967164df8e926ace17c9b64f27f234fb5e26f43a005d8dedf1dcaca715dc48acaf96b484277d7ad383bc1410107c173eccde5c4f74bcdbec092fae427638772c15923835cd9b7f3487aa5ad772c83b3a957e23b78fa591473a227550ad11d064245843191d849a38511fe493aeb5772db22a29dd69e5e4bfbc5972bf74c4d683f9bb3e4d62c3f360e5fd961152300e2a72deda9a8dc085e8ccf442ad24aac60592e14fb174b0580f8da0122b4e170a809b24f990d6349a9f807c804e32174718ba9db24d91d35110f1cc1b8b5c5303534f451893928328ce5e1c418904e1095ebbf795b22d702ca8ffbcbb1425db0ffcc93d645d0064b2eac6a590984e9b1a53a246ccf7499831ee923ebcc82e998ac8b4fc647efc325b443a1aa8a6a7d89199d95c5734ef102a60f6782aa0aac1c5518605d75e7f2db2669bf4faaf2ad5df557f2fd0528b666ab71d82b11ea235f23ea071e57c2c8cadc2a240d2d990fd7b5ed293a675bc32ab197ac3c6a36a8228ab035b741fb39e76e5c735a060aff7afa68d9eb3e27ef67396b282a1eaf8e02751fe1433abfa34b83aeee16e5bc501d2aa215fda2a65ef9e598941bdf759a59722f5185857aa8ab819abdfc3ba5b4b89e2d3ce45a8a3317af86b36c2766f9ed8084d62e36044b30af638b53de92a9275351771576ce5282a79b752a1a1754c4da6a01cf4b1b171ea3006ef2c92095854d871158959a3bd9a4958fec52c7ed639a9d803f9f31b00689ed4a7bd8d016539ee48db204207c6a80f534f91d9ae09cb528adac8957b586f04e6d8c04ea301b57db48c1543b353f6c233205b7f214138e34bfeee6446d43f17bfd28817851aad0b46e53d56f9f4b491925c86b2159feb58727f19fdd4631310c9e153fc9ccaa3e95504af97c8ea14e73e8428d31f390a84b9e3fb45573694494dcfc1b9a80b290499eb3d5cc6d768fcb1772600f63ce4b809def01d51b23dbb5d0cb2fdafcb1f805f42a3b2c6f7549ed221b0a4b25f0fe379e1614b021322c0901b344e80f69f93b0041daad1c497e5be18f18fa1fefad978593f596ca9bceaa7e7914ab7c4cdd68b23e2640646dc182f5c172605bb856b7c020687442a5eac19cc8908b27c792ffd08ec119b17fe9dbb4b29246ec42e7e2465b38bd334f0b7fc72bcc055a1168e4da5025ed2d63558b5cb3ae1121c8bf157cbdfc589c03bcb5087fd4f3f5f41aa24069bd51651c224a12667e44abc3df1214769c3f6e55aeb5341798dda24ee60a932e85d5fd750b4b39be996c81362109216c2639b9df1d064e38df966c092d0bd09f7de2b3ac71b2717807171254fd63eb783a071a980b022d1554f67f287fd3dea1ae01c4ef54fe132cfbb27c57e910b63e2347adfda395aacc65ffc5a616a3e9d817d053964041990300f5df6663b4ba4ce27b9d038c0a48d9747da734029c321fda1636d683da17055716747515731fdaf486bc2bd898fdba9d048320179129d20af3a2d6a604b968e71e28bc6e1cbc48154dd2f4be0edf49c9d2b7822143539c3e7de5cf47261fbc79b05ccc45ac47f98ad818c09b21c72068ed030dc345d8e439c4779723a8881009eb527b92101320d6e709514596bb721dd2d220d6a316f88d5dfd1d45d5768e705690b0f5f3f038ef6fad550a30393d450dd5160378e146d2d877740668deb957b1726bc86375436a01118fca0ea0c20b4d45853b43f2c308c9ec099925bed6fc6a6fe33f25b8eeab7a32336f3f593f3cb785607884305cf077b527963f980a3e041bae8cd82efb19f172a896bb156de16a325fd2b6a0d0b437219e8a54f2ad7f66ac38efee3265afa33061c053aa8b8d574356d16a5c1efc4d7bcf3125ffb5da47fae68114ab3b789a10c860e1f4bb89e4fab8e2c8c5e225e3bae42ee049f6d1db30d4c0456f660cb217af5dd89a208bcd672a050b87e8d2504ba0037da35eaa62637f09c413f9d26f06f943fe274c113f6c61c6a3d32898f5209c867f996853c56143a8d5fa67f7a826a53670bf167299d92a581c7cb369bc48c3bbbf1ee0a310f341cf6e34a9412f0226f740761f26107306ada279e68eeda3146fd7171837be9d71b566061c77e13e32ae528f644c91a263e3fc86f1ba4f5f5d82f0d14ee7cecfb70ccb1a229217abf531e4195fdca412bf6f7d62d0e8437b29c4a91a452dc4df0a6f50caaca1e92b7aac868174df1e21bf6487cfe6e3d8ed7a2329d9187827e9c985f33a03c45244008ab3a5287d11d15c2fbf3b17cbd2dd61f409aa6ee294744ce63f67ceebda6f536164c7c21b95bfb14b67c226c6efe6271fbd99a7563c988bab34d3aecae048122db8edc64c14e3f1b5e5849d52c6253043736388ebd14935472a7b73fb36f8f13952f76f83a0a07d18118fd91c14cff2c6670e10b5472d17cb1062f87c1a570efb901eff7abe10edb10a9bd48039458362c3c9df4a41df8243ca48d2666f43acf58278020829b1975b753ef56183a0cbcb6b13602ee0df40c072c25f4dd736e95173ab4e7fef920ea8be0c086f01f5a9a4230567bb200fd337609522738fa874b0cf843d910f646ebda20803d671ad34007fd50b0ae2b7ef534ce5f9ccaab465f7046f1ca9f901b5679360a57e52fabcb3c6924ed0b94ffadb5082fafe72802c30dd33ab13da79248cbafad15de97a0db44b5916b26a96e091e34426e4e70b9c1654e2daaa5b7434a4ebdf2e3462ca49655bbca3db0ad01a1295a235d3aa6a3c4356e6aa77bf15eeda3936e5bdf0bc15f32143be6b6d2fac512eeb065cbf933213f08133c57ccb7bd4ea447b2d7f54c05440bcd6fcfef4e66070b9ca27ea5054e7b5436014e442ab3fdcd7814d7b92b8820f757147c02ee186d549989d85f41ac38d052e7a228deaa1566c768a62f65fc4f27f1162c1ddd242fcfe3c281eac500a880ada24a979f10ddb3545f1196fe4223c7314324c94d99c02baebcbd97cdc3a4600269a390d22bc23c8d2d6ddd82334c325cdbe54daa2bd1c96cab2e7abcff1d32c38ac50c1023ee7a46aa90581be65b123876c1ae5b175168dbb7ea05d4bf2ea6507808ca2ddda2b7ca7f03d4afbf5a2fe405eb34f78e8e9a672e17b0b2dcc6f96152c1b75d5823902fdad1e5886f44159bed2cfac97743288d1e304be8492c13a6cb46be0593e1e64b002359c2d5c997bac2498048a665d5cafd54f7c6b439076b04ec1d9dcd22d2ad840a7cd862da85b9fdb8bd8fd8a7c99e21ed3765d08ba8e0236aa2f1609455cff8b992ac01e345ec181d483d92b369fdd906c5ab89523b9a4092b48af329092640ee90b239ed01d2970482e8f435cb910c350f2156f5a7bb600465d8b16bfb89391b8cef9cd322c84bb25e8971a7b43c112a277326e7d2da6fec51a1c7c1386fc5db8510eb0f8a4ae9958bd7a53c3eb614a3e2a588f0832b2109c7cd56d2c8fa899245ea30e5a217f5bc6736990e6c86127a5de1e7509eabe2c65b0abc5d655f72518fd4d011db1815b90df230e17f3fab33183e1aed3c08601a97102c5c2cceaa8d7fbce501c85795bb8a27919c9267be2a63a356b1344783a0e7b6ad5e7419857862459db28b8be905dfcc68d5bf61fb16980d823ef9487d749c1dcef95d2a3efd4150c8fc3e3e69ddb57af062298bcf0c5e0f1318e0f7b0420aab7e27696f5a78cc81ecb417adbacf225ca6d7bbb38bf80d35ec11a29afd148f36ed16a1abb87e176f84467e881d19d78030ef5e290843da481cc0953bdda4a8f729426e92ef3441016b649e9e79d7cb5fa5c1d62910e490a99169acb1229f61d592a6895981ed6ca12a554a311a5d505c66fb8405ef5516cf57028a609ef18f180dfb5847d2c7592e9e024d5bac9f11aa268931ef005942a132618788a24db4aa595c4f5eec9bec294186632859334378cd102b66e71122e817847bc5edbcc454016d2d0f432f1d163caaaf16d1870f389f614e2918ea3d1f7c7a86d7561b9df1b3a8ac7249c3cddf7d5f254ae6610be1cc00330daea97d36708bb25613f47b5cf40d91dcd67213a1820453b007348ffd6c1d128ddbbfcb587ec44b19d6743acf409fbeab869f9db41637e5da6adf7fba327fbb8c1c1441432ddffd6cd455d1337f3253fbd32abaad2777b4557eaa9203f78231502256e099301293e2dcc520854a681b862f2fdcf1c5f3d40f6e405436a40ea68e7bf3577e57fd6cc62c21d90173338742617ff8902cdeebf50d4617283f684958c575a67dd0aa2fcd3bae96e0a5308b2bff17eed619c74667d37938fe34100a4783bec36d38b57b2846f2e6077e6d8161741af7b40beede86333ebf8712a44de00bd0264187f48a448b085832651f73602a1913e236bba4ebd433d98471f1acf36e0b623a27c82db266f9c6b463bb1c1b1ac93e30ab3ffbedf098f8ccf12e5687fd3eca5affdf401446e45a173e2d2cf30edc641aaa522aebbdd9ded1cb0a90685107483c48b4d82dbc48d019437cd9c600e2bd34a287d8a21a21970899d96c9005f4db0bfd48f14b7f595072737b43bd85f04989fcf0f923f7440a453444cd7b7f7e9e3bcd51b6ac4b4cb3425df9c9fefcb428eaa794547a88f273877119870585c474be69daaa10560b23d3f5291897bc36e5a8cda1dc11f29b036b36480f470abcfd51ff769665ea68404b56c31c0c401e19d0f4ff5170c853b1152fb8d2286ff0fc5f534f74d35b393cd921ab9b14a528b52a076fded3231684bdfb6ebf5b7d8d4a0239fb2d227b6f6b309cfceeacee4fe4a56cc3a804e95fe8aa5d8420cc81a712eaacd2cf7debdb02c3354c6bc2d33eea0a0f044199af5d06bd5c8cb679c2fb626c1b2a04be360f1ceace8f3cc70a6fece3a03dec5cc4df560b339de948b833a646b571f706f6105650b7cf851ed27e487d9ccb133653f1082890ecab403a09cafe7383e17aed5d03317ee4660e405dcb3ddc43215f9cb81c7cd230646574ee508d100d5acfe78a2a296002af0ce65d9526745b46a3632bb7d6c97facbf0c0d7a4520c1c6712696c7b0696abc82ac03197324a51660a2db3d7a60d87447ebf7ac5a1eaa4eff76c1cfb62685b26754fb3fd63bd8d465bcaa6f344bff94b98fcd9d376def0d4afd62f67575c599c78004bc9bf737a1f200f83537dbf316aa561bcfac3326ca29c9d416743e770e30187b21b139d4148b1af427d77f87fcd4864a2b1cda1f46ec3f848dda612d1fb7590a4b6828d54d9fb8aca43ca3fb893036a59ff02ffdc18d31d511f20b9efe690bbafad47b810768f763c8ba2167e0a1a450667c1be391500530973a90956b20d4a37f7a3357c78bfec30b9c15397ed275aafd85da3b1c0b7afb7b37cba9e309a5b742cc403700042dcce189e57e51d7c94e752158dde399ce080d07719337993fe83485d4faed0b6d78599bd0197d63a8ead6233553e8c725f8758fb892d0104ff8e8e071388546ff7c044096e4b3c434ef27ec138e51724b551fd4fbb8f85611f9c5c85e8b0492889d207bd73ae838834bd5f467f97053d7a5435afe07cbb208a430ceb7af3775634e25b901c95601ab59211d7b44ac296930374f7b0ee7f2964525c6768327a01cc0baf61cac60b8cb7002bee4f9a5accaf5100ed63b1ff459095c7fac3fa39e8670441039935ea619739f08061e563b79e3df66068c2201d0f641bcaed004bf1fc1540eb4ce9c4e59e22fae0c6b27db077cb995964e4019bb8d6d02ff7f9c74583ca03ca82ad07f212f2bd651db178818a393e03f7548c08b2799b37aaa851f06f25626e8c2d0e81ab31d5bdb96a1019a398163efda42dc6ec20c67317f2cc4cc473c9d0b5973322a91fd575fd24afad9c0300d412aaa993370d74efdf327373634f17f8e1f01251e2c23369c0884de319f4fe66ca80327c9323f3aacc6d0b599fe6b3713f95758ba9a4a99ab5b6d167e100369b157b94bbf897a8694362c1316fc143476d7e74d106b2565b5582d52afe7bca3898465ac1fe448d9d5dd4068c5a40cd93981f2b102e48a9981baedf1973c69be0a0b2561e74d697dd78fa99d365dbec06424527be35e1242a94ecbd3173a23411b069cc0186d5c6ed1bdbf91a9336d604bc6c6473a6099d037879b399839ccb3a7e897a22cbfea5d8fca4f3fd794782a10a3165ce6395207c51c23c7e2aa30ab0776fd5e293d320b761f57c5e031bc86776f8bcb1c6580c0e8496153d52d29960679e418b8318d4d378720a84d333abfc33a9e927b9bead6a659473b20211e5dc0c1bffc1b8a2ad96d3e62ca49797764313a5e22fe56c5b24d84199fef7d6ec6318002fea224285cdd5c61b86090623b2aee76735506a8a56f4b3fbfef9e1fea3c7e4757fc946f08c79861ff379add76d0c7431fb798bf3f25a37acd82385ffb1c7830a6843d0a4645558546b420a16624d7f9cf2f792d945cd7b4ee25356bd010a90f8ad2b344648165944eec9f6a69aaa20002d74695491d3780ed79097ff9ae73dd02dc67102b7a4f0e362809982a9cae2e410c3322e5f6a960db3261d920e2532b1e77fa2753f4a29744b0bb8ed764837ce1a196f2923ff7e887a4ceaaf579f1bdce4d73fdc64e33f80d222d7b87369dd216671195d78b83321a8dd4218b3ed031b4af5afc14b545cf6aa1075d3f55baa1c16d8d5f4740a026e611bd06a4e4d9f56883d28aa6526f06328f2434b241ba4f30001f369c146d1ccf5e39d58f9ce4a4b8e913f01be588b4cadf28153dc461d31675934eaf59f28ac994051488930980bd6a235c20746da7b5acf0c502d31b3bfb41541636e7927f86006bf787fd78b4ecee3f4b4377d569940943f05c6bb516d2737c7edd867916e06424c288f1857a058a917a8cd410edb564f3dc79feb6b7b320e56198a74f364a8ec0170a0da159595fe0a99c236773161547f4ffcbcf076dc5f704e4580499c7f74407aa2b55252d66d470cfdcff3082205b7aa94a159431fe0b0c53dc02c6ce2ec50ee55d0363914eee18d8ca3d06ce4c56f1f73d44dee7edfb1ce1da6b643d7a93c327308453f9c6fc2a12b28f14f9abde16656a568215019106ada54d205372eca825f41da56670e5d88802291ceaddca837060bc92e2c6f2925f05a304881bdac28b635b86153d22001d6a39667f7e6421e1d249c96cfafebd8c1d4ff124eeadd4a05cea0387f670dbe4cf3953abf3723688cd2cd0ce95e2e5913b8d08b5e1e68da96c4872fc0bc0c8efe4d830daa0412041eb3174e42d7154c0430c0ffd0991ed2893e525b58aa8a775d64e3317ce23449dcf54fb1ecf568dd5b7f6f126d560b0efab6d93ae4e1028afefc21c14c0bcdcd79b64fe2006fb70205f76c885a5688e053d6ca1e79ddb2f8f4cfde3854467915559bfc57b6621bd8c47af84174316104a9c65d0be893d4991e1ee84d8b9ee446f68c6e529de81e6b7f093a815162c9b7ecf7d5475e9c74870ca52532572df407066cea149a577002b88d21f14e5f11e6d5688863ec59c6f1b005a703608421ae9db2bac6a9317c34a744e40050de57a22f18e8da7300efb99630de37a242b1b1534df8b921701597f73b00fb1a120db34b86adb5e6ce7e209dca10b2e2a57c2a306f17a68fb4e41d5c7e4fe0af4f0a53b442c26e5ed8a620fb95634e58244e07be1bc82c40c67ef3db9d3fa05d24929cda4268f19ba7669aa8022153af39610af49bc23c0abe6c19e5f8ebe461c0757388ce0ffa8d53a7dde4da362a125466965e30252cf09f1e2eba0fc47d9b2fe0806eb142483cfbca573edadb58d6b73d96f0d3d513fdc0ee888fa002cd0d40d1bf3a302314634fc91294ad89bff4af5c77f4ab48ecefadd51874cbb7b7b268e79634e617e08d2721ebe7d09dd1da51f85934f556eca6649d7c8d4c03eaf2da1e3ec1f381e80d0c6687cf45d2cef4236649f55df45964ee32935bfca8bfd16dab7f10133a4fdb47a5415f10631df534e82eabf17bbf99cf19024a6e01018c99d91fc2fb2edb4d05abd281ed6018709e823ff408d7523b7ce91936bb5579dc8db28caf5ff76e2e3cfdee5347b0463d351d72f5cb31e212848bd4ba98b26ac2832738d05996f1401ef6a065ea5441e4f553bb99c5824be00dc3c7ae43f0027f3f2c828e955a7a84586f056e16d9cec34ea5dbaaf2b086cf8b5ebdcaa9cc6a2a307bcb90a28e940ea227b27c0a0a86568aea893bc48cc740be2a9445eef862557ce0c0fceb681c9aec492848db23a1bf8cdea9dd82e8a79c22f6901f4711ec050e6ac3beec52809aab074dcdb4ef649c1707dc32188168f073b36d170ed58bbd2123bedc604efa87dcf687eebcbfdd14ac78d711fbc97c89885c088e0e0d42b891ea565b39c442dc54e78753e359e54a61a2b8fc861561e03f997b9d29dc852496c0ad95e51184492f4f3d3fea26f60f34ffe6ce898193630a1e35272fc40907974e37bb48367372a7cf9d3fd1b2e00d11683ec91becc474e41edd5a38bdf0183b2522c810a48ef7a10f72c73f6aa23cbb4d5b3e5566de55eac5dc7c0c677727d52dea9c1e70c70f7adb3873feed132b687f28050de7b859ec951467ee0781bdafdeb3610a31e810eabc8234a68a0b86d8a195ae624ad70dc1fa46ce662b6179ff5b7f9cd9c92f0db3197aea389662d8e5b82ee211384f7cb12a31f66368e16358d39e504de957b01f1bb0eb3b10d7767a686cd169f1236ea55b8fa07ba8662adc0f6f4056dc1ed22d3ec29939caf712c7d8a5f45fe0c346e735cf9ddbff3d95175bd80b0ac52da0a7eb8e7b7eafc3e754b8bf540db0052df02475f5cad4304fb965d83093e1f793e33882195b195282ed522b9d9b7bc2e36795e87264994beaa011992599aebaa77c332079051c00f7213887f44dfda0d3d0ca86a5cacc4d7ab9ac6b79d4434085adc3b50b0366842316599ad147b4aad4a2d46eac22b616a10b2bc0369461526bd987e1c3063058ddbb3f355a08bc49bec09da82261679da88eadf4c1421a1241e27afc88e407d356db1d02cb402b5fb2ee4882e7c8dbc859a273a4c0da967f0965be878693fb60782c68b465bbe6b36a0e0788f2890f9b25b4b3d506b24b9040369b842201c13b00b21000b407da192d1d91db2886574654ee5833042dd98a847196c933d195bc1824b60699bac1e759a105035a87a2918b926a49ac326781db4c4fb75363ac8d046cb5e2db6b8f2a8eda9da97c0030bb41fdd3a2748aa1e545138137e0f22deb79c0b0a4af6efa5454ad16669d50aa7aa2061266e3acf255e1879f4d3d0c620b1878a9717ee4b093d400c65ce03707a9a55454c8692fb80f8d167caa0fa3a0fcd3209adae2b88a3588df28b18a32f2a7f3106ec4a8cd3158fac08f5934173b022756448c60f9bc04840d696082abd54a7d390644f501f05215e2a73418dc740e047aa227155c7bb0b7d9ab2c6115f27922916e5c66831571ef7f763d7322d1de1eda8c5aeb2dec96a8c52e1ad4fe9a098bb26e9a220ec864ab8fac45d9cc4e98fa49c0d77faa7a809707cfbac7b615004774e98e2a46bcb37d0906fcd8ce104fc5d5bb6e475ecba71c76f5cbd470cad4347d7e1cd92fb0057156c6ecf26d97f2ef1a5bcd371d8750a36b90ad7bf3713ae65d70d188dbd6397cb7ac749d2fbbb59bcc7dc8e93adec2013585ae7c8b36c385d51070045a1c1e0ccae3d66e9450aee00e449ba60191112f525f68aee926e3b7fcf691d10dbb21c026cce5849a8a2b94f4166c32fb35786acee925685b6fb62f6464433b82d8cbf8bace4ca7cb6249de2a1c5751a81300f3a06e9c3f18e7a5635147651af56046c78ef31d05ddb93e4b8347e0e7b261e6372340accf3f579479a53ee763d2d1e3cc607ac5f08f0031efe354375833aca70ae4774cf1ff8ea001a31bb6d22e7a509298caf19a6662c97b6a1a2ec21d8d1bf8bd3a43afd5d1badb929ca970f76f566610664278bece87b71a81b2a07ee32db17e6e9725cc0d28713bc9180962c7ce163c97608956d264d88738603909c3347084cc151af64c3015629ee3462778d4368d56123f9974078c0661f3f398617612092e914516a8c3ec4cc6e911d1f4bdf11367bb116c82f4df028b9c74dfa34a2472d5837b2772a0ad7cf78051725fa70da68075e0f4303bd864d076b7d671f127c058764bd8057fac8c3155f617b098f141150cbed4ec924c57791cd25ae358e9d6df378f5a602e14a3953ccc093226e165dff2912965c1b3a62ee6f01d2d06a53f5523f2eee6810d22cf3c07d56eede8398784ff639570b8be986bb256c5518d68caa5013d6c43e588a772f0c5acd4f61a04270da8a44bf39a0c4562e0c6fd3bf82ec47a8a10bef707bc4ec26f8292074de875c981720096a8204b5683a5d1f4ffa63b3e0609a275b44763c08bf8960a08d565fec03c68a9ef0367dcb35c8ee9b40485785b19e6892e75decd10754972923227def33e5c8878ce1e89f1bf48e7b2474dcd3d56ff1ffcbb390b9831a8534dcc8b258f5a6ca0c2de973ad0cd8cfcc91a8ac72e0d3f9083737d564dbbda40b8e9149cf13ce86764b10b1b241263f7f3f50e47fc94bbfacb426129000e948c7faa0ede14231825efb6109b5f256249f9b0cd7f03bafa83cc668c2b1a48e93492caa6b7e5624359fe4ab4220548204f9bf309f6b2b37f69ac443dc9781cec3e9bebe2fa482dfbc9b09afd14cd27ae5d5f3d7b3ff8519dc9972efb24de6fb72879916cad146bfe8801de607007020e1bc61176a68baa219e6efdd617083b6345b5c74723b422295af30ee5c8e89cf51fc4ffdc51a1ed050c75858ccd3464b45ee52fdd3bc97549180ddf9b59fbb56d101dfe8bed27625585f7a0d636742e817dfd49904aeb995cb2854c381c6828fa979d00c039c728c337c4e979b7bd54e351e4ba924bdc8c77a99b8513bcfd5f5de582520e59b760febbb2e4345e3cceffeb8215b58e69ec364450aa534d3ea3601d73103dae828083a7f73919bc66f7557cecc2382b5de0398c6e87b3b0e68ffb58d28d4df9e9e0d458fe9adfd802a9d9560572c0115628d7016b859e4e43d53f051b7ee909d1871ce16ccae5b2f635b5faf218764b1e159a11d6b979d9647b9b99a549c473f68af29051ab8e310c4e731e542e0f28297fa60be81688a986e58be5135cdf4718764100ecba1ced3ad6507ae5fd4ff211dfae403724217ee65f0bbc93deaaf3628323e7e65ce513db7f2970b22015d436131b8ea9105e3c682d5eee2381ca31149ddbdbb83256a505939cb766ab5339e362514a5cb0b0907afbf9450949e6ba21e7c3948e1a7f8a831baedf6150c455c4c41c9de70f54f86eb7137edcae2bcb6989078fd3bc41a9091ae7689b8d260a9575bda8318a2c44c372214866357f1cf7c191a7ce35dbe1e7d027e6418bcc3e17bdcdec40ca660d8f8ebcbb5eec0e215b65851bd5580afa0af481ef3e331b4c940842e62af08766302f0c2fa63760d8f0becf012b6c53cfdd1ff7bbef0824b3ca78c0576c950f2422c53a776634ce4de08163c3a65b1b29d12569e6b546e074eaeffaec37c4927f4b62a9f65962fe219bf889c989f725783210e4b13e26efbda79ba1bea3a4089378f8cf97c25677648885bdc6d63a27f7e9cb5c1f8b8fee540b38c64794fd9dfdd5e19140b4bf13981d78366f5b9f8e1b0f57f0336b8833c69f8ad3240424355630bd36a48f27203b0f031d92aa96465a76d0bb22b9cfe4ae09d598f103694d586500a4a012a823ed3ac14d0476e61557b7a7af3e66b88641db407efd2026f454106d08f12a891471e9d9305736178e8e217b93cfbb1efb1524736b72e3d2c81854ed53ec29bf0f0fdb0e7cac3c11dc5900d4c9520af6f042576f77fbb1c784795c7c927cc0d44c42ad8d0106681fedcb22775039221ed8dbc0a6678c9594b45060d35aeec82c96770acc43a442a9ada0ba24010674b4d65a4f00aca83b20e299145421ad2a4ef222af48ee59a9b56497604a615e3f562e8fe0807dcc95752c3e6a8e04326cdc7c95d25a4d4692555ff4cb8018f83b3bb5fdbae5e253e21be322d2e22f42547b8984fb1c445a9e45303cc4280abafac9a8d6ca322984e5ed10c9a5aaf2128477cf9698fcae565e17ee7b770f9a005cb12fd9ffdf5bc83f756d0b488646b1a254064904791371df02db906ebaa306a66ccc3eeb2fb106e378810cb799793dfce0ff48a9e4e002ab98d64182081ae800a7c823a7aaefc7fc19c6d72a839dcbcff2b83d4c78a54f71394e3c00ed43fc63bd790d380b38d9c85e990ea16f4bd979a8179aa86f4e337cddf8bb1e8a597d4e3dd4254233450def74320da94462c4befeed66a0d2874f5d39be54d449c8b3442df495c2a0982c4e67ef99c0ee2f85c846b5bd13aeb8ad4bc0d73bf8602f329e5990c6877f8453a3ee26602b43d5cbf622cf2e6a5756509c0d1cbb7032391979a43980717204d84a9fb0b7627f36feb3ab7aec4d199e75b22747cda917cb60118c41eb6abae88d86c961b97d6d37e8cc2b4e7ad842a961100d3bdb8b4f8edf2e2cf45fe68193eabb646dd5ad9e910de5735000eb5d964a11fd0466f6c323dec772b2e6816c449a8a602fa2f372eb441984803aaaec90c6d5c041d46018a098cabb920b61a48e560068a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
