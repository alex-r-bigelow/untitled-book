<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"556ff3bcc1773d837f136c2697772afb409217e67187e0492ee65ace0526b5399f5cf0edfc7fd4eda64fc63b92b8e696b5a9f4fe70a8416a9ad8298312c49ced9ecf653934e966c24e9f0f8adb1335c15b6360b3829ce2425ca4e9c575c373fd7a2ddd7ae422c9edc9c1ee66ba8b4b17364aa10d53fe7c26a2732efe392d07e78fc9b1c9770c612c8aca61c29f395a7a00c67129bd8f45dcfdef7f1f9658c345ebf4e57cde6ede5bee3f4578f53f699656cc6c823e5f1d04ebb8238df010356f6b7aa0d536cfe6a308a4828cd07e2dcae517d5f0d440cf5ca10527d8280773dfc0874cf615d27f22f32632c8ad9241140002152b779f0c68f0363205c17c8ecb32687f94529d0b12fecdb19ed044705f9e9d1e609cd7eb945bff40f856406cbf63fd80abb6ea9aeef5eb5842695c1f23b13c4821843d386c61d7626c62afd5e4854cad6e568ddd597dd41993a0ef0c168f8776eaa8aef71ef0e5db897ea3ccce92849fc6df633ed061bb9f364f37eadc2372afa19f3e94890602520d521bf912829864f98a2e260019cc0c306cadd3211a3065fc4bf62a591eeb1f308cf2184540e32f9bfa187862e5ba59e0ba383be9e5745c7992a3e4049d0f2bc26a93443c44a7c549c882723960afbbff00a4d2cf0edc79d9f1c76437ce9fb57d1108d26149fc1ff0c5657a12b87cf32801be8df575eaa3e975f7336a17dd598c64b804caad4a20ce6ebaaffd859133258724719909e8a65b3b7573eb6dfd908534d89925ecb46a0ddfadb214d11d0f65b51c5528f5a1fe8a9742c3806c815477bc22018d707f803126b9d56b0ac74e4f0af68e1ba6aff707e413fcb703d7db9a125b9e00ca96f4a6207861302e5e0745ba4204624e063a95fa0aee65e13138a11835d5ce82b7f051cc155b3b20e34b7dbfe586138c90f29bf4d900f170852be3f1877df6a1553e8162b34bee569b98496936d2842efb8b919b8c1cdbb20c34673fb4e931bcf74cfa9b2ff214b03ca648217193292c866556bc465276e1111f58401e3bd8e79a4d66060ac7b0a74a820a3498accbd20b97629ea8c04e7766a253faf81237442651e7b9c9840fdf1c4b2144f6a5711dfbbfb64776f252a6bc09d5188e0163ab05cc40138c695b5d635201c8b6ae9510f4c6e0ecf824457e5c5234759da11b7f3dd8c3cf905478692d4832093e72f6e08b69e228e741c382d4d80bf3363b9d00082b7a86971126598712aabb86910a791c4d40671db89c246dc91d01be10421686132e4d953a556b668a7b3ea6d9c4c2e69568720a445f145cb74f08e7dc16ca9bcd0da0c402dc7af4b8fedf3226d7b16bb88b8d8dce39b362f96d55196982193726a5e6caf776b9bb09892577fb4731f31f03783082d501b305c5d5cb7ab3fe4dc5a0eda411477a4f70ec880ad4d5e24f7e5041956a08f70ec7cf9e7e27b4aeb9d23bb4a5f3099e3f4fee97237cde1e32409dca0e2c01e851cb1a296648f0dd75ddf2f3cf636d73006d579f01b629f6dc6933b2817a2a28c3a050cc0cc6fc06749fc3bd2456517ab683e93d834811a128e2a5041ad9c76720daf96f5e2793c75b53731f5a7d6482d5748036be2fb619c9f3d4b63bdbda201eb790dd91b1978fa12b3eb093a46e568c2a14adeda3fa39e95baa1fc6e178e9d1527b863435bd6d55bdfb0f6fe9d9c1300c655aaa772900aa4dd45ca98ceeb859f27b5bc9a18438542ed57272270523536a6c8ac4f6a825ffb8b8d4482777721629b4040d4e7cc2f71f0578c53d725fb4a33702dabe8b8442287713c0282488ba4cb12cbf5727c76fc5dddafc6bfc44999cadbaaec6ff19aaec900f1e638070680a5b32bc8ff8355c5b5a3ac5e702348e5190588a1998762400781bc17a30ce70a872a0192d3fdb7844c445d875a96c30d21d663f1dbcb4362a2240332f7c5e91ae37c57aba0ddac00e2505553dd0550a1e878447c9ac6e94e11b93e14c196a40b185f83698c1a214f74a89e93e5f5022147caa00dbcad8384d6c47badb5d9444f69c524657f3f465b6d80d72cd85a7f69e511f2baef6cf0b51d61eaaf68721243811173771e7eb29154a0b9b53159ff0fe4b63f910dfc72ce8505585e5e206245e73fab22f7aa2aa33e238db7a7e806787adc7443d61916980492ed813ec747e81adcbcfb01058ac209758c63678ecb5c7c9f28aa9081f869efc03ebe7edcfde9eba3a5392a40ad88a7db8c15cf60645924a4aa6679d2062037028df22014db7609453e60e07f4c6162883a0912b61e776bcb8abb62824ce13939df569dfc9f3cca05e7ea2eefd62ab4d34cb273f7ff40bf80c843d69d423f22a1c2d3d60e2e06b1d96e75152d266e5a175d792b401fc91c59c2e7200528ef8242ada10d2208a45e4efca952e39f8641347f512065b1efb5dfa09cf9e2f4ef82af339c05297f33096c2ee33a395adb2ae31dab7d9b44ab297e572d94dadca612068929efcfda97e20176ffe57bd87119c6026302dc21288e3fdb347d65ae156d6acad9c915847e08f3d21b06a89eba5842cccc5af50ef45cef666fea0eee7ef8828661cb29105e4aae2a3c8f86243fdf2fb2ed293c56bb527e9ab9abe50ae083129dac433fd47053db23644ebbbec821375a5844210ab06e13f7e0eafbd2eb6b464cbb17d6b3f86985e25b8248ea340fdf8ef84f8d21506f949d2cd5b74f6eeb9acad9b3560a8ef753215192c83664181660dfa96db5555175f86922eccbe7f6371b21acfb7078412e799c99fd71761a54a59fdfd62a5ae239896d33ee17566e7658bb194624b4d893ef896041010719f981dc83eddb43eb331058e7300b18353453e2e2e559df3e17dea304e391ea4a1b32e03e95e162a1059b5ccab6da21c0434f96b2072f4be4cf9295f8dcd159bbd7912aa1a153eb3a3219d4cf45cd870593ba76421375d08b0e2c1b58ca49f12de11c70a7d085a3f964cfee3a959c672baad25164678f076c2490951f673f903c7d1dccfd8415ede1f535b26896d0d4a179cd70b23c93f5e6a14967d6b2f88b4c8060ce7267017449c1cb6e7f60eaacd84f303d74227ba48c772fe19cf449e41cf8f71ae2fce0e7ff953fb971fc5baf0ea63cf980ee5a5794746e922c6599eedfebb58098d5faaef427089096c292c71d1cc29ef5ea0ff8730b7d191ab36a523dd00de411b9fdb164b6733c988889041d0f9bbc6f63bc65fb682ac22b3326ce6d0e2b989fa1c6d278eb5b53332725f0e6dceb10d4820e443b141e2f65a8ba7ddbda8a23e90358bc14dc6e57a60dc5875373e328bc28ed2f1637520ad25efb3f07757e90d840a53f44e919750f121ba4c041e20a2ae732a155482b823be52a10e359542467b71e7dec2a1e5f3db67400e01b28ed5048dc8ff458f7db40b6079199309bf27fc51102221acb583b41af91bcb474dd624d3a07c328d294f1b3574ecf23c50917cca1966dac67694e4f7cac7e21429b312ddf0151ae1a905b8bafd737ce5c391d117925fc8d292bc4db621cd6fcbd978beccb1813eb7ab88ed5e4c8d48a54d4dd42793e9e50cec077488c629df1762417d47806da8e332e6e0c6f4abd12cac860bb26335a81eb2c2ad66188d2404556325843ff07450dc68809bb04c5cdb28e0146e22edc285b7d1ecfdf06a7311b4c12fd992d8c1e77d0038a49aa6acbc3e8be4de7e09e982178060495467c6dca357e27e2330443d54423ab5544f402e3f5724762b86ac570a5a3a9eb79c464cd6710cae41d08e172af169fccab5b4c33df778283c4fd6ddc8e71ea19b53e068f9a1257488a0b850056787eea659529119655abbeb92d267f9277cfcda8227830098fbf6901134c225c88b320c1c9b7eab25ac870ac300173ab3c167b5ce6ee27cd5cf7d846633b4e1bd6345024a03ae9d3ecd735e4a26addea0461267add49e309c1505b3c5559aef26077e6605cb93143eeb294b78cd9696f4b251fb05c06a539a9ccfbedac1d340176af1a19da512147ec852c71b78834fb86025619901e9c007488976f9902ed0cab85b5176365ec5ddb0fcd8d5b81c2b88ecffda117e72e4f7623f0e42104e993fdacaf084209ed0683bbb58ec9cbcf4307354aa5096a550bf2a30a4d15f74f8506d28baff0bccb2c030d9f30e6eb760072cf08915db80024081d4bbe42c08e3844aa0b60d99f1400e9ac58988c03d3a2bd21934dc6356a7cb87d7d2e64ad51418b12df5fbdff423a871ff7fc392d73c7dcf4efead0fb13f78f374d0002d0f43917ddc63931851b0b2e6b0183bfa574e4f012447e22ca1291f8d1670ea18bba4728a0a07934bfd379d69c93f660030d2d3fa9831b3c1e680b46099738067e9606ede0c6f25bae93e6801b186aeb0ddff769ebbc118a6fe76b17b736b55a79b88f02525be74de2d03e87d80bd0287b301c832a2b3dcaf9cf3e80361324d8658a3c43dae289cec23abee6ef446c22c6e38eb9e9de2d614df34fe02d4949f6715868f4926ca30ba7bf17d8e191313013b8cc565819af56eb628305ded72ef2d7d830a8d88b05a21765a74db7bc9bffb60eb4614fadbe4d238d44ae6faca0d2e56451de0d0adbac7e2838ab381dc5b1e8f8b648f63e550ca0f4db2a9d38b69b9904c75767676b2412480f0b6e0906aa6b78b88c6934d3567737801d8296d323cbfe804569bf8ac8eade99495526fb3b533c19725efe01df066ec96081d61e3cc609d84cc86136645a20448b83a55feddaa07df869294c22b2813b38523be64828899b65909311bffa5d8cb6bbe19f0a47c5fb1fd965194889273c0d7aae46765ade932cbb60784e875f9ee58c05e8ef9429047a203e56e11eba3da2b0389530c3ad735d5fd8b64cdd79b0ce3ab4c844ba4e0942df249caaa90d94e6afd1e376c8f6bd3a2da4b7e30102b39497c0ed090e6cd1e9b1355a14e21d3826dfcc8f40d7cea23cc1cc78185dce48413d027e43c549debdb3a9e2dc29bfc1adb0da6eb135a5173b1b4a4c5d9cc778109be0846fed4e81ac38364f3713b0c562362a44458b8783cc5e311e6ac985fb0d149a8dd3eacdeded6d9b41927130ae81b5d76038a7f213f34cec4eee99da5674b4cecfb32ce8df61ffbab88f9a84a67c5b818b52a8a866f0afaef666e20df8a00d997a509e047c5d3176a78640800b28a82479e704e59ad97389baa56adba31540ecd5960b1450705ea554c6df7241afa6cf2020775a6add7fdad21b55f1f7f1316341734c1de5e03f90493c8525a44dd432be906361cd08868e087dcca3cc6ba61455e81822c4c90c96b28179afc4b77380b1911226822ddaee31d4974d7399912bdc83f432a68ba5829effff42692f1b88d52510b9e98af2b00b4c94b57c9c3803c778799186110787452646d3582c89ae0b1bd24cf83713a7ba5e25b090621770ec153a61536eac34754282dd2d328da0c0ae938593e46150d931d1494124833e4996c29162fd432ff5521545af389cc10fd33f7305547384611457997e584e9e9d37e4cf42c671c7d8f27a4a04ac2b276a90e7f2a9aadbb1982944e84219ef230553957666b5545b3d5205d5f77764ba50c1fd7fdab61dc56e25fc068e8edf03a17fcd68c0c44e0ab50007d41530c816c2687bdb6ae190fd5988115364faa8785e9ed7a3b88733d036a49c478f2d7219c7c5e99bc44d9754a49514806f250f5fd07379ad7bfde8254824fc04b86504d50a798af611f3d844fe69d1e8033abb911ed1254c4bfb98237bdab516669cd3c088f5943bd7ae9eeb0336717b1c8b6e78be109f3375e07039d063801adae777617f51e7e8293db432e32bc0d8d9bbe33a0e16bda70f2fdb2ab8675550302fd60f0a0ad7a3c3dc9ccecb8bda3338c96e05313af1062c630f880d29f17bf64ed7a85c856865f23c6a4d9e2fbe45e0bf2a74485a6cc74c9179737e9d24afedd01e2d634fab3a515d7626fdf5416015e1f92a48b6241118affd1ac90f6a774d674b4652f5b771069c76c2f9a181bf1e21544a0f066c10453223fd03b04608341dfef6febdd93c85233003b675b49e177076d8adfbead245a1512e36a7e5f54180ffc8a2cf69a8ea67358e5474b494c4810206360b2891e5f1956a3948ea30d0bd504cd8067fb9355a3aadeb26ae71046dc712ab106ab021f1913642e53cc80b19851b48fff38d8e989dfcbc865ced51c39e45f823a12182a316ce30f32f6eace4191dde1e19fa81960bed47bd982be7b5df501cc0f14c59bbb44e27f011eca99842dfc4f69f164d2b14550b7aa77e3391076916502a750ca4ae2c5afd1be5c4ee5c71800f812b60b22d10613c82412fea8279ea54b63a473ddf02da0f827d5b6494d27276645a34ed22f3b2a6cdd12442ed20de8122b5ab5a7bed0f12da3093e14fd6422b353b75ed3e6c5764d77f5c4e5fbbe8acc3892f7ebb174b4b25a8f634177987b70815fdab8396710acb72f22307806a81ad9ef189e6fe606f5ad702d5c8680be1b8c4d8b2da2fd7a1934cb4957a9b4bda11cccae63f3e78cb7b2e814f40e4c85fc57bac5ccc074ed3201bf45262388f17a4a04b9c085973ecc444906e48c6d2f4e359e537afa4583f7114ff6b5bd60a3ee6b35ca39181c84cf3a1903f7518863b7bd1c3242810d92088427e22d8945f1ddd0c2178efc7fb0a0786d8fcad211f589cd0d5e502fde2fd99ca54169fd11471aa02d8ec2599aae1d0e82498706e4c5ebc1a5473d65bf12cbd5001607355e6301a98e760df83e36084d713c8f122c94697ac26a590f6ff4e78044f95ba63a3aceb3fed7618ab8b7df94e79e259012c683f6d764ff162c7472157f9548253d373bc4c0e114cf3c72ad93e4be6db90428e72942ad90b2aa3b7d6d0711229755b9c1b22eb5f8b27b6500e181fa8717e8c0df2f45400224d6aa4fa79aacf6715ebce48a773d8fa640ff6d04808c156babb70e10169ac25d1828946fdcd66dee4666ffe0a3053d251ef943b4b9cf2a8fa50efc426ecee32b7956225d3b7da60c46d68e7ba5ff90b796fb6bd4e0dbb6a6fd072d1d7ba466d6c8c2eabe6433d3d1fc184d0acb61384085fa5c4a8349d88eafc478bf138b0943dd3437b4514f5af8a6198cbc2762d09d00364f9f51f8265bcad8ef22f4a88c611b28a94e668fb14cc0f84bb506724e443f70996c86324294a4d7da190fd21f3a7e418672f0f563c1c6d629e06a67a54e02f7b379e1ed1052b415d752cb24938cdc63e02e71c85e4641e2662995069438805d98753a71628e1220dd83208c000573bd60427d846769a183e8079772df36ba78a993905316f73bf505ecc1cbc826514e7addcd8bac9cc0277fbe53a89c9f875edca071b084328cb5e188856af270dfe40cde57d2701cceddcd6b82d7a42e81a48aad1860bd61a1ff61e1a01731e84998da121fb23ea097fbc733fd95b3cad14f1e2cf6ca26f2590b56991db3e759a9e1a67620e343d3a76af0534fc0a8110b851a530ccda2725d0a8d541233db3edf6361c771d1f2bce649c80b95d8b08a937ac67bb1e48984015cb5aa8327b48b74bba1860cd137b82c939e017dda651690fc80f2b3bfde243d8885139621114546207c1e3ddb63cb1ebc5eab1d84a24c2aa43e343fbf7703acadd32672a0d6f9db7c5b50e4c4a334ca1b21ed0c1c30e475c912337d1346fe0c6ef03ff3caf7511b5c7debc317a170869c5651f272d4496257307fd8232362ac894849be5446bd3907e25af88cf6d84650ade07525e4aaf767debbf5161d63b26cd6873707db3d20ec6732a43d64ebf4d65a3ef3b152832e8b4917624074a605aacc174f8db29a62d324db6c5c134478393f6cecbe590528a1fab7a5ff7c705c806ea39d2ebe1fd85b09268814083a1ffb78fdaa97c2f78a875b3cae9df34474edd801f1241ce73e2971d776dbd4a6dc741faf3065207a1e8888b4af5c9cc853a99dd3e760ba51a4b6b45cf51552e24ba25d255b1ddd8d3f2ee2b99f6a80074a88d2ad8a2da49ce039263af0a11c6c033852618bca0734cffbaf9c05f81b66182be095ce0cefd42006cf8353ca71a3fb1b1da2b011384aabdbc05ad22016d8e73cdb7cb028e0189f2136417836a216b476077410543565c8a2710aa0c1d261bf161bdb5d3c310b13f84cfeeba60f9bd7fac3d09f5a76909fa53c92b3775142369b4c78d4516f496069204b1c193dbba1deb88ce281f7a7b17cb85885ff2d0a2be639d7f903d1244785a432dd51f64df39ffc0ded837e7a94f445f074da7ac317c8957ed8e7ccc1737aefcf702d3819c3cf10f99dd3fc2cc0f6d27199ee412b4804075d0d98782f008c193e7e190a07ebde43abd0426c8a7db9ae9d7cdc4e15efb4ac32039d339e185e81980dbc9d0c1677205b3a5fd70c33f2949440a5721fc9260cde1c686ca4264040df34954426850f9457ab3176bf4924269a5122e78e7decd1c71413924d04821c22b9b9eb58b9eebf4818495e68e13aab32063ed7abc94d210b34469fae023b77fe30f9213fe48cd493d087fac01ac88d312785589e9586319a324171021e7a0108158712cf6456f91b1cbf31b39903b05e512c37fccc29f07de19d0c53fc291585e382b053e1e33759198b4d7ad8af5bff4496b683f2a6fe84e5280e360bf08c507f224ef55c5c6815ed3425ef51422dbcd0559da66a36fbb5544d7a9266b3ce6ac5f945df105b77cbe68c59c448b5f82d1f49d828ec17be8e71f62a3392be0e8c7f7e6b999700aff29ddc6010bad23948844973161e8dc9e50207c7df9a32c6917269bd236c6972f55c489397bd484594c1418a63d4ce4a01ddb7eeb1f5d17e503adc079210e4caf281821bf32d935dc80d0455b5c4d5786d51674d92b6af9f9130843571e5776f76ffa83741d9d4bf220209a684073477c050d01c4ff9b14827dcfac971e6bc18e762a9ff913e0f19739707563e250a6bff046363d9b1f961d5455d728734865504bfa4fa308d8811d896fc1b13a0086293ec2317d792f6ba6c5df70392048ddf44591765fc4d28b291415f5142d316539c634b2c502719d1a669778fe2ed25b8a8a174efa9b3dc079fe274d64be5c9b5390b9185ca701eced3bd1f8116878dcffe63e6848ec2504d816020610cc138e925c5809cf6f8fa9c417775eb4abb4cc29454147ea47320af188162fad2ba9690db6724679a02e1486fc1c3d2444d9a154ca86f1b66ea6e0b2d9d730a9afd5820b2c38c02f2cfed09b4298afff29cf1d58b1c5e76e92ea043d38bf60ef97bd57c55b6bfd83f9860a21047cf1bad924718423d669578cddf729e77a2ad2fb0d97d6facd615820bf5d76727bf75ea314b82517941f95dc3a4be0ef87a3d6fb593414b33e20e847ec7393c10c5800f4e5ecd67799432f29e501f80b1b8785ad4b4f363d18cedba0667ecda7f55a63e42264f09dd260680aee0534334f8a8bd49aca24e9a4063434c4f66fe937fc6ccb8cebbd252fd21c55fcc2f515b5576a7e422451e6bd8773b11122af56a153a3ca0098ebc24ecfd51ad61c1cf646f1291ba767128ebda86c69a1642d33c6ab5f98f94f09a79ea501c012e12ae066852065e6c5fd77c341c9942346f98e4eb7b8901fb66267211c6f7ddb5a53758121052230db1a7ae34858b14f8549b1c39927cdd9549c490d77219df579c4ee6cd0153e0421d9eee8be7cf44cfadcefd4e3bf503180d80337aa40648a43d77534eb0aa1edecd1a3fda897567802ca582a590b7c8e8c174eebfc8ffdf13c8f1c65b95bd2d2b49960deee611d830dbaf0b2696ca55583a610dbcb9510cb015bf98b454a832ff7e5076990ef4212d09eb090881e36ca58b2a44ebc69ea09f7d19124a583c75c7c93c8737ba74dfbce958b64aaf1098536fc2c694714a90e763618a6f8a5640cdf87b91bd54cb9ba406616380cf5f07ffb4e0e24ee9200d9c5f43f18ca6967a89e4b227fa2d792bff1449c2fca41292eb7e3af909f405283820f65d0421a50dab256a18da88d2ce154ff1fe1fe940a6589bef1b4eaea7b41fed1e9d11dc30794400f0d538b28af6c1e7b1d665a93bf3d2d8ce598723134a469289c10d52e277407586cc907be77cc4efebf1286c8c77e1e85eb3c94390891f6d5ee41ce6077e3e54d6b554a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
