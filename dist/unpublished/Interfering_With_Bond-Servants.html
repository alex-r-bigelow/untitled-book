<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d39a025d34aed9471046590907403571508ade7811d2b09e7de5ff04dd19051be09b8d09de04b32fc7ca5b16e7b4871354c3be903e4b95155838afd2f88b4091a7a24bb966c2cb6203c2b86ce3507a1e64e372ae43334f9d99eef76c19267161eeed88fe2bf2e604af42be443d8cc38081f7721fd2e3cb584156c6ee01ac4b62131f77280788f69e11bd1cc3dd66f443c64c79aa5d693baef05f2c36d54fab53f0709223c4d179252f43465f13c73163bc09e5952a38d4fc25906d5690e7743a410d7192be2168c77081ec599aed4c75193a80e924e5b2e001b46272274516fbbe49a4c1bd772bd0587c50fa9e84bb298d939781c59eec4c74bd64660013c57dead7bc648c11ae84a79c98721cdd9e82ea7811add9ab54e652e26b7a2868acdbd60d336cd6c803b36667dc1043f8fdc26ef5c24d6878bfd1510c229eb980c62a4a882002afd72c45d0649383c09e2719b8a224a0eb753c5263830adb893630b11b502038e401792bf79690ed86d7852537384c3f56979205a37ac5c775870bb87f45bbf75c73201330a7ee19045bf9c1b35f8cc8f5f0d46a5874f23603a776f7e65bd539dac07788b942a07f2eb04c5c8b1e4e5f88e9f44a3a9dacfb3a0f2d3f81635909e4256e32ac621d8e6585bdc94e3cc197cffeff6200bd93700b2c0b213eb81c7458c8a230c011c91d1b872ac3bffe884c2ad4a37ee3a00530a2a8ead6dfc8667837e1f11c448a3dbde4a4d721b627e411c3094d9a757e5f84cb287fc678c764dce16ec8ad46d6de9e69269c1459c68a748cbba5de38a430186a65102eb0187ca95c78ccf6aa47696071d8e93724d89e7452f13f2c6fdd02510a84a60b21cc0ede257ac34a96b4f8bc4b77d7b634efe6b60a69205562ecbb5f31d228b3191fc46d8ba0d38678a5c0fe56c89f342cecbbd9b77832e434d6a4a78f7baea7b50575f2824228e64f480fc1529064295a023e6797512e8761364faa76e32561faa4013b387fc93f0dcb7860640ce346f5e8728298f5ce165478e88413904d42ddfeb03ac560aba63d2aaad443c50f89f7d148345bb0d3e2b7d60e4b2fdc3b0bd5be79c6b9e7f43a440be237cb632abdb9bf38648ffe2fc479ee771a94fd10abdffde88b1fb302a75c1e6f10970fedced8028e5f33583c935aea620e9c1661ca23d9bcf012477c890990f144074650ce9145e4890e1af9814500e5a7ae07760b18297e4d49eab94d87f6f70cad48a5ddd49841007ade71b4c882ffa85147aa312cee0868afa350be70603c47db72b23b14f3fbdec199d97c1f35200f4945866d5a87605b5d2700a7eb11eb3b2e34da99e71eaa0e4a7c800d8eb9b3bdef069a4fbb7bb9e3acfecf235b4b2f09359f64f5e2a21f20d6e8374c191e730eb558e71680550ce6138107a8645a1836c8c29a9951aed95d96b660cea924198854a76709516868794f0c27628b9239fe7c08a9e4b2daf513cc7d4fe5625bf24ecb3ec4b381b052f714ada08cee5760a146886c61b71ec5bf196d4ed601dac3331aab5d113a6091497598c7b1ac1cdd4e533c888204f3be0c0339ef6cd710c2f23f890f6c90c5f160e5f3f4c125e0334a8b0f3e384d74ab5a9debaebb794574baead54882699d785cab5370d71af02c16e0478d4138199e41cb047c2e1ce31f3f6705500c84459ca6d72fb8225347db35a8a31961a881f508684137ee2613d627f81773ab2706160a7167139a4e57ed19880300bdda77f04143a361583b6093f7c0a5e26636e5564dd27bb750e0175fb5d88c47de5d047f989d9819bad9e0e5ff55173d1bd189c6d35623eeac6ab7f527e030a089be773251bddb4e36b7143d388321bd2409cc4d73c78cee99b3b7dd0b81ccca24f25c5e857f7655a3b8ae3ca2b4b0655ba48124be9a909992c24aa187be43fc8550d2b2ea62ee241bb44e4c823b1cb634fe8984cc484cf8a783b6f5804968746dd455cccc5135cf33ef20dfd5ee737aa61cca6daa6590fb25403d672dc5562316819085b283dd7ffdd45fb75a96180fa66ee69ba7ff2d26f998901cc61d16ba12dc917c0b3bb899bee87fe80f8ea7fde1711751a1e98c2e16532c2178f7d9b0532e4907f695625208f3c98b70c6e00873a000bd84d40ffb0fdbfc524d4d9f8c5ba5b0d88cf64b2eaa1174fb34c3d574e4a6a1a16eb5bdea7c5026467eb7c171f5ddfb28878b8deaf42e269b2a24e21641a08f8bd0ca1d458fa90e44b9c807170aa6fa0bb4ccae636ea962a765fe613f896b066ce9841c7fe4af17befdaa7818af1cae8b4c83ff280e9d1e45acf55f9cb3cc0e02631421b22389b3d8b535b6bacaafa5dbf72579baad6d26f62dfbeee84e50157baa7dc7b8f09cfaeeccdcd6937c42146cbb53ae528a310086d0ab316aa147a831a17e264116f64c5dc583a24e5ee044efd9ec73bcbae134a6c01c1f7ee06b9bb6732567618aea535aea8bf7f7b833c9bc590e0a7e1616b5cf7a7bfd6c47ab733c4289fca1f11c38a328b2c84cd003d149122c0bf2ba50473b583bc0e5daad0b2dcffa933e72528640334a35ba828358cd58f592edb9e161d9ce0b64ad6ea907274cbde09b7d36481c9b7f59d8e4aa5f01221c373aea7f8172f71b87bcc364527640477e9671d3f1f97f6fecc8188fe5230dc7f92a5b81384f5b88e0cfeaf9e64047b6a16e276431039dc896d8538c9820385a1ae4e9f20868fe9e57768af8d7e3a58f659bce498c5415c8b35a489485ce0c1444aa016943a6879331f88a1dc740bc369a66b33acb71f736cfef3a798f5e7bace20ee0fdfafd2413e5ebbfe6f84ed3e56c39775ab200212ba17abdcd53d134398689be2066c8388454f4a3ec0ac335af0cf7f5be94d2b352708c1976f4d343c36cafdf111b9b193b2d365b5d1aee734b82e01b7b5a9860a44a8b84308d1046ebb969bd349f9204e0a2373ae358a386edeafbfc0281db278eaa754ce0635b15dbd803658f2cd242d5516691fcf9dc798ef58ca6a5fe4a27c8d39d6c7f0ab823660a534090cc967dd0719953c2b12d4fa7a1090f169c688d6da2096fb7c51b2e487962fa52046356f85c537c556006a89f768ed39b229a71ef074e7edc2aa74f5e995faaef22414ece77200b0295a7c830faf1459ace65c428f0b761ca0492162c341904baa5fabaa131f575b1aaa411b4cd4810a2bbd63a2ddf0d367a8d468834a223d314053a6953106261aeece0f7b7d7ed55af5395f84fe07eaf75d0ee8e3e5113631a835fdc35c8135edcd67b5c00d0245f6163ded2a31f32cea4842b85fb0907c6f14f29e8aaa2be0df70e3494fcf30cd69b2400104fcb15b7c68fe8b218a1df5b0a6e3dfec3a8cf821ddf8233b21279dd16a87aa43bba42d849aa1e21f4bd9643cb55fc67fbb03d7d15472e78cb22d710565c7d2cca91d3fc69e4eb541f8eb31154ca6673cae98725b08adf26864f556f71544109cccde515d6e892534f597a54e114b6c68e7102c8cbccf216acd80d84deb180cf7c4e22360804809157b3df6a3eeb33ed470bde885e92089ff6d51bb3ad7df0a11178313a9f1f287db23f6d0d5aa5a99f58e41ec4ff53451512480f7c78f041219254fe00f60ebc62b9a6d4b9af11d41c3429fdb6ab6a67a7ff3a77df51d6a997269613d79da0bdf834ac00432db94eb390480bb52f73d485ab7f11a02180956c604ef337132be4d8d5fb19765d846c699f2b7d692027a14f2df17a5cd52865c8fbd31f52667a729d71849330d559d78e6994f3ca7aff7973e15c8f91baa3158f5338bc7ca3234eaf244881bad32ac09e65faf6d189f5fc54a7867af671bc93c37266cfbb08a7e0886202630183d906c4b69e54c6c021e93b7c371fefe5d1ec3a2f98af8feff54f65a33af648e4da4637f552c44467b240a3c7995f09f68ae236bf1d0aba0638ec560b2a57a1b28dd011fa4ea1a33ed5674985979253d153aee9c8057c4d2be959c782256daa6cf9443638b24571f80491b0f6cea400d957dcf511e5f8311fc4893218492f3b60654a54e946625a70adffe4dd45bddcd3f21fe5b55ceaa9f88c5f51fb96407db17caed006c8e8078ba0f3616ba104c7d06f88b7ba8142260c4d039662d3b1374f726df420215305bac965ff7305844708c9e955bd05da323179faebf15641ae5f4a1ce34f70cdde5176ebe39eb677f844feaa393c79be8afe5fa64be3bab6b3d7356d85dca85379257d661691a396fef1097b47d5082ca8b177a21c3e4665c4dd1badc42c3dd3821700aeb9cb41b7b334ef3ba232bb647c1783db977ae1477ee669fb8ee125e7175ecf3ed3f70f24c7dd6a713b50b9bb4c33250c16a9e0fe3e3c7a0194d9a768aefc3cd1c8e02d38b087adc742ba659647549b5ba301b3d5640ac39332605e1806d4f46f29a8ec158b4b25bd2a25da3f27fd32f2f39835c04807f4ce17771ad69798a931a22d8fefdac3c2c0f79e633048074bf4c231af8878c6c5214552dd05ac6acf9390e08048563cbb0b7e7fbc0e025905f2d9e83d7ca3edf76023af9931119038c631ed66f387436fd767afc74cfb0f96f76fbd1e4830d6a4c8099440d387255fa5e8139fcb450ba2ea3636bf4ba88798d3d710799e2e608391c448a4c31bd266371e5cdd7d6f2413e159eaa792b496f16e002a1cf4c1a7924c02a6694ae0f0d97fa64f574104ece5c5182ad339e1fa21c58a6d5bd582fce0b94b0a36087de59a330f827d10d0d4824eda0fa6851ea851cf5936bed8aecfdda532c36a9fef216ef6342805f0589a9da98742808467555bb0ef442d6fba60fe6687a88c98b5eea58472a0bf47e251fee06d3effebd25aad83c06dad2ec7a33a96d432a62160509d6d5febd9da20ba7e0f14954c9e5b3a4ee9fb975d638fc8c2ecf705fefdd30adf98eadd2be47d2cb649b82099d06418a82cad1f65446c8cce6dc78f9e88d9c07cf09bc0d71a112697971e7e4cdc54574d85881427435da5a566fa8a3dbbd9f5094de055d84adaf1571c67a97c6e31e80de5301371f82bcd8aa371ff01622bee8bdc9830bac1fa025aab73c028cd17541ed339051ee5db11cdf21a2ada4a90b0b45f61f56126517fc357255e7ae553c6455e8c7b7e99131aefb48c0137534dfb03586a626bf953c355365a21c70361db86c5e1c39587e275931b29c9301ddc9ffe534c14f61188bf85b7b4fe07aab0a639ad20b0d79fdb4b1fe7ad6844a8ae4eed22654c36d9720eb78f2b19ee11864e2067ebe5f2682e83710a8e00c4b1819d6c01ce29ed8eea8f316c640876915845c481fe8ea8dee99775847915901dc90134bc17f9808f4d12fe9972987a5fe5c9822b5b6dde59e5b2ba703209d4baf3e2b12fc0136c6385b2d9e2d8c11baabb2d3020318aee9e2a612a5e9504aba2b9c9c2acf2f6067a199df55e2c86395e8af67fac31ea51eaff65044b6feddc52e346ce3f6af8c02e8fef7dfe74ed6f6577d542f3732c41e1b9cef481995aab71394e44148f710bf1fd0e954a669a8226e7e67e92e7f696d0a8b167f7e9575c08ce4de20e942ee559305af4ffa89479bf00849a39b837d50b9dc07b38d0a1746a0d6bb2390ba5b6fe84593d88c1c4d40bec6f839b5d85fa2c5ee75070e8a7350b3ff641653f7c36aaabd198d52d50cfacc3e70027d31f0de450a602d046af1013f65c7f4594de4bb835e777780f8217d3c067bbe828c6b47e28c4b5a742248732a41a88446f5acc76ac147813ad5b0a6080b0eefaedb61bacccc263a908d031cbae4c86918aa24eca789c4aaeaf26f86dfad5f369523a23325d97dc9f0078e975f8ecd73b3a8e6faf32d563e12a37e245b02c2d4d8e93222477f56411c5539c72761371cf13166f4717d60a28482f12eb456c0c759e9efd99642e27b74f0eabcd6143d4aebf6a818d5b76e83d32049460f8781516380db4b7c733e93b795e660a329776d3869641847592c2c219e67a8868700553678448910d819dd243e7d15d5d02dae371b043b0b2b00c62096a92c73602b9830e853f668fd38c996310deb66672dc0045d650e65d84c126ff4613b6dcdf59dffd0d6e3f9dd8e2aada5e5001b09f0aab0d4315db49e92f418552fbfbf5514223836796eec31d0bd6037f1db001c31b29d3e83c7979e0f2ace07172eb9d4e4be1988d84e6e389ac1d9f4121ffdaefe647686c5e48ea875e76576925489ea522ade60c3074d66e95b09f2e411740a845f1dbcd164c536373ac6cee55ace563bcf484815420075d652e979b4d98aeec39f8e68e02f372796bf60f17df5f1d0b7b4f658ae0f46cb7ac237b50f55441993658795f47ebbc3187c8d026aba26f8a3fc8b2c327888d2276b8c22d4cfa87294d0be67c1ecbbe096f495bd95208eb1512ac2cc91e01e0a54e6fc79a07630a4920f2b72f7f01aaae45e898b3e616499a9b0431bcb66cd9a7051d600d2495032a315c379d9f12af3d8ab0657482f7f2fffba028389b45857245aa143bf375841d83e2274412668248f42eb421a1dbd655874c0ea131a89c8dbc63640fdafdfff14d8aafcc6e236c9c192f2006027e4d3261e0007e809e34d4bc47eca379c2a0d42bf604c84d289c58e94bf611665c7423c7b6df916529cd6a6d2f9d54425d2a914c35f2dc86987f1abc2b7095845214dae7cc021e97f575b2c36f38ef186a2b47879951bbf32a72a342faa2d6c170c25044e83a179949a3cee0040e732979e1fb6464b8e7c6797f114300a5c4e544f09926dd147fe5029fe02f4db2ed302cc521229bbc380078b8f3256c95ef5973d833740897b035913fa9c51e2d3e0f5c08d339939f4a596649d2d1703d18ff1425d84bfbb4e2319b9d239f448a8e3e739de1e6fa6be2bd414339220373cc2b0908699e51423b7566969d0b627e88e1c96da0269af35c2995f381f41086ef0e658bf4ff2d767dac83cf5d4eaf751a4752fb8504807719180338501e4a2579970d6ac47a2b60a629892e01a3113500b24b074861701f5d048be9c68b869536446bf3a7f50d9db209f3a71d4c06036785742aa38c0fa8f992fa2afb5c63cb3a86529f1cace3c9c868101f2a784df78d2c272bb1de4a3f937f6830094acdea8be53486f6e293b137f2e41b5d71e770eeea81380d5c9648ff006d17dd664244e4e42c08df31a4c4304fcd3b4c0d14472e2f3ca7c3aa8a2433e29158539c20853b677afd08fffa84087a6bcb55f872720665326458f3be1e03dbefbe1f05d15f1885b0587f23e2f75441c40035036dee98ae0bfdb9b9b0ae98b7eb61ff474a64dd2c690e2444007f9e5be9caa754812c84e244ea4a1b09149613272bcd4a379659aca0ac8b21d1681c5f84a823cf8db38cc8bde1de80d9019f01d4f464579835857c2e6d2cbd9dca7e0523c318538403ad6d88e1785f5bac08f4359e6254288a46c71f4184d8549e25323c59b04bedc8cd3d81fba971775fe8807c4ca8f89eee36efc7ae4d344d5a0326db27c1e827d55376fdf315b98de9ae2af3bf54f3fc5186ce75a486da3db3306b2f15bafa5ac81bace97aaa508d6617a2a98aa63edb69f5b58e1830fb9063ac1a4155a85707aadf34cf3d41f6ca8e20d231634d57cbd4f90e5006797f61da360d98a44a5380575a082650e635432b919d8d650bf8a8f79b3fec4a63d6fe63547af467b95ff7ec45aadd0b3321fefc8dfbb1b6c3394766a644b857ecddcc02c1e187083737732b2718cde7ec5738c2d278359d554573640ce2ec12b64924bea4c210beee99fcd0ecc4f31e62a01d7a13689b1cbd27150bef6a6bc8083546621bc6cf197d53c2cae7730616a566740478b334c5e4bcd0b7489d618856bb5605adf939ff69c461575e9c9f16030e24b3d519590b5ff220402608f63ec07ecd662abb7a233e401832d6848d8ae77374421ec739d70376a2a2bc8750b821608130b11681630221744b52f1e7190de8e5ff6b54a40e8f152da8dccf5cfdcd71b4adff2032474fd5aa7de933b5e3ede941632859e8d71ed6714b3b74721af6d1d408395e8dd1d4d1153f1e3ac9d2304f63c7301b64de3884c02b460b2b646c0e9de47ddf774d1e4e66e6f5aff6ed6a3037ef8454c5676730d510ff1c72453dcb94869c59a096a54fadcb5a3c7017adcaa9e67ad2612d3c0a74c9dbe8a0a19f89dd6b7a535c813577314d5ca8dc409f0ef83dd18c09a0a502544564f9cb141cb24e36ddf6dfb07c26df92de1fb08d6c02731b6ec1eb6a1c6f224e6cb92684d6d88c69ee634696fa7e7681b019436b4eaefe019073e35b6eda13363182cd12f5c86291fdb74c355c022058858894f7d29509776d51d4119c4e8a5fd7ac5980f4c7e7d4031f0cc43e2051624512074cb782e9eaeb2fedf783bf355147be4318fd5ec4e2377e91e1f39c6f1769b9a6a47e91510b7518fdf4c577eecbd5e36827287aabecc29639a7d374d437757e7908e50dbc96a9b5437410d992be894226a37d8fdf440768a8edc44cee5cc9f37f69e3d1e068964a07976fba588606983857a37bb72138a00923ee810b1b45cc6629e3c041a7eba82c2e6c7a65eaea8b25eceb57d46caeba61be8852919c4622cd5688364bf09ff8ff4f7d08d4e098d75ba8f6aa66673b2c3382e4f016ad207747781e9f9a3ebf50a21a7b7a2e380b2ee2b385ee8aa4eb696321d4388c8de0731944922953008dcd06ea0cce72ad1bb53dfb54cefdbf7dc873f495c2f43305e32a4219c285f43857e6944280f1251d78e323d5f62a59e79397b8f44e4feb5873a32f38f44dfce991f50f38e8fdc3cf21560783af38a84005b1e7ce0a4cee0f514f2a5ce825afeffbe45ad1488f2d1efa3a18f295b3c295e12dd65bd8527c7a654820a1589f19e561d847977c11b175483d89b515d30910006f778233ccbb9940fb83c64e399d7995d7d2a7eb72b68446e065726b2d450ae73926ab2b15c1eaae69cccf818870e8e358a293b19a30b83389dbd3f0990dc12e23b6f948dbf983eeafe53d4a57aa52b711da2503199c3165aeddd4cdb2e001e3d5cd5e3300faa0470f1b0a7fd2bc3e40e9ba694e212e7377b0383f1cba5a0528ce9ab6d68d1b01642a053deb8a9a9116dec01cff66044df9afe42ef9aa6b0c3eebaccc015db39386462007b3fba3b76bf06195c5400638c5f5c9fcdd9c7561ebeb4e710e2b910a485d21e31ebd871c13d00dba345bc9b834dca4fe061018bde10490c8929b83d353a5e3809f99ab04a3c0034e6a1196dc01a91bc67720f21467585226681d7821c59310ab087e3153b648170ca8c8a5e76a38bb7c050eab73a486927f1f9703d3e701ac7e5cc80376b7264af4176e22ecf708aba5c75ad392774aefeb487dfd48ea0cbe25006d68aa44e771c47236f1f09e1ad92eac514e5ebbc28d8257a65cc1a1f3823007fc0d0b477be17e5cfdf185a4e0e94f963063d8d7b1b051054cbf95c6680296ff7fe909dff75dc2ff97db9f2f0a36fcfa023fe1fe55ebbbaeede7fbcda3d7321409450e480c20df2b0ddcca76358f70b8eacdefd3adb96fadd7560390c2569ac476b04485adb6a56932b963acd83985585b305574d4de523e2a054c0dc47c59b2cd68702d8d91d2c0351627db8003c5243bf0000c3bfcd6d85da698e516bcd9b00b0ddbfb8167eadcaf06b798f4b082ce80037bbcb07bb93a3d2353c9c877071e73a7dd650f1d01c09f5cfa4d820d99f3da70c50f68ec3a0070ada81bdc6bfff626947bc633a8c8fa7ca022db2a77ee6129d3034c8939993d434749ff250308b9537f896de415149e273539f4d068c077209a27bf8bf0564a5a7dd1e59dc30471453a3cb75ef44f3e0d82ea825345db30d30789e4436e033609a797382d749d49daea3d3091ba476c7a62c9ebee2ef305f900a6db2ee13b3e96781e2a22c65d92260cc9aeb9df3fa0a8bbfdcc5e119e2baad4ac20792f4d827806dddec406404887f6ca093962a7d01a7d302c3a7ee302affd29397862484b1a781316412898fba4b60139c1309dd2ae4aaef13f31f3d579d164ec98de86e7d2a0428aaa6758a4571586070c549daa4dda2bf2bf85f4ac58acae8bbfbe78f543ae8e1697f24c4748b539a8861c6b6a60e9666de2e4be8c87f421c9d5a04e1733fdd9419f27a9cf34ecec26e3b60d512dfb7790b0a1ecbe543f8b4e071ec5fe4dfb1898d493cddd5814a2eaff1fbc791e73ac42031a7cfe64a38e38dad187f282203ec6f99c033e4c337ca6f4b5bf73273809c63043b7a142806eff6d8f07e1c40fa04d56d17e3498c887fd0258c58a82f3757fbf60652ff2d2afb067618a25ebdd91932908f0c5b0a54ce479571094decd8b354b1ec5a7849185e7dd0e5504a18913c829001f37cc7da6e5b16540554f67e26ac47cdcb8662e0c5601fc53391a8623b46fe023d0dd9d5f044001825aad090502678d4aa7a20f4d8cb91813bdc6eb33caf04d690ea745e73d1d3bd8b85c4154e84e3c096d9a8c7df958b53cfba9174535a3be7091fc8c6494f49bbcf042f4fc36baa91d86517680085700cb98cdf5ed1b2208fcc895e4a67f8335e13011b5dadbd8b6f3abe00474b27270fd6ffcf53f2ed3434fbca15226e2fe89a8620b00735adc162a101e3fb0fe80856c0f3daaeec2846c986c83b1b9f6f0db411961562e3b05014d01b11d4871c2bd615071a54984e4f0e5ec3cfb276d3d42f0042d37ddcd31b107d4b116e00888f2928c56456ccd3be66323d4d4120ba003f60b20f7f364201d159e8f817f3fa0de82033fc18b70f3cae02c16234c566a460f86bdd4a79e3f22251c07c914d6d225ffd36ec727f0c0b83bc82f6d3013d9b486aef5167c372ce8fe0cfd02bd828312ac20a494900f54b8bd05d7320f6b175ea856211d8fef2472f7ea03157d141af136827760ffc1bf32697717704d2cb27ab774b30af432064688b9c042de5a5b726b3ca303be94ec1bedd06bfee2e071b47f03d95ea36924e601053ad4a1b8e960bbceeb6c12a98b05018d630cb26a68ff69a1718564cb5663f3b647368e903d1cb27baca0bec76a851bb33cd1d0145b1eba08f873ab1dc6aa2653d327255cbd71344ec1b353ae5d4ec518588fe2d0ebf0630fd69f97f50bbbe16a11d0c8f2dcf780078a3b4fbb7180a593a3dbefe0b092751a7a7804c47d0ce3a07321e41881361dda105b86ffffc095a47485b254cf7b8f4085e72495ac4898c60c4c5b08c62e1de7bfc77a1254fe3b0447e10eb02a647c21a48c2568a4eb127da4278f01f81ef2cc179d9c4acfadea14448e466e7f1bfe9c6c07cb6ac16f00a94daf78464517a95c90ad33506bca1106dfb12b5c79c76ee9e8eeae9b387a1b9d6e6d14bd7cefd5956a35994dbe51c5d0aa7f7e2ec13dd4c43152ac659929ac1297435e8ee58c57564cf91905899b805c8b0ba2e41b6535d71eabdc2d102781fefdc2ab16028fcd8a1103b38ab5ff5354dd40549e6f54d685afe085ccd3ac900b8fe31567260a347f90dc37befbfc1f2c15372b3e814b62c32441a87f5432bedff3e49002599ff94e6be6b26ee1128185894b4d25445caa3cc3a79484923edab18ad8984357b12c767e2b6b053fdeef6bc108e6320edddc00ecce80c4977975fdadaf385fb92bc7abcaf08ce9a4561b66f3c94fcaf114f6b1023416ff3d9625cc1d6916df3c014766896f2c7973482d24bc45c06f83688049e0f5d0b7c26f53c823cbeafe3bc61e8edaaf43e6ae8a410fc4c1f155abb9d3fb82a6efe93803601ec3bc7cc210057796f62cf7c1c0aacda00ed2403cdecd8a58192fc93ff98029c1f6b670cbc7db8870f9008957fcd150c2c3138dcd6deff2319e44a4c4ac3c952093693c9dd627ccc02ebf0417fe771d66e572a697e1d5a64f83e63b531b0069b38caee27d535325bf04af237042123ea592745ddfcef36f390b18c2f4332d57b709583a2a44935b3b55397740b0d6ee24284927c0f63f4cfe04cf354f30a7db2fc041df4c64dd6f0085f6be2ca4afdc2ef1b9c699d9342d6cddb6e0544243102072d1c4b0e160f9dbeb5feac7eda952a34c7b9dddee2198f378693caf0e06dfbe87f1e72c0e3bc1091e2dee697a1af880c35fc15d897a3c38b776e25e5991f1831d29b80901bd5cca8ac34482ca7c9c487392fa31524f4f570141b615606d7063904fec6a97be39b2b9fbc0d813dbe6c03fafefe24cadb37bc56580913c80c3dd0622fd1386d6614647421953bb5a8eb706c36e2f711326220363b0811aae8195af137ca4b2759822fa201905e3a993085cf450f2148d15098d5ce54e151e6f453e9414fe04b6fa2fc92deb4da79a6915e111545f166a38e1f643d3e09a1056e3f00a93240e4dd0dc9d974ccbe84ab4acc8bd531198d91f92c7ffd7eec4011ce352a9c0e7df27fad086152a6c821e1be3f4d641218ae6d51f055c3fe0cfc556932055be3c316814dc4a133af4986654b6a057c9b81ab97d14575cecceca212c3e5561fa6005e3942b1fc5aea74e79af215b15e449356403e62f9cd540600437c34f48ead787f83cbc4c8f9bc3eb396216bd1ca83471ab1f3889a8e4dfdee6a96f05687c3ce14a130801260aa1db118197a9e9f9bbec29912df169580e990a9306c00885bb6071e1e5add091c5597f37c81317d5aebde452cd31e732e05e84beeda90dffdd42825ee73d54fee3414d3a5cc659c54788a921d59c67734d7b453183a19bf4fc8d6729aaa7b83c0911270b266efdc560e524ab5dece42e1797fe6503a3118f1860cf022767dbd8165681fb593da3a2be72973e8885f533a012fbb2526a4b03a926ead4f4d85680ab233ad0aba606f2d4fd3310eec3946f45c98d25f72626559c32922d9d8ef3d7f2cba06ad7c0d5f26052672f4d40e55b9fe1e8beb537cc44584b507495abf775c70c943711464cfd89472b544087d47294e2e5fd1514f0fd4099845a39aeb4c8e31c3fa22cf6c51b2675ef7d4ceccf2da48af6b10675ed9bee691d9c8fe7bf908d5a3bc6dd77ad3afbb1a79e75e50e2ee82f9b3d77174ec188e9261753650c357d6090bb7e15ab2a9dc02e65ad6ad7926ea821888b048bbeee12cf6f64df442ee0bbb8ccbbbbc1fc62ec544d6515aef0379a3e93ee8856a3854e57435a69bc01d19e0b6b458d48de0d9509d6c35145718a4bd9ddc4dd3630d53777a10d5411fa421adc7d14e98f5644366025c3b15cfe337f3610d58d9657be0254031de535b146ca1cf8f0144f138a413bac3e4ecc76831b152d2f823c4c079e1f975ff88fdaeb6b68a97e3bfc0189dc63fd2665a5b036bfcb39b99578b3ad4ed2f54e55a5f6e11b8340120aac3a6b54c4465cd35ca456c90412f81f0e95082928c41a8d47f021c0ee458e94f1ad305daf527c3347d81f90121cc852aabdebd57b9743853f575db45ec7c8d2d44d0689e3ae745e15c932d31dc5e83246ea52fe07e033adf5f772a2c7ce168495a1d59bd12053fd71b58e0ad21d05d9c02f5edb9dfd0fc322a70b74cfd877c5cb44f385224f3b42d1039206964a1ece3d6ef05b2e2388f727fad9cdb2e00abd07cdec983443baac770ff002542d0ccd5a188bf17b34655d887dd199f449a9dadc5c06cb3e1045dff312d19a7f006d0c97fc2a4ca8b74f9215158addb397bd65aa91db0a2fa371b526c3b04f0e7d2101955f5b079e3b735c27c99eff17297ab852205073a564d8ab3a28049cec9fdff38e7589195174eb01c4b5c5317374e1d4e6026603c8d3740b9e7437b0ce2a6d5927ea8991cc6faba091291743e5c93a18a1323c3efb907cf938802d07574280be589336eefa817a75abeff2a61d9746d512e901967c7b33121780ff9497e4b301f9f6205199f405ac8b375a3288d4a7aedcd76a793a2c3184cf3a479c489c111994fc7a02e5f8b07e00fbc1f734077fde3d9d69fe67287a288190be3a4eab642b026a457c8ceac7065feb3b021416c511111a75e37b4b0d22fa691a84cf311858a30c80589687ec9dd528c8cef8da89e87fdda62eb58d35d6f997cbd9a517e4969f94149f31720cf93c8afe0c7471aa15fdf2225a4f032c1886a8d9be04d159dfe2ba462024edb297d50c13af323d82c0b50aa87e6beaea439ce7f3f05c60f5800a04516e4dafa848321fb20275b9722b2f89e357325cd07d0527fb62e4e6fb90bb2abdd8c3925d33360de6e83644f52c03ec6e7f1e0bae2cdc02f9373a23219cc25895840d28171d6a743e044258b9e1b51c8ebf793df09adbb37ce4d2e52e3d32c73d9878eb44b373b80461a8c7a564c133274b7d9d3afe2317918e7a446d22a6132bebd22803527c6b59e2126b76ca6966eacfe79784e103df3b070e0545d3792a0ace94037b0da247d442e277d606f45a8fba4e3308ebb5dd2802d8a1ca23fe53a3e124e8830875aa507e79e6a7a3eddb76774bff0a65d6563d5af9b92c9f470f8a0748fa6eb97a962125153b335b100aaeeb87a7f8cce9a6c6679edb0df4ef04f7fb97b8bf540126f8adef95ba4ee8adab9a3dfc183a74271e08cc45f1e21dd2062ec97e97a5bf9e9d927bbfec183fd5b3d20e43c428ed5bd69bad176ad7bf15768cc8d8a26cdfe1e11b4d8484cd760501f1a1e9630720eda6f76e30ccac63f65d0c0bf3d40f8076c6838742751d060532a762e2d826816759ead4ce506b8546daa793bb7ee4b32cedbace23c00ae805f4508fb2cc7709731d24148a4c7cc5588d923f884c8cdcc9f71fa05118b1f9a1876eb65d1fb1f6b982a61c0a0440599d3ec1c2ad8b0d64c759bd7cb85b2603766cf9a48397701f4964ca5674c624deed339a54ca7b6b066aab2c807b19138f5fbc74edfaa1be5ff30316d69fb0994772d69ba62b309735315dea61ada38215e784484c6f94207b0fe5378d5303c7cd5eecc5613e4258a0305dbf3fe721d3ccf26c6431c4046915852f8c11302aa489cc9ef0be2f9e0f02971f2747e9adc7675eca14eba5bc7b43b27247b449e4efd963d3390ccd2c181016f278559b12f76dba254f49f1c631d65da353492469d1a9e980c9103ceb284b3ed7bef2ecfea5a7d0fc26b5c0b9d939902f3e592ef7ce0d924c79eb79eba7d6fc73abb41b3efebf5fa4109ca35b3e6b83b46a7e3880ba1ae3c419b913de61988ebc1bbb0cfb83f18a809922d6414d4b5d8a0474d45a2a3b793861f372e516519b69d2dd2dfcda1d8cd98ccfdcbe8d9f49314513a54b5921ba9ad3432a417b3522ab6f2d76c1082ff1a17deaa5d3b3e6916ee9a7aa3b0789b0b6520f88f78aabae02836cb21601891635282d5c26f948d1a408502b09ecef3992ed30d95ba2b2b63262a26bac5914c2b36fa456fb6543e7523aec5b96a2df93021c7013489c78594d608f9eb8a064740bbd2b090d80da489228c1703ca338b8e59e70c09f15b95717df1a9a797c28d1711543c0647d921677e6976fff0c1a883bfbd29c1ae4152d8cae5b60799bfb50fbf3108188d35a392ca8eeecefe9e269aa7d2dab52c45c326d755f8fb8ef0c29a6689b61c6a6b469d7c454a0c75142055af84926bc1f4bbf97fb52bee74cb8d7a282196f65d1fd7171eede53e8f1218de55e96c0ec2786bd09acf8ec54ba82d358e0db711b6d312f05fc7301be863a0f206a239d44f1eb25a93de335715a735190601e7836fc25d77b118ed354e36a2ec83ca212eec0f24a43ca8a49b188fa2d2659c0457ea4bf9d767889c40e01e381486068e096d1a6a80a102b017f30f3516d353c69542f62465e431f857d4df53f7c164083f26c2c4c82913761d7869dc0e96710eef737b8d6212978ccfad01adfaf5c44616ac6d36d3d84f3aebe58877bdcf279653682ff6239066b415a39b82924037920ce4deecb383399f49a8d24fea391005747ab21881b51277351b83b28a04c6573aebc98e8977822792307a926d9ca2302d52b0f479251e558862d4ed6ea7dcb3d3126d3581f419e2f597e18ba94c2b8988755349809794ebb4d168a3da340a3973e42008525c7efa6e4989bca65756fd3cd77ab28c03da1465fca3ec63576ab93e3e0242f2c67babd759983c8cc53be22ccd1bda9fd3f92fa40d1e3f688227b7bb7347d488025f7629aeb37fa90f56b70b15fcbc859680145a07b62280ac325045bdb3a2fef595e6bbd35ee8221ef4e2f7dd6b79b5141fc02fe68cdc2bf4478d831883fc3989ee25e79147f35e55773d0d9f438a732d73436e6aa06d48abc6a091cd9fb15efa1ee85b8da7cefc56466958a39bd3d878711a4f537fa0667ec618487d1af7d6c951f35d1906a5559e79df661e5d32a44a7f458845ab8aa62625e6a174223045e03696e617886d0f419b6a5738413b017f4f2313df6b3460caf0623e7ed19bb68545a6c6037025060240b9ddd6d750ab4d4c66f4ce75326f9102678bee79e73056e8d4ca3d909b79ab0f59066d92ace4db00486bee68c83dad31c373c1c7bc45250d9612818e6d9a87edc973b5d4d613e489652c57d5337230aead84ea3737f1f8665f2228b6ee6a806d6d1143515820c8b57efaa45e84a2295eacfb0d09e8a7185169150d36037579860a9e015d703ded9f9bc8ff3784c53e813e087a12f7e1a7ad5f53bf18a0038b9318bdffabd8b4db9406efb5a0cbdd8eb799b164a4bb115245bbceef60475abd2db936e94d79efb4a50157ab10155d0e45a5c59164062609a8fb5740f0129e932ae6d298be16495a39f35b6457208cfb79c28e1a8b8351715101af2637e81b09908242f003aad5e390b4e47056ee14d47479df63f7006315542a6ca0d9d64379afaac39be368404cd3e5ff6676250c18800be937f1f1e276056860df27c773b372f9ebfb2cff8feb087c46d7f93d4449946f82b811d45a81dab21a8d8eb9c53a645da05f66a0dc98aad576c48db8db64d5aa91f5b683eaa8e7a1f81e487d29f9f357f5cdeb02e9ab253304b639989f0ca5477b8230b0c8808e763e266e7c8fde6d3c4097e4b4af9873ef720bdc35af74ddac1ebabde789512c4682e94381d452ee2cfc162b39552f23be6d288f24f5ee497ba68dac61f32c935d6b9dba098db4a256d4a4ffc4f4b5c0873b7a1733b4d9fd1e6ce197ec3fd596942cb9f9b735c46f60c6fb118f9b83578b8ddff779035fa2e2345ecbcb5c834fe5455666c90e9d1e9dbb0d2cbbc73b70b5ec90889ca5c3743fb9757b472293fd584aaa130fd0d63dba20b5360cea5108b1cf0fc09bdd58a6145b2ce20e37e97e7b11b5035f8b64c6ea42d9d44dcaec5204ed1182628a04e918f942dbe34987bb818fffb83866450ec6754b7cdb6cdf7f2753bc44028287fa83cc915d9bd470777f548d1692e5f1f9a259463f21ca02c497da8c84174a34382860f250c5da63e0e2b9529117230344c053f3f85b8062ab71b50ef6b231c001cb0b2741c13f1a4189a03c857643392f404bef58ca48c50c470688c7a66cae11f8edadd0d9cc6168d4cdf4b049ac65215ce51acdaa3055c3ce59df61ae2797295d64ff984de60bd7fa890069542a649114a1d91d546477327b2a2ef2a403f3fb438161d2f77c67cd1ff9c0faf5af66c8635f300a2ffe6a30f27c503ef267dea6795c0e5e0055769f12188feb9346c924832df67ea152401830fb1f7b2c58da4e48b7925656cfb5c9b598f1394a10ca969600089b9c936a2150819e1a51ab7acee0f9676ab862348ebb8f910079c94d33399ac50f7199c925b1ae3c3803dff938aa7e5c910c11cf9200b0cd4c053559e80feeeafd09cc212f8392df5da95ef5a8c87a3f69a854602bc35182f90aa953dec618febabb88a8b4bef9d712ae07bddb5241e007273be0824d33cb7b1f8bf955d9594aa394361ab8284d1652dc212ada1f4039b6d20abd059ebb137d1aff934b8f0dcbecef95e47fc6b0d6b42486d1673b65e7ad0207637b072f16988baab6b73219700b5f71fa2670c5e17f207f057756d04842cc09ed48ac66c23e20eb6614e8bed5ce765ff395c2e2791a189eb93787730e3d376f37b1baf9b8f6d2edf24cb7b20077a1920cf7d0f2f4d9dc5f14043dc57a0f767e6cec9c28e69702c4291bb541eadc74d89e39a891bc03f31cec2b953c60e26a0a7bcb8ed82905ca1052f3f601aff44368c38b75d80b8ffcf02371e369f5a1ef8ed3f55a26e763f101020406d507041057f1c7b009970cb612200c32f5f4f90314ad2ec303456af82f2b1a266cd41da4bc55b7f012583a4fb9215e5ee7c58c7a75133fc443d47b7df213ee58e5a3cabd960791bdab2e543da99ff578314582f6380c159df10a677411d90ef48ec3f934b7f2107ce179694318ba583243798a2bcc181e832d6d6b0f7e499f52d7b82e69f281590b22d6af8dced935d0e3c00de44b0fc171a3bf1261f46c374e1f8df23c00bfb837f220fa816f46bafad8d5ee8b15436ce384f13cd0785fa54d08f509224bf743287ab5574890dd20135caa85717012a8fc14a9f66c8e277c6ad9c8f589dc932108c646ca996ac3d3ff332e45a35a76e8e6a05f131ae8f5445f58a4969bf85603eddaed9b03537e4a4f1959727479ba0582a32874b6db1a79fa81dc5393685ef384c9aaf0441635de92a44812ac1b5eebffead57c4e47d7242d2560c22d736680928ff29fbc1fd3173339586ced34954ef950507d9c963dc608739baddd12f25d0c2a6b5843883b3995d5b93ed3be8bc9d21256f5164f677d792bb09a3cd4d2c8b617400feec37259016d397ad134096532287dbed7a65d06c02c7379dcc37edffeb57a60485945529caa12ce25a595aa26f7c1b3bb6dce1d182828673eb40ec4b394a96085273dd36da1f70f1b0c0e93e84862f62570a387291550eb91d34b38f7e7cbdd177efd710fd01cbc5c4fd73eca501872b971cfdab98d17e4102fe5c875474df2960a07136aa70b00d01a10daa25e0a3de56bf0595bafad2770b9be4105e1f7ae048ddbb388b85ecc7961f0c6538f16be53e2fa8357eb093b867aea8c816b549eb8a801087a39a7f196563b68131f97d057123f68ef40a51c44dd7c46caa8e04832e4bcf247c315c9f90f172f0f80a3e2d1d69972cb61f528b9e679b9a88fce7938faedda73164a97507d0cc2de3664e0935a9e9d33d624c9f09f1de1a9af966b10a5af1b00b5af7b955ca075","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
