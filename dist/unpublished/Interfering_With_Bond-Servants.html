<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d94f0fcce16b6c2c50754204525ca144bf017ae90e1b46c469738d8bc3f983b76d3721d19bf3d01a6144faf11f269b2a9f431326aa27db4e6fcf71b406ff6f6df5b0f887283244cd651479884807943dedcecb93b8420df4363cc5b5d059ada992823ea6bc9720e8d4effd3e013e622e2e78796e1fe52e6f2090fadc9a99df2a77536513783c3df6f96cc77262d0863d92af15bfc877b9ebbd9e652a80ae170e96a6872ebbd9d1167a8936965988c32b6b47333cdbc86e84f226b1cbe2e0d5f6ca6dacc8c7b9dee2d7585693affb1ae8b2a754d784a9f376546cf3c21e17a785106eb817ed50a02b43bd10b648c48480f500e5890250d8e26230d18d3a219d0e85d7f337233e94541d5b2a31e6f974e33b896902491b76355b7e4dfb5590585c1bc3f00d5ae6f6d8bb3fe485a1c5c9407e2a2e5b38cac2348deb60dfdbf7be7b7c8abf4ca8adc95a9109d3d5346c26c1d3adfb15f1f519a17dbf8bd6cd9c4a3a2d19f3dd30be0fc0f3c58e773c820cc3180dbf58766c007ada4e420d7d3c4db54e3e9c01ecb6d5f3b9d04e4fc16443140d07bc0ece5000e5154ca8f78fe602641282eeda0b13adcbb2523876ecd35598b95ef9ee246e530ecf7d209ae36798607e40496bd9a87d62a36e68a5d5ab6ae2885ddbb5f91d9e5e2fe1d46f9b920b25ccf1c1e066f110b07ec4fa3bf578c78359f7b792477bdca992d21f17465e5fb876db4c9f4467be2fa55fea8cebf2ff4ec2d116b6a00ee26b81061ca63ce40d65d555fb2c00257e1c5415022cf0d29985ed52e298304eb4ff7260dc0b3133c5ed5ab9e620566241598c5ab1f2c8d9c483cfc13713f57507d937230b0e320df113e5a0bfa27556f2679fd748165e4d96f453f99127ff3d46dcb42caf53b57b67e0ee11df2b56a4f93afe2631b9cd8ef0bd0d06c81c47cb9f15ba1207b68028c3cf5dbc8310834708a9517aadf48dff3422fe20a66f8f561365d7db30633419f59347af780c029941831bafdcf4967a02ccc4ceb20a1126b82736a4f4666157620ec5db576a99daee29d302fb54ddef52c28cdf57167a9dfc91a2d7e2078250408a83bf193bab6fb8f3e70c4e2ad550fb429f81dfa116443347a3f4a610910fe99b01f84b0c2ecb8db62d7784a909831188329a8e99c13385fe4993f824610ed7c1116fcac8e62fa181b7a9b9f0d0dcec0b78583b8d03f3c11950d03cc370d939e2f5edfc59ae703a831b8c227ea1f5fc2b9039e64912d6ed3c7aaf660e6ee9b0367d025c19a3e2e63fe1df34c46c89dc827fa7e090f7965a133d2577a56a3e8160bae42605dae9d9e320a996280f027ef00ea2d660ba6cdf04074d0b497c5e7ef7cc5b2bcbcd6e1f776cfebe03761f1111fe747bd181f4381f46d7566fd41e648d4f89fed9b0fc9570d0418ddfe1471fdad2b7084cd9040b43e36eef961c450d2d5552430b31d5c420b5f67d4dd4942d697446677afd7c079a3e3e7218ea6793018d635dcac2f6f792dae2cd90189107be57ff8a0a26c43f58de53c0b7583fb24958117c3752e368655b3295065374ad72ebbc6ee98064df0862b347a208ef439be86356b0716b5310b3114fff5d429835af7f52d4e9b684fc35f3d0bee7969ab7b5281827d99afb078d250ed61d2f8a9ab3d843a7cbf9b6579e1934835340b83a1279bf99ca33496d0c1a4a4e87022db139e5f43fc7017295b7138b8fcf2ff7ca1fdaaa695657baf1a31993411dfb1da4ef0b313edefc14431a87ff1adf8225ae1547057629de0526e4a61819dfee096418f70134a33915113e7b3cde24d79504f1da23d7546b65c6fc52c861ce48fae6f44aa4603eae608b5694a705588d62dcfcde867fef83dc680c0ffe0d3ba4a062645ad9fc1c26d3c73fa1daaa5edb75b6670350fa2f45b9bbd577fdc19baa81dbc652c44457ce475fd6af396409288ff671a29bf33456b4331c079c7c28b495372cef40ff930ce822a6fa8a472ed9c982640d0c20ee429e1754e9183db47178a638ea703cb79a27ad580686a3089b9339227d2afcb3e57b2c3f84d4651e4751cb81ae4d3ce5c7b135e80be883ee455e35be125121e8a862c38baef9c48b9aac7326e184a8e7c41504594295cb0181a06f4927fb8fc0d0ba0c5285fad7952000cdc8ff40972c8a7bc62f17851626fe17b71fe70b063e10703295ecd9d8d8850b79e436b0eb8b9799ebab415bcd23c1d0aac57be08386865d22d043c86a6147673a11393b9e419c3a264886ee6e08dcdc85392c45a40455526eb9e88b73bae1806a04c3dd5bfdd779e5a32d1b577aef3616d9e4965de90f764e11876ec7da331c72856a6152334c9bac214d23e65ba2553bc8abff79b6324a9cadafc0058094691209000fa4571345a193635e57cbc4f3d80158f296ab2f7ac5a9b09be7e57ed745ee9af2e1377c0b5b1f929d7f9e191a9b66b74ca8fe06f801a1025d094525cfbd52f120025a206b9604971c868bebda4ef0726e4844c79dba7e166bea6314b95d37db56e8f99b0a8abe60be635f7ad011275da0c4720c86d616e6dec8cdd6f1e6072c0a24795c0f884ca51e41667b54f49ea1e92c034f4f3fd742819f5fda512ef95138cdeacc78398944defc8051d24b5d225c44db5a168483f177f77b29fe45a53effbcb82d4818f1e036fc2835c28a5353a9cce8c846e009b94ff1aeafebb461b8304414e23bda6370d0490a1946014df266f9ca65ea2b252f1c022b63bc1acba4e57560790d6e9a5cfc28c64d11804fe85e0476c9e474c43e86c0710edd3ab581a675ae54c71a5050cfe40ad58df7e402dcff7f43bca17c6e489ed772972c7ed6a0c637c62f6ddc43f81ad0209966c1a00aa136eab28450e19f2a857e7606698710e3f7d795e15c85e537f51f339f3a86b0333055f4af27b5170215a1cb241365a0a533e867dda1063b3a07df480059ed3246b8f82f7501598e020874708d0e8a615f862ffdbc4e87cc5c3ed8c45cab1e46ad02f7e6424a401839716560407bd6813738e220782a9a85ab24342665f27ea3827e7913235e2dd8e92a2e58d20ce60ec4917a067edb27a963aef8d6cfa7a80c63368b090d56867e1b447d7a464733ffdae7dd9417c5667469e7023900eeccdcf32dbae31a17045cd7cc0a3ae672858863703db0763b6ee47a42eed14ff729f5ac663018f1fe941121498fab61c79e1bc3a3d7dab96eeb0ca76078d3522fd4263ceeff37ed9525aad389956f823723bc6e0efda424f48bc281fb5acf37b42b7a9c7205294c475f7b2e84be62e9478395543182354c9e7deb0acc41e1b71752ec0634436a8e1f7f90abdaba6dce011764bcd9d34343dd8b7a3056a5e530b388f94452e953dad790b29fb33ac0fab34bcf8ff0966dc9b458234913704b5519c7ceeb7e94b614a380239da15ac825d678b375ec11a9ba8cdc734feb4179ed429d341ae8a7e380f50eb501cc7e9339c18300e57614e473193ed04d7521645e09c580aafd6ae80a5674c6334ffd2d4713867297f1301f9f74cbc473bee4a2037426c2096654912724816bf8c79050944fe9d4e770ac4a91cb2f3cd8237220aee72932d15118759c0f2fbaa8ccbef37ed4b2af0375ce9978e12ba805c2bd4a69321ccbf89f7065f3c8d3576740e39480afc86f9aca0b7b4c8728d88a4dfa7646e11f810f4c26b34fd6ab844bbab7b80b9f71da292b2910fb5fa770b208ab7414167acae0d129cd0557b146bb04352838cde7d89d864e16ef545a85d5619a2c992d203576f73fc18685142f54b6b299cbfb4099c29caffb779992e8ba14621cc5ecf6da36035460533b2692e2b124057bc6efd871bd4396b8fab369dda06df6cec3013f0dee09fc3608394b2ef25c697d8665e2a3a8adeabe8e660c68c4c90dafa27759fdeb49f8f04567be5b28bd0873cbd2b8b64339f83bfe5ef5bb4dc95fd22de7e0eff3e25b01ceb8ceae427adb36e23f381b0a31ac3a38de228bcc94da5df7186c2f31c6c96508f5cbe4009ce93b1efc85ab835c21432ce626c23f11c244379ec790d340f52245840910898d0210296f7fe7918abf752fee3fb325bfaf992cf091cd73ad59734dbf27f2454925b74b3150c6124478f122c71b3f6414127a1c20956565754fa485410fbc38dcda31a55bc361f60d32cc636e24740a62f8a2f0365cf8505d1f9fa2a7ed580eaf2e8f3f09d663c2f7a29e75b50040f7c771a506b39fdb4e8c40d4720357476a55e1c642a764ef8273d8a8cdf76142a52c18dd0f17d488e41c437c2f95a7633ab0f3b9159b349ff9eb4380063eebc5e9af40e2ade6b78e9ece08070601771cfecba0449cc036642b10f55346b4db9fd7031b70c7ef54fb7378350bd0d5ea0d590f905e117c518ab509dac7e2d67752914381cc773d96bd0caf30700980307f09b369ec4f209142b8fc7d371f1d90a787b5363dc6e460ab0564008967c85c761ed96b8067be69fcd382ec371c6f15ed1838886a4170e2b36cd401e3365633bfc8259f539e36dd07c927750487a516b17766d081a7e6b0e515fd7e5746a06151ef09f86048b193425358a0de95e5c4947147d648a1bcd586d22f77ed99ff74c28cb5b22d4a6e3b68719118149137edfd8314d2ebd2aa47a3c6a561726a3cf4da324d532294bf73e0815339416f45f061760613113809f652c2b9b3efe05a63104b0746d6afe6acb19319e50ce779351f30ed8b85d3d15c0b4a87ac894f8b1e1076dd63bbafdfc94bd0acb5d125dafbcc0f676316158bcb62cdacccd92d6a24c440fb0ca33b9c6fa168dd620ef70de69317ff30f575f1d388a016d809912a004ea66f6faa1c4257f513abbb0edc9f080e0c1aaa30c9dc726ebe027705eb05fec66ac794483e9bbdbf9a551f729d790608060c18ebdc3a13c40d0a1a0f5b0658592dbaae173b3b64f775234f862363f5c4c1988346b1e83dc89ab2b946a2bd4bdffce84a3cc39ea3a40c3e0175179e08e12e14589dfeef99ef00a1e0df98e79f43f587531767c5b40350864722e329a8d9981962f0ecff0362048d24472395c4101ead23d324d7edc8030c729672ae2b9f018cbacf4c462389b2930c7b81f6f7ec4801bcb0ff6d97960acfa6f1daa38b48c860f7af2c5db2858b0e7a0744004334de4d437c3cd2936d7eff572dd1f2a90415683b58a76c42d29632a21ae26e7d1bba1cac623e395c320f4ff8df1d5ed0cc9586a2d2a5cf1055e1eb56ecf4879630ad19033ee5f19214d366b0de8cbf848aaea0c970c016af6720c601852d77a94b5a258f740054150de0eb5e9d8743c356a96b410c732c4ab61761cb7733c4c834fb3a91363134695221979ec893daa9be83775ca984cf1e3b5ceb0a1fffff86edc963c66808a9a935af9e8c6aef2888131fdbc4bbb7874d2d9dbe529bcccf7a6a1e6bd8753d6bba224bc783067f91f9f7541e33fa3c6f9fa6609e6dbf03c5d7cc3ba18da5e607f7d457275cc10ce1d4ee8d27c8c1b02f89b869a867f4bdc22c1ec49fd2a86290f156b38b0db99067d2f36c1dfe3a4e33081b9da8787edf97e8bfb1db9c1298df5069f171ba1db0aaa2a4f8dcf2f39a4804a1217f9c265883f9b06f0f92634aa83ec6c97b110b6f36d94d03a30bae4bab2370854acbcab0e8defd1d27a02ca9ffed90fa158a7d237f051bc790f9f1066e54e6a80916e3508d2dbe6d4593bacda68bf694fd4d49417532a406adf18d6cc65fa20a2108db0c404e301d0e49e73fc7a317687a47d94296c20a71860527c70c7664db26f980774d5c05f39e07435c6c0e70a9715136d38c2810d70a4e92120990106c1513a0f529e1900ff771b48e1233caac702c29cffd333021762eb07df8c860c1a9b2a8f7d969845a4999d7360b957d89251bb947d629ffb9161fbb7b9bcf39298d794ec5e048b73975aa94de2d55a30fdf0fb5e450bdaa7652018f7863c9400562e70346fd55dbce8c21a98b2c2ce34a1f45e8fcdea34e23dd93d05d23d3c15e58ee095009c64d95c919e091d6e9c0448c3c98d88e9b8842a8d76dfef426a452e4b40bf5c3d9fda3d7749fb6e6e8e758aa0b7bd6120a90816cf8d13b828239e353be07c363f48066708e5158fc2d4f475906800633b03140a8191ab54ec701f8fda1ae8b38258ec08ebdfa8eea6dfdab814e32a4277823311eeeb9483a68a94cd472811b5a92afbf30994b2a179c3a4ebd61295e38894229b211aa8257b47f809316186fadf03482594b0ed141a70a804af9fc3b13897e26209f2e1539b7d5c49621b432726cd9a668231406687503821b2c6c3d051b853d63c5332fea872de12661ff2c767919a2096646d7a8acd54a8e11ae7fd5e7b73c1bfa0a7ca766b0551dff90f82497d8fb96c979c529e738638287db90ec73e5e9b578ac8922eddbd8f93c48328bb0c7ba1345b77264d1d2a8bbf0bceb86b3b38d0199a1064fa46c6c1631c06f22272cda2ed196c3509d58f93bcb1a5ddb73db4e6d82e383a5d3fcc86d053d573181bfb7378e15a07067df118494f6f36d1abc64782261527be5d94c697cd74b2e8f3b552f5ccc2bc52a1b5ed8ad4e312fb4648b171c8c506c28d75d23dcaec05f922f03d68c29f93d4770223a6e83df2e1c69c1af4e265ae3164ad66f0d1fd2a0e36ca06bdc2bf602fd5c68f629a99928f9753c94fb62c329e793924c53695e1cc9eb6a62be393984d305a0923f7b44b22e7a9a99967b2dc56d3da242c865dcf31c0acd48e98e8998d5f0b6ea27f29fdd9c921e36fe0415462c004622391f7acb2e16b2a3bbf428f69451f7fc30c5b4d320b240fbb23eadd31f90481166793b760416384e0129962db7439b94d48bc5748f3c417fc15c1a49b2193d090c5ab876ead0425b02dac2668b68e39f78da1e0e632d045055506b0940dba3d6e542d17b6a280794f1d1c547bd6757038938645d69615ecdb5cecb42ac069816eb87f33f5a2e296989a85cee795711c1e587a6174c92e2625e5368895da7ceb2d8ff9e37f1d9a966689c5bf34635ba58aded24e3cc436768e6acfabc3fc0f3678272ceacc756f50b9250ebf69fc7d64ce5f90aeaabb57c35a9a1fb77d475aee034f20774276197a68db6ca0ab2300bd32e2c03ca143633888e2bcec56e3ff7ee65c0f9b088a75ac8167904b0ac5f912114c8a6917ee3e544a4aead21f9d3e06d4fb1100db807dbbef45e04ec5c0e253a47c5cd5cea3c97609cb3461efc1b08962072df14dbad03a6790cb9da2096ff2cccfb5c19ae7ea8c760dbc24f15b359a617c8219b1362f17d409255f2729fb9c9102e2c929ebd710d2f0100e6cdb281dfc016b11f9da1dc75b6027dd5f7f843b079e92c0d66e47da5027ca4df00aa303605322d467c7e9cc7602c0bc27728b4bcda117256d4cada4b1ce140acc5d00c2178941fa790cf5346ab192db9430a7de0c096173157131ce2bac82d35a3d88f308006e8354fac6d95e34e251755b9e3bf22af3f6bcd5632cdc2b9a67e64779a10b543cd383e2e2f9746455fcd17f27dcbadb4ddea3774384683081c861c07a99182980e42c54dfb0801d2a68dcb19d46d1f73392289d3e628fe0322d417af26514487ad4425aea23dd95646118e1a98201c68eaa3a54678ed81c35be62dc0680132213f00f5d92e0954265430d3b828efd3631a6f928f5bcfe3a30c78d6910e56122518a0ccf1ca475b794d08f530e269860cdd2887ff30b1d2fc3f2bc3e9eae8c2e9a3a37c0e72c5c48a7b19ae89a588d7964d5d464714c776648737c0c8d3ee2d460d71b4bd2da59ed213fbb2c0f668011d188c2f8194c7e7ef6881ba716d6bef66bceb9bb5c7a0dcdb6c1d1ee3eb5870850a9746bc30f8effb51bccac8bf2eae87e444bd2146cbfe0713053e8aa46ad16cf7740621ec9535c0ea2e0c9fb712ea7404a48bfec9ec09d87a6c7ebc2fc23de4b44278fd8bc0574f7c5037c7607df882138cb5e96c3374f83f263fbd2e3662d6feaf144e95046b2caa3da81d8909d780c968a8ff208c39db77dbd7b28690a8916625d6469f08544f42d849dc2cab85b7c6015ce4657d8a81fd0c3dee0063ff8a53290e01a621eada7f52d47e77f88c7b197ad51c0b7470d2ca3a35b5be9a98d3bd262afdfcf834cab79cb495b00c50e4bbb1e24b7a8b4e259f918a0f16a81cba56c2229834a533adc4045f283e2b6e9b1383b99eec0052f32f2dc6b7ac8a2580e489a29185e6f5418697d265d63964c54a1985cc6d3af5f5943776bcd0ab6bf9dcc5f105edafeef744977e0c26d4f82be9e6f4f8f0ade3ffa35f840959b9cbb358f3426753669bf272f6a2625e0b675530c5936e2b6f907173dfe2cb63a4803e6e983247b875af73549b6ba0299b3dae834b2b3bc5af3bde4c0ef9013cfc99b63db68ad1e1443e4de9ed76ea4aedd83d7f1a190d7f86f32178bc2042105f1f880c80fec7775b646a0eb44187ff8ab7b2ecd2378544e901c4861367502530e41ecb128205817e887ff9a91b9cdac0d1443ab9b937b2d0a9c3e2c005052934cabe545fc6c56f9d664dab6a7214adfbdd1c0cf66cd4a619de7ee5f79263f8997c51cf2f6ac4f59bb2c00090d5a277c3800120872ff1eacbb4932437ba9e958af4a49977010fccc59e5054681f4c186369c70ab419abecb5452dd9fc1246b40c8e9329716b90d5729620341f7d0ef552d0f1290a9f4d6560af4bd34b0e1c436aae5858074aa7e10c948b8b4fd8833bc62025643b7ee40971e57c281ec0ee03db9cec80ea7ea36893127a67d1629c67dd56145236518a430746fb9a33efecfcd48e92d35621e4d663be3fd55022105949440738186cbbe718fb6903b3d7601b4662043262ce6feccc22045ae34accceddc25996973195397acb6699e6396af24b5b69885da70486f4884dac4e947bd348ff6433842aee16c2f74c42ea1ac8faa03f21a674ac659284e7646474cf27280bf027cfb3fc4407d8c14707718025c1831f73f06d33a61d246e84ffbf5176138bb879339343caed48f9c463830c519bd7128b09be83fe8c6242694f19dc77c1ba1d53bd34d9e391b7b5621d67d5f5381b61de5ee0959301f518896a7a8f2c86c49399ca276dd1c7de8e8162a5df1db7759147269732827ca721051a431695cbc5b81bf7b84f80f5151c92dfe4f1427c1f29d4145599c4ef540e66e65446f5c5f9e62d22868b3cceed2dc6ed2b8a92e7d894651b05c5d8fbf1302ddca9154bb2cea329039ec56aa9112e57720276e4cd15ec1314e322f2d02423be1c4b9ef994f0e509b0f8aeb64b96b3ffe4b98f0445f92fbe48ced0316e78c052b423c2b376894083f8abac63096873030169d9098fa51e3f1ba0b1063ecc1f5251982ec00d8e42efb59657c275d0effeed76bea0144b1eb6b65db34e31df058b2f6ec7aca652509f0e194ed072c11c29928cf49bbdb6ac16eaa21f0f0277da82d71969732c3e212a5a2dc73e9e63835a1f530e45a836384ac9e8907bfda19f3640f1e5d1e640b1e5b24259a8f1c5d986ab4120a65319a0a54fff4a66b8d44cd0c39a426316382ae04756f6064ea631b9359d73430975f9a67ff13675d93756212f6f0ef80f7206191f90cad6a971c09ad350cb8b3d648e86dbb35e41cb854889bc7f5d7ad4d52413904f722b4332cce597a55de7d437c360c75e5e0160c76982dae313f347e9d92046801274347f22416cc22437cd729cd07a3a2c3e09a8911a81788c1ac37800bc4f3f156280073f803f7cb20a377a5fccb411118944988e5257b7de99e52c82660df1d9f9f74ffcf7dba6cf4ea10ef73568089923654557c282b7fcfe8a72eac48ec41c308e5fe5908be5f10b92af0b1dbb59358a11c1baf8e727e74f889febd009e19f1af66e5c6c7b881794b2a898f7dcc67113b1c990bde343e73b7963c1ba78920bcbfc3511eb6927fc99ed7a6d7a19f48e499c741dbf4a878fef05097cea81cf73409208202ee157ed885a1226f33cbe64410beb566c2464f7ef648866ae42c62588d295da93935aa010541dfe0ff7453b7445133861cd660d2fa473de1082c23e772f56224cb9c83c85136af44ac3cd8e226d20c6334183d206e193fdd583f4e7130ca72e476f0e65894c4f6b70b8b11fb4a11a3b4643b18bec3695a43d2153a675c906d0332696686936a02c8efe91a254cb9c5e626c441790e15cd3bb7dc08d31d920f05fbba4a45ad3d918bd03971717bc44a216042774e7a11b0707b83c8ea6466b2cffb8a9c873f683379aa5a0e0f0f121908010e3eb7db142106bc219fda122037ce6c71105b8cc4a3d93e9d404da45644e82d79af1c018b059ad224776d609d55a9e6aad7460576a363b43488cc9dab4304835e031d96b9530d684096825cb0bc8720b3d2f9c180afb54f7aa511c57c9b8e3aeb10988e053928eadf39ece13dc90b2d92402015cf48a20f8e782bd839a2a8257dbd17c03a6c41a3afb18ba0073a797f391d9e9276097843f87d419cc2d3868b0fc57f13a1e0ad295696e48160c8cb8ea0928f5425b6cb3311c3bf35c842ffb901b50a6589a441a5092e875d1f73d648091c6c190da139a546e31668a882fa28531e2fc723d3531c1afcba8188251b33b99e0800738613f0b8372441e1916d55feb16fea97cbea5a38de4f0ca1697963bc3a1576a50ba720ff2b800d3cdb9793cef90aaf093e749e3ec804850be78ec831244952c31e7f6d526a6b60de4922fbea6ddb3a448c6c97c26769c4f78b55269881060b0ff4d849e1861d379783070990804f22f1c9032fa8abc1a1f75333a8685784140e30748d748599af2db01c11ea8d2b3a2d146ff38d88e5af3fb5d216042beba72df866c698fe0f97cf7733f4a0406d333856e5876524bfb4086a1566c0f96ddb15be0fdba33de67ca3c1a4940d5b198ddf57d8d4273bf84f9802e095559fe713cea48ecb3ba84665db0af0c709c257895bb41faec04fcbc3579825800ec04178c305f57eb301dae7c6aaaf28268d961cfe17e97062825bad93240de589b1bc323a33a26b486f113e13b508979e25cc6a2c4138c211fc3743ea24b495eafe067d296c7ddb7570653ba953ac7291dee741fcb32fe047733ceef8ea61776028846385881879c0ffb629b62b84906c803284bf62642fac0e247e7621954ba3e8644f3886a19d0a876078c32462098e56b715d9e984b6bc773a92634b2bf1384a87e2426a540bb95fdb67d569cf74789ba06640f07ecc2ba3e288af6fdb8ac7f298ee1344eb049135512bfa93d8246b8b3d692d52adabb337fe48801d7ac2e8071e9ac5a6fb7fac418527375689e3351d22dfb84faaa7defbeb3ba41223bd0b64a247f3ac8f95da894a79671f813cbef4d99de78daaab2c8295577fd41d7f3ce7d7c47c406794787db808c6bcaabcbec699bf0bc42d785dd739a6a222d76b6ab16d802e8a355a366d3f42b83111dd84da6fca67b7603c17cea6dc001a978ee0dd7ccbdb1b830360b6e29d736d1e9bcae2fe28d9122d3ab03e7abbe1d3c6e1af6c5705987f7f0d4f521a3b6ee3d5b0845dcf7f06edb9c257a2242d86f3421369cefb4e082e163e8c8cdeb30457d6fbc2c66a132989f398e7005cc998d5964dbdc81170855f453e5a785af9f04663ccfd0d318177a0e668b65428ee1b44dac4342f211546c5aafb456588d5055bb89e094b26f603f55e263ba1c00eac5fa2a9f4646957b93f99fe6cdd76abf2bbdf73ee7ec2bb07c5025cf908802f5ce5a7dd78d6f1246ceb876479c47e2e912c2e708ab329bf47fa0fdb6fcf8446363d5a8f3e6ca0493cd201e07f4e9c7005580e1df18e78b39c28c3df548cb53251161b071aff18f5a4426e52fe3eec4abf68d5889345fb452a89f0be3666ea66582a272fe9c369c03b0dd3a5adb002580adbd8783c6e787139a97d0152f53c4ac75c0692feb8e87848916fc1e0f1bc729f1029cf2cbe4d14a3557ee57678f10b9ae0c7237df2a6044899cd876ecdcfece21bc0f6f6ab7e89e3cd2f748bb90f4f9aa867d93fcd558c804ba7ea8db5a93ac22724f844462a40b4336edd28afc4eb047c46c073d7f4de89525a3e1dc610ac6acddefe61d3e1c61c8cea7a8ed6a3688121c1e5596aa30cd6490938918e9fbb93edbf7b4d3878421b80e104e67498c1859a7bc03f6dc6f85bb2e1ecc342af3f685c3128a4d6a3e8dc70cb7b826df571f23298bfc7a15566fb633eb98a7c2db22e151993a5bba6fff1c63c0d902979bf9bc2f35a104701a7a62e47b68cf39ca9bdc0144530ab5c828200fbd660fb42cafc1ddf9e0f31ec0ce47e4309dcaca30915a094bdbf3bda48bbc9aaa81f3323e1670d8a84da9135dd53a824c1b3f345be5ce6ec00a03c0299d3ea4ab18dffc7b14ab8880f5460f32f30414a5d81635d366b3a4cdbe1d2fbdf70cadd27b3ecc879e0638f1e5424f316216da4a58a49954b689be5ec019b50d67dfca0c3656b18bbb71f298db477b95932e6874db30ae16a900e46f2e8b99eabb8e19d00397246547b0b3c136f1c6c0f8e7f29476c4674fe3e59f7f2e6e264c71a5e8abc800c5591b25bd82396328a54d3b15c1c2c0939b1e870611e8cf03babc8f60e1bb8fcd1ec2b633698cd32a88c49ed87c14a24703a9dcc9e667abd3d03c9a2b5c3d6fc232794105605ba5c10d50cd1cac58b2927807447ad00fc7cfde7c30a8c69480a1123264502aafed619ee65a5c02c3e4fce6d00d107d420783ea0cffa2fb2705b156d6a286cb687b9d7173a4b0d379ee1c34c1866d8cd4c0b84c50735eb7f963899fd4f0cbd6cc91e3b9abf73f134660340225f9a053d818128a42ebd77361bdcbdb6d069a3b12ae62545b95c724281fa55fbc7ded78d7a5385440792cd2fe29c99a1dd992649d58f4e88bcd042724e79ef20ed0ba8ce431b6013d13398431700c658f6e545e90bcfa34111ae7b793bcef7a439842e1073b762b62b747ebbd3317b4724166de8e32c26be4cd6ebc3e85cfcce435ddc64f8423171aada1097483206d4148d3cc5462092c416fff2098db7d5186bb5cfd361790a819a18b3473cc672de083eb68317009ec4d1a9e9a2a00519e1d814219357e410f7f8c7640afa7ba32638a1ea1a8b364915aff25dd1aebd151b73ec2942356188c4ced245f7daa9f5382511206e631cb613318706bfe703cd392065d7fefbc3d94b3cfaaa8f1d4b89749c9ad708ae5083d2adca2aefa9af4e8b392cdffa0a01829f404d6c896f43bee861cc2f8d97e2aa685274015b8055e82d9a447d3b788a6570e86ef31873b6c22788f3f2eece03aae613e4d7a4abc9449df6b1bede20ec067f809bb413302165642833c0410fe4fcaa9b732478079c5f74d662c4351e495ef09661d8e0fa2ad7b3fa0057ae1248e60b2bbbc4c82b41ea7be361234d5b8248cc73e7e03ff30b3c7a60fa97edca8ed9e7c57e201761be0264245449836460f9d235796377c54ce1d47e746d558c873a111404c4ddc0cb3c61cbe8a6f88cdff62a59e9ec2b3b2afdd5381114c120576f905d5903e1729021de919f466ddce5fe98aee5f34f0f94afde429f48fca8915ee664666d5e18ca50f7707940e1b79ba94e24dca36b7cfc9e94e2f9d3b1139d5b6cf0cdd59252b391fed3d1e25d833d69be78490bd5ab0b4fe1cf0d55431f01c004b2c6682e66c32d0fbe896623f92d00b40431c3d8e55e3b489468f1e5dc2f63c9cf50a0aa879fd301fd7e6afa633278cf73f8c057c734fa92b2ad296be73f798ef283ddb40dc64638d4f81495e187b487e08e9786f25008a599fbceb240cb9fec296d2b9c7a5c1475357d8f2f71d485657a9c17e43c6e8ddb1d979cb780eddfb3eb8b42568325aea91186968f581c2b27958e7839fa786ccace84c5f506307391642217c40f887b781d3dbca8c4ffa3401b8e0006ff9e731c38fd834aeb8fee7d6684be823e2cb786539c76231aed3e1fee0e6bd1607496ecb44d10c5f457243a18788abd9aae10fff2010b787fe7e35b4a2eb7bb6314c415cbf1a107f02b795d653cde3a9b095613df6d99dda1bf09c2a5456471e8ec91bc0c84bec713c14700d2dc8257dcd2500fbfb36b55506dd5858b7462eff5e80af05e62e860886676f11afdc6feb4a9b253ad5f065b4853916ee066306aba02246006e9abd944ab74ab8e6e02bd574e2b2509b87805a2682bb6dc6e78c75e23aeee34c00b241fdca25132bcd4cee487ab70a2e84e9c66bee4975d4555ab71a34e3ebb629d3cf1132043fcdedab79bbab141e8aa2a66372dd7b9d54cc962244cb5cad0b2b8e2ef9b68cfb5471b3d0d9e454ce5d6b6a4998af4adc8cc68d5913747dc7c4869bfaceac4aaccdbe91c61f3946a7b0215cfad6be66fc34cf5f8cc8a571e8a3a125609f0043a765d750cada867e6038ee23604205d3b43014abefaac410fc8c2fcbd721c29ccf12d4bc0e9767f59508448aef05e626c745d8286eeb044aa6e67caf40c78d9e94df885eb2f263895ae3a5ac0489a6d50ebcafbd3acfd68a48263cc39fa57f60a4e1a598e48b2d144229ff0e9cf495fe201122caddd09d28c24512df885ae5a6aa834214bb9452b116e9b4d29c65c496d19beb51a97d0267aa83757736447494a84996ead94e4ca598a69d24e35e174879721230797c4be3757278556bf44d5628218954e6e0d1244054ada7586a4318eb65439e75b5613d16c2f9d3bac3cd2d1d2418b967b8939b40b40e75ffbb5939b2166851d53dc7f904ddc6a77f35a43e6fadff0868f3afd529b89817391c141eb863f9a3687db93f38f07af1a4cbb2b4b70f716d2bb586bc34b9a1e1015a13e1a91e640e960afd4795be2da2b92619cd6b8173b6b67171d766003809db2628f8c0860159edb0e95053fe62c00d5e9b1566439cb8e7f46476d4854b6af3438b6328cfe7a43e488d85eb5f05187304b98b08afee927dbfbfede18ccdd33266b159534fb453996b14f2f3cc16a1b6881595341b72c0a768b85e3da340a57ab06bcfdd3f8fd5c6e5fd2fbf6f8ff330d31f1d823196583625085a6c86b406cad7d55199e13b58d6c8b7483d8e72b39bad9eff0f4022c7f1bb171c97c7f8038fbde0351f959a32ccdd5fc44ba27d13261b16fb36e56840c5871f5fcb26d391591a5eb4012e43b3647e705bd37db7750a46453ce9cfdc7f763b1d4f3f0a53e63a3d6114c46b38273b5556a30815962d148889e89c395e3486c30c9faef5ab75550e319693b87d545c34106745589e4564b51a317f3cb8d431b2a437e1900af31b8f2817c5d5f00996a265a272550d86221db618ba3e468178bd6accdd52c1bdfe4711e30c409f0d651d7db97df05042da9c66a4519582d032eaad642dfdc9fce0a271a4dbfb458e0fcd4eda4aafce64c1b135d00d1b35177bdfb22b4f681567600c480863a1c10ba2ad55d05c3f0e10eb79fb12e211dbc77722234b1bbd26c2fcd0a0fb56b73e9796494aa493c10a5d5a57fd1da5cba614a0684cb396dc360199d57856b073383ca231b603efda3a221aced7a7425c757217ffd00a5b8f887ff214714be2d2bebb087bcdd90071aa232553536e042fdc09c426f4b04eafa920649250b8bde8fce45fe7c3bc105b76b82f12a7225f9e02560ca0ab64937c6382a0198014d9b3a8f63743f6fdede3ba2bce818411d6940da2d2e5a1a80dc286f090f081ae6c98624a54c4a5524fa842f47321ef837f56b06b42f839d86d1e00f6816f37f0c93d77be7be4a01a7aa0af328b3318d210066d7e702234d257604ee42a46c08da6d0857f915886a566deecba64fa7f884d92d09eba16cbec91e14d56725975012ccd61bda08af2bfd11d91fb1b875a269531def9434d5f3eee6a5da2b1b5e60d3b9c2ed0c6da81d4bc4192f1b0be8b958401f022b41a964b8721eed1beed28657a7fd8784c6ff3779990f26617ef5e301f5b79ed4f9df4c622b7865afc0792a07560dc505d619b110d92b81941689bf9a790328c161df91682394185c4447d39b2b245fd4e035b90754dbdcadc26b7ea2d0f383115db933798d614394a78433c90bf39a8b37d2f3a7abcabcfbdfe6ef719a93b2a5d827c5306fd22109cb4c0bf91c65b8f7bf03244a11bb8e2a09772820f4794dc67d9d71ee28b90b2147c68042372b2e45ceb5911c9cf19dbfa8a2aa8749f48566e86c72048862ce54feeb900120e865ea2ace88ac2d7b6c997a29dcf7666ed41cac4b1207fa511b60be112590e319dca339007813964a3052b6702b1c723e0709fdf0d8b3781ada52bee3f81e12df1c7e90c8b072ce5514b28da1ee205df0cdd944b1a0bfa8ca03f13cfe1849a8a79b9d0aa8008c6fe086f6c89330ef4d9cc4a39feb0b598e6aa121947a0accd682e125aa41a4711dc192727fd7977674cb8cb496f82859e89b4b84c0d873c78d933a7ca54c23c512fe3e2a16eff54ece3944e3dd50cb8b9c280c83d0d92b4505de5c34ec7bd0669c58a85cd8c136ae232df878b4916cdf921a934ee05e07fcaf7b9512a2cf17e71b63a4581b884a20e4f1a553490fa41ac1f4947444ffab142e608dcdec109d41571dbbda420c478f4f4e360297bd180b364dfac7d1b0e6d045ce96a9901dd19fcc8bebb396141336ffcc0ef835d27ab76e051605355d2c484622c337a978006fc948458e6a9732ba42e5a35e51874aefcf8211a69ecc2d7eafb26f4894ede3594b73f77c84e493d0dba0f1706bb151f8a9b5b1b93d51202fdbc92e3b2185357c3c430ad92d797305a97623730ffa9a5c3a3357884751f2077bc49d8aad1d6d9f983cac4084b8557c37ef94a735ac0bb4089c77ffa38885c009dc42736874866c64de75da28aa58c8c28c3f7cdffbf78458fc22a4435492511fc212cd9380eaca7a9154a02b963685a115e1b0aea4f4b2623464f950a34e22c4f749fe550e46fd32d6c7854c19279d26b90ac7d60de4463ba2e5884d2026b051624126667978a610cd796d1036d517a6284d2ab4331655cc31bdbc1d30545253ebfa776fb7aa80be80fd7677aa8a4868f61151bab43f5e0e453c56b96cc3a062a9cea7d6e7a1d1f0154e7b5e5db53e7c24e613b59d8d5416590c3881cc26e1e161eeaf21157e721802707808ea26f398c0abdba5b24a8af6f0a68a962b2fd9e47a36b63dac6e714054aa48c603ca19735b8ca5fbf25a412a329307954f9fb84c8dccc083408f2851831e46e782279e24c2a69d335662dfbf33251fea686c8b5b3d888a2a026305fafcaca9af93d7e8e55f20bda2ad68795169a73346bc3df10d4981b22ecfa57df375228817e79d1a6b1b5733af2e45c45679149ae13e4a2c324787f44aed24225d856e8797ceb888a74e65192f5a79044211c0330c1ea5c5d481f0c058a3f9859ae98206e777b12dccd6019a779b4995c04127b3c4db9d8224748435ad69661abcfab1c3df49922a86ecb6d9237bfe54c26c6772e6f680d00010705500b37f77c573f68d0571692f68171e86c2cdd3684b790edd4c01ae4160ccb5603eecbac05f0e2c9c48814fc43fc5eddc54f51e386ffb3f594c5af418b4316e15340e5deb75b9a3ca5df96f49c577b3f88b8929ec4b906947342a3c763879550bf1fa24e51867f1df3916f146f7ec863ca2c83af3fbed8cb46707cac612d75183e8f3b70851fb30e6180d9ed3c3ed3929802ea551445cc2c0a218f9fd26a4ece1ef0f241dd498f9bc70b4c45af01642b84e2e09d63d4b33aa358cc527e504986c3df35c16acf39acb856c3d9269a97ce92eb4b5f2f35bf00e4c838f0dc4969da98ca6ebc6f3837ef959e4ad3692ebfdb945073d02f2d77cd2a638193db08a2d87074d25cd371ddc20b0c1259fc883fe468918981793cb650c278b8d01f8f10ed55c7dbbda6c81d00306d7c1d81069c6def1c715ad363426dbf61da5d55860b82f26d136cf45ba3b65346702a5d697d802102cd5de1004c12cd14dba0130875ad646746a2646d4864b3586d29a2e50c2020d60a0507ae7fbfe86c3c6af27dfa3cc632c32ecdad37c5bc82856e88d9e12a493f2dec2ac5bdf501c0603c4265fca2340ae8ec1f55b2cee4653bef7f544f30df07cab876628c487e00c1920f62dd59e4940c8ab60130d8738c0883532b8260d330be41d5ce2307f3b2749a650c0b60127c5d23ae75ee30b07b108ce15c0b083e2e3cf46533f292c7c01804b9a8dd864039d1724c9ecdf1baed2b4347415d70ee36b045d9907c81e2761c36671c166f523550aa897edf9672bc32a8284762311d852e687dade472477885641c692bba42b78d6fcdc856f0e2a82efb13c251cdda1b8c86b3feff8fbf737643ca9a2409ca290b89822cfd6b3b0f30735dea3a7bc90b3663b2f24a5db4c049bb265f12e482fc1d5abae8eb31a17c1ebcab5a3c87c45b76f4a93d1ed0cf3e906354bd6f26ba2b4ffbea3c6023832749054ea6cbcde7c71c92cf9ed827744487d574cb2a1e98952a14967428e7aaf041a712147d796b8c8e775ff7d6215c90a09a9d9f6aa171421fe2944e462a6a44c6be28e8c6c6ce6e0665817790747e1455feb36f3742c4fb35f29bd06d806f55fb65d0ffb0cabf7dbbddee53d0d7dd2390871cb9d9b5dab242c1d324a5e6c1f0c1f2832dae7c7694d4bd5727088b4d4603eb936f45b05bd0e56caec5b2a339e2512bd8bec592278b0cd79797274afa6ed79b406bdcf6864cceca89c76579bdef95214e90f6c5474e9623957159a06bf177f8bbbc048619e9507a91d4482cc28aaa73f14045b987c2d09b662bf2f54c2ced7cd0d01368e348a4befe79b5a23d426d1c4e9f28d3807b066d339162d153b2353aa842a0d7be6a22931af617044bfd7f73df1c9196b4deadf2626cef1fd0c3c8dbc952fd1343046d27b47c40d0c97d95f26d1820386ad1fef3e7975fd2081e919e11af46f2f2edb7856614b5a86ed3cb07896949f8cc4e34b500e3ece5fa7cd34bfe38251d55c345f2eab7a5b612c0f954ce9b93b4a4b2998c3a3b977674406e432c750db330e50ec8e60dbefa3460c833ee296fd9dd8c217fe26b627c91229b3396df3ea07a2982c9dbd08aaa555184d72302ceb45d7ae1320272abdfe956e989e71ccb27d866d3324b34a365eb5c401c7afe96dd00fd8562ba64ec1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
