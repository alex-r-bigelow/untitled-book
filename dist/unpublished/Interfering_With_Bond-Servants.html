<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1dea36e1499e9a26813644d32341e3818715ce943b618c586a70c55b9d914048a39b7fad75b3ba9a4bab6eb6345bf99b110dc2c5ac2f46bacfb370abe16375200b32eab05f3b4d943272dc86e79d40e70350d8cecf9a7dd5de23673f5c7a3d2d4dd7906c3d7b9de6b683d3f798ebc904fbbcb2ee327badcc6f7b7a201c54f9eb45c01cd7111ea1ce470c3d6ed41a69f59039b67a405f2375b6b73272c8b98678a69c4ab618e7e51a806082a4e553c48de4e450fa32c78b29c3010262264d8459f1cd3759f25b893b14d0314b60c5a1dd98c8d943532ae17077390cb15f62f9d7ef7a1468de9231868f31c7b61fa5a8a281333b96036fd0d17e393d91dca1bf75a51bb613e112e5c51e231585cc13a259457621837222d72b04db0e98bda479dbf86366101aee1ef16a61da2246de28a04ea8866141a35ccef82bec9fba84cde66bc392f435c0693a0f2c2554481ea6f9ba22647184c86db813318b1563ef5af8bd09b0c1fa84acd452de215138af6b6e5298d269345822ce8d5b0a22418b2adeb50569f212913a83a0cb6ede18b2379a67de9c18eb2886247dcf7f1ca26ba718a67081215ce66d77784f83dadb11cc0d49cc88bfda8217d6bd4fa94d8d1fab5f46a7d54480e14f9f9b871d61a2e4ee38cba40905478735aaa7520377860b5ff3d7745e2a90b421d7138ed189f4e31c3af13ade9d94a339e92fdfeecab7e38b6e8672461595830951f3d6eedb5889e3cd7ca20f717205b06d98ac4908e9ed7b42aa3aa7b7850b93e46bf32849ae417f083cfd766a868f144aec4c2fc691f2fcb272d1980b1202991c7c469151d63b4f5f2f6526e87b40eaf08665fe336564bf561096cfe46dd23b5b27b0411c1398ef56e54dcd6bb1b1fcd688d908189f3ea0bfa9dc94df2322e2e2df46ed9de72dd64437f599acfa0174a005c33b3bf3392d8977164d6faf40ba0198fc649207d8905e72697a2085150cd7e9be2a3519efe22156f920377270f140be0ad92596f6ed360a00a8a1e6e1abc6695daffcd0af0679f97ab121378949db1cefc990a8638e464b8890bacdb10b4c36edfeb77749311cf29d81839b36e51f905d93569b8267be7c13ccb40a75fbcfb6379e412e3b43b7d11372a5016ef5110b3504d9fab14d58dda6f53ef39efd831fc7cc0fcc30ba350e04c5c67f68f78ffb9a93f0b54ec8baf30655a053a35b11394e41849b270448d0b48519d71691ec3e1acb2096660843b04df4293a95d06d1e8ada8936241dc54a76be9bbe09098c5a33ab5ff28441a7ce1339452055aa3dba81b1f41c15acc78e5efb0681a877ca1b4fd60b6eccabda86009d32ca914e95bf9c2006c5f2354497e8ec994dde753e373f3e0260d6602c91a84f8fbf85f186fc1ebc87a7c93f51b5e7b2ca3e833df0027590a3a2ba93a0af242e39adfa326ebfe94a05eb0eef0a7f8fd9afe834cbec99adea6c2616ba06cdd1aa82d6eec85ea8ac6c06a58c2e1de66f2a23bd9a577262e787344fffc51c962f761125179a9c42adb4434e881ac5254adb51fd0e90be780c89f601dec935ce2c1a07b0aac2eff7781cf17663243ab36d789c3586b82c3de6fafeb9efadf919edd1499ff5ea4689d3fd0abf630d92e3435cdd2298a12775b23e258aacd8f832f213555d450004665fc3a8429c2168cf853437c61ddb361478080b5e1e6d52365e4bb7178f66a7cad9451e6c7824e52246022c4e753e5d45cccdec4464498b1618bc1bbdea03b7380190f3e7886028c0aa3b020956c12d4e8b7ea210b7894518839e5715474162d7d5ccb29d2070833835b4c5078ee1ce99a26aceaa0f93df137fba39b544509d2c83720f435f3810b5ef8212a0cab079806d5c2d5c6fecc40c20ad2bcff4702796678f0f1447c3a052cd41ad214a0b7ccffd93eacccfe4d17bfb87fadd45a7db7b7036038aba4fa1947024aa57bd2c87e149b9a7e99000241a32c9509fe6f24d788f89db479ea2c8b6f8b77f268dd9344af13a97c7f4a26877f2905d8ab25471abb06a7a0cee872a1635749d0e1fb97388fc3fcd10906169377744c7c7994bba631effa5a75e8cc470265658e08cae7ed5275d2f02f40fb27313cdb2653281053320ff7744059d22d75b8bce64fb383e9a8e1e74d647fa9e4635c772d91c4b2e060ea52701754420572a03f2706958a40440ee3e335800f04ab399dd8c9d40e42bebf72465f406938622a1d0737d08e330e6d59a6f5c2cd1ea2687c30fe778935a948f9af8d846cf87c9f0b5bd89d52bebe0fca172fcd7aea5100ef9f3d4e4fbdabe7360c6b894ab331d21dd4bedbe1fc082f0988a4d9851469490edc6485f9b3cc9704883a7b03eee59aa37b83c143e3b2d49a115a7dfe4cf6d78c05728800a62bdfddd2376da859b742ca15226e62dea43a72f0a783e0c8cbf886cb0b42039937b926837584d4727b9084aa2301954e8dca8ca8f824ffa2a2c4800cfcf16db560416a6ad346731adef813975269a390560ee4d1221a97a5e03372ab2b617f69f8492b5d3fa42f8353a6ff85ccd1c3459e7dc3af5741368820b69336242ab1143c8e9c0f35b97fa57a69f30816f159a2a872c6534960caefee38180c3dad61f674cf320c61aae09574b659dccbf3cc4fe2c1567f933a43f58f6bf19635f04fc7e0992e0ebb638910fbd5fc8f9d054a4bd955f5c353432fcbf1aafd7b2601aa3108eca5b684dad3c5baedaa3a3b8e29886b60a057618d507bbdf7cd0ae30ee340203995b6f2cdd5e95c3ef1126cda5b7ea4cbc13b68e178610026ff52c2bcc83ab64276325a066b819c65f8bf877e82b3bb508a1ed9be70ca70db83a18441fd87b30f18fc5d0732dda497a91430c4a32d18ad823b5f76f05a637159320d6ad04c1283ef4f284de5d76be3a283ac1c231f8d61ffb28779d495ab82137c09e852e50dfb93aa8d4d4e67543d3412d12d00a8cfbc704514edd2aee9686bfba1c8529fc9ca7f3f487f8c81f1c0b10572896734500b9246d4ae5c9754c0a5b372914c9e07eeec3ff970d1dc941bd2f5275d69983d790742d577c5ed7a5f61dead38b37ee296628d0916e04586dc27fa754bf23fa7bda7ada78ae862c5f69c9cf50f3702cb16c54554da6b8d264ae4db6188a018ffc04439509bc095b198c76f12bf978bee2c61dbc7e80983f4c8bda68f9b97ddfede4627e94155db47635c6070806931a14661e3077d2b5d1182afe437c46f9d656e818f5bfaef9bbdf95a02d2030da3937335438e5162fdac119dde5e07aa0a63880c3547ef9412b00a68fd66016fb1fcbd1f6e2627865f6d4b203ea0c004e890414bb397bd2ed0b45c5ffbbef9d56e200227dade01829292fb7381b55f51504efe9d5e72d4c4792d1ef4e312ceabd566eada5d73b4aa2faa563971cbc0a1ef713af8ca2fae9bd5f396e33ad58accde3adbb0ca5d7e5bb6feac31cfea2a4f85165f33f956c4fdb72525249ff4d718c51543e119783b0d31f3f6687683f7a3717286eafa0c8f806aa5beed60c3bfdcbc8e4f5952861f97674627a9b073b0c21fca4d137f3c14a8f80a20da045ef11117c142dd73ae694a51295178051e4bbce8adb3f2cc085819db8f942fc184b42193e222196cbe1e2d47b680307d11196e8d65c74d2e55c2f829dcba8ed76125508ba6eace10da41630f9441c726f3e534a2aceaccaff1b5647b2637366ceafdf9d660750891b8c8ec9c545058f945d8d0461f4a1ca578f093a5b866dab0bff13c394823c49755099e7f063b46b19db1f905f9aca7114d3ed1fc42c39aa7cd66dd2795b90e9d0684456fc195e619a296facb962aec7786855aa44454fddffbc0b2575de46d44ddaf877e5a5a228f26e2cba6d2b5f6154932edbced57e661eacf8e4f4bc8fd2b4fa673ee0c1b7baf198ba690372f0f1e2aa9647a9f97c1ddf2469069f06672dc21a278c8602e11dbba7441d9f6ecfa8c52e50517a5fec91a3940f21bb56d37b148bd727f632bd6ad1cd6408f399ccbb17990160b2cb1c124c20d5d38fed26352969a211ae4f29aaf2107c15caa72c1c5328a45467f9675ba6d05821bd39b79294a7bb2f74a510efb979914784dc4f726f68c82898c4353944d0b1fc41f7d8b13aac3890d5d4b0379fe12b200bde46cdc1a7ea23f7d1f6e9176848a7b39a4cd7b370bba67e67cce22a6863eb1b418ab1eacad02170f851f5f9ac373d7ea47cb9156e8a164ecd63db46d66a69d1325c26be247f1f935f837747f897eada7b136dc2905ebd852722dff2e170e4c823731b4f9f132bf32fe855a75d3420374a2e21e8521af7e3755d717922ca2ee43f9d50f843d59072477809c8340911f5f36d1d4ce016143cc76c1f50b95f1dc1a967de2460395ff775f079015d3e2b19996601303a25070c6c8ad98685c1a98a9e9b6bf4c72ec17f6c3c7b700a923c2a87f8d23cb05507eabfcd1980bdd890aa3b5ec01792522cfab41ecf22b02949369b003fb90d8b0b6daf76705e9dfc11fde882ca86ad72da4cc2d095004301ccc400e2f3691014e45f8335d9d75c788267e8c278a3ad59e74e8c43c751c5793f446716a2563e026ba2fc92779e29dd2f041063067935bb367021444b851cb830066c2406fc12c066084c11a986f5352e1492e82d5725dc6967aa4a786acba70ea4a26d724cec9372021e9e5eb186e016caae3c51ae58c4ddb49dd0214407fa4bc8c9f1b9422fcc1bd248415506895e2510a95fa2b39244d52452e671c24875957de1e74fcc245b0b2fcfabc23c8228e1341db13cee9073ba93188a60ce4600809b90ba06a75976725cd123e0518d1f15e83f01cd4d6f86025f5da0b5b06eb2082194aa03f8828f0ef7a9f7eb7ae1c7abbf6edeeb5d0a44e151bf6904303fcdcfd3bb5e818918402093e95b70ca6d17ae2eefd5e40249a96ecf5ea0ff70c16739ad13c25961fb4ca3f4553e889535ffdee5dc1319614da202790447161ea4f62b30aa3d4e1a16aabcbd05f0c95a7c94a29f4d4b4218bf902f1224bf7a971c418a851643ab1da65d44a4aa0307fd8ef1636db472667529d18f4c756c9bfff68c230331f4bc869e96dca5bde1b6a9c27d966a92669305b804245fad0418b0da56696c591282b20ce5394fcf4f1f993a6bb25f07b323ce1ede559d92eaf8769afd84f970e882cf22187edbf7bcdf6b229c586268c0d85089a90482c21de01ea99d3552746288007e91f1a843fd69e8b28fe00c71b961e1330524016c465b21dc724004e30b65cbbce6043401216cf81742e601f2f2f26db11b3100e1aeef47a1a3097b84621e9f8011ecb4fbd14bf4b047e264497409f4ec699bb2304bc6dd96a9e4589f6084e2861d77800de58a5cf6554d67b8077e60645592aab9bf89d9ee79989924bd4f382656c0a59a6f7ae9cc68efbb91a499afdea864b7e34cd43386a9bb01aa5b5490735ee9841cd412f39dd8c85d48b1e7bc55b8d4772cdf7d1a528883abeff4837d1ab10d8bd28bef574d29825a88a4bb791a65044e298c5b41cab7607c0655720841f0a6f3618a633eeca00e5cbd22400cb72da431c6daf3a9da69c8095406764be2500bf22aadc14cdfe368f651a42712cb757960f2788d58c515113a1fb32f8fd822075f34260d49635afff9af7e78461fea2877412b036fc8565fe48bd76236adc435cb728e23aeabac1ec5b0aa2132859a984ab2a89d1a74bcb47aeb9901583211348ea70b3435380f0af927d388a27c0a1fb18097479567c99c74e0834d2c2d55fb9ab70be91c029f1acbef395d4f8b7f1e9fc5f5d4ea79387fdc3171d888752c827189d07fd76168cd2992d73174d77dba6c0a2b860a219310a337b1bf98ec6f1ad5ba9313fb76c607d5e1b24c78c8754d880c48640e33472240e09e2f4b7064a7776881e3cbf79592fa4619d5b9bd9899b06a4a80f64033dbbb8d1dd99aadae3b0461012517517b032a049ee7ef73378a4c6b3093e42e64259f6e19aa5d29f5d2d82170c764daf1da9b65d7a91e51b9cf57ef697e07017408b274acc787d3d81ace7fc9d3148156dbe385d75ffe8321d8feebf1312309c4c144bf94741b7c7be00167cfac1fa5e8339f57a04d3f465b75084022ec3825c4f723729dc5c0d5c66e8399c4b0a575c63bf7f24480629b8ca6b34a117f08a93f93b92673383a7fd5b437bbfc36fdae761977d5b4c19fde52275814a5f355b59c02a8e5b73f38e1c59900f1da7333024f36896579e6aa5a6d4c994f7198a55470850d49d132d8ae8e33697c2f4ab285b868d772e9ac03088d54315c4ca94c0137bb7ce8d528fefd25f617bb82974917ad4c1d285e56ec5eb95c4ededf0049dd717439dda626792c4480e79507a1ebb666900a06edb041ac888717b3b1addba5e6762f222f7635d660be53fe546b7839cb0323fcbade1d8bbf06e8cf241524c0f7f44beea67e132bcdda59842945f87397054382d916ece402eca05aea9c2c051f28dc3de2f98fb94126749d9d9216b5afde7f76360cac2e7233f5b9bd9df274caaf1a46e43877626df599d016e74e133ebd5f0460aa158b4fea54bab17dea427e6834b6a7e30cedabe07b77484e53ee6dd6707f42c4d18716fdff7316f371ec07c40652e26e66985f9a6e312f1f920ef1f5338faee5dc6e654b5623ccbe086d19c7dd9f9da161b1b2524eebcce2385f90d116703841d7559ad3bfc4bf3651bc131d90c5df62a5b977c0775ee6614450b7c5d4168e283e8a4c12236387215dcabf538d8b01926000905dcc6bc1c019eca20b1900e7f9a7773ab3be9dc9a4ea9eb7ecaf4e76576fffb6a51ab0095c4fde34e89b35779c6c0f669a88eee1f778d9c4c33dc731b53c26966ff269ff4ce32017b5c8d611635ce8dd6510d093228b6b47cddf0e48f489d7ebd88be845721989b95fabf34f8d4cdffd44afc367858f44d827cf5c26430802b832bc4219323933c11bcc6eb1dae3d88058e47de3b81d386e78e07d57804a3a42267f9dfcc63d6fb7c2049262d2bd6bc0cf70eef9350b1632daaeaf599f7dc5cdb71fe92e68bedcd2a194ae622c921a914e91d8ac32969bcb7c10f5fb9c7c845894f072284ded17a2b7ade2e88cd6023f698682dd2f43b06f55c697bcc784e1b621e4f01c961f094b98639f246c2ce74d111dffb1bcbb061b971e47d2271ae6cdc28efa35172cbbc23bb7e36c2cc2ac9a9f7b217092cc91bfcc9ec53dd5c0cf11d06b92cb8643880bfd5bd4b7ae39723451d0b525c2f41975cc120ef737f687eb897ef7581511ca4dd6e5bdb97e255c2ba5ab3ac9fefbe2df8b7590930cc0d854ee239dfe62626b084dcaafc8d98d947adeb087248e4f6e5b9044907f579514e7bd64fb6d04bebd175080520555da79f2aea45d967e0dd9ef06c384b5ea2a27ab1c3ee72a90bf5ad257b460a38ad9a9384cf92d631f9fa09251952c612d5cc99fc5cbe58815c9a8335317736b3f4436abb4b41e260578d5a58da6a16e733d6946acc12888a136a0d69b7455efbd24e7bdef765bddc3e4fdbb09c82f6041e0043911a8fd13c361ec9467c87fc43496855e36e05ae8240f99ce2ee59d9862b46c9b1fd8f609238efe791cf9a09a043200a376a18f7e67f49b5760f6729e27fd8da6295db46298c3ea6a1b9adfd95387c39b8c2b8053153cc41f657d1934beec02a919d41b0efdf5429f78b1f2c9c1f38366184cf16ac3f6856e2db7138293d4dad956de2505655861d1bf05e3227a47bdb5957bdf01405751e1f790f8e9a454f8f1ab24614a3915949f28d2a8b4aafbb0ff12b188706502abcdbaf38ea55209becdc4452c762787fd5c291f68ca827f369a55ef282c081baa47c54986b590f39b07296fe9662422ed78660e22df39bc183f5c1899a2e913354cc16e2b6c72ddddc95d1f08a1b69a0e09fbaacbf837c7eeaff941bc966752560032f9fb17c9ab787ed2d64e6d8a4eaafb4f075eec2d8589dd9e7525865b81d68e571059029f9649eb14b16b48b956fcfc6604cd151ec1f1b438a61d8f150483a2233716977393d8056f72fa1640ba2b292769d84829bcb413011ce4ebfc3a7ef8b5349a0449b10be01313c4d8e3bb1da4a2040c6640d7e1c9624581649d8cedb27c787ba76443c1dd83afa50314493b70ce4825e95518799509b301561420e5e9efc404bc5be55909cd559227986e7f00409564ebe0c7f4ab287cec3de9d2e25200e018f2d3533b207ff93cf1413316a4aabb4a6a0988fa1756b48170d30c5fb34894eeb62269380eb1d6714f5a4534f061d7bf342ddc5f1c5b88be2a427c1d4ef74b130c73e6be46414072ec4c5e021c435b9156c1ddcd1306b651c08d3a1a156a613c16bc2f2d2e19f4f4e3d4a970edc2f293431ff77470b3c3a1f2d922059371137e4f67073173f321f95362c86bd2e838b2fb81c9f60114f0a51ce93239bac197b508f128fa866bccfd1d707724be32dc4663630d09679ae234eba0ae8d4eea8b4ffdd3a274c7b4940af97187834263f2cecaa99d41e2ed33630629ae5844aedabe9e319c4174fb64aa2dbb89c8595bc9234d213dc4cf18a62caf694e3833a7c4f67726dc8ddeb9e030fd00eb94be29e7ef3396985ded0e0afa70678d0f1bec38942e7c78db42c186b7561cad50f8d72bc361b62e4b118a466beab3316f013fe94631627f2c4b9a839a341ecebece410fbbf98257ee5de41b2d718ea42a95aef4e00068f67bd7abb1c64464adf636560a1c56f35841fdb2c55f00bfbb542df92e1f6595df735c097a985edced8b7b00dc78c982bc5185474cd4dc762df4d08522f865722a363c1840c7be68518d7fba4835c0982eb1a07b8f3a1b31ab9894749c583b11bfa12cbf5c36502c1ac32fd674c519676f79aad243e5714341d2ebb718ac8b54a90a449d550973dd7dd427a9547eb612122b3969fbc448dfc91315ff4bebb02eaf94e54f97b20873a2d1951f10b38b29099a9721cda9e3e9445bf3cca0ef5aaca1e8edaba00b005b8ab4515a5c222dcd93565eaf3028fa74febc44c55655c308153b5d30ebfdac5a2cd76f5e07a69b7f89c5db27c2a787eae10bbe8d830517e2ac6318a62235a6607d683f74e0a72b11818f82fa637e77186302bb681c50a669f602dea8f0dbcbcc3aa85b1bcdd613381f38d879c957d2723aa5ea26f94be1c6f6d911aa7df331bf7905e5d6e5a4e6336d0b12f838146901e05a9f27c713c6a2be7e1de0d67497d08c09b79f35d2446d3c6430623c42e67372152c005ceb72d3e3b43cd085f360eba87419be4a2da55813759350fea488240410a7a965650dda2c38d6f0d2ca8a50a84d9f771659570ba1e9fe514aa30a0f90b447bc1f80ef20ea83aaee05c9de8d8b4a9d3b881bd51e1741622697c7de6a3b673f30ad3f06815ac649b51d457e1bc29ec75c9f3b52af4f8877a8a0539e831096fcfc3b80cc5ae398eeb962fd070133f4f8a866224d7a2b33de9260f5a97412e6003f4da0f5021943c38c7462148eb355c969e09910233e69cc9f90e889d30d9eaf6b217005746f9c67ea2172a04da45166d195c35498e052bc92e42db523bbc05848b4192546a0205ab33a002175747333ea413ec261c0d9d21c436cef164546f6a33e45a6409db5096992644927baced5bc8a368d8bd02106421128d9fdfd0d0dcaa5c2fac95ff06367e3efa27de40a6fedb161b43386dd199ec3bfecfca3525433c0a9415974dab5f312836c82f30ff8a8bbab1de7071e76479c3e38b6a5d26cd6a6f1abf978527bed9fca9f0169bf483f9109384c3c5bbc0a58ca396e96aef87d2ae6e725467b3f9fbf60415784f57f9e4893447a5818f35b6d159cac4aaf49e64909abdfb5cafdb5fb0a834e02dc10cede9787e1bffe0499dd5816001a904cadd097ba8e29e4469ad4911e9cb70d615979478751e703b3b0b67547ac3204c84bca55b03b45dd33ebba7adaa1b34ad4eea6d6dfb13d776429009921098276ba75afe49318bffa629893c33343d0d7906324eadc21d2517725dcf0858f23dfb3f485d8cbab143fd80f26cd94360d50bca24b1730552bff7adc4efc88d0294a6224def4c2c6e2ab5f5389fea53a07b9d7506f44c349359bf2e21bfaf43d4badb03a9893d89159a48394ec69bd19f4b2094d255b5718c7e4fd1877c5f7da67d4a30aa1e6ab4442f2e69a475367ef7d3af00cbb23bc9f602371e8a323704745f614491b608ddd1e90bd76993e43396c7089a77cd5edd070f85d29636587b0d3098845962ab83e539e864595402c61d05d4ebf236b11e544aee550da10af2661d09defe8cff438cacb8ee4f5504780fd05b7b22633a29c90c28abb5ceb64786ca08aa2019b2f277dd283bf44eb46d12002f579ebe9490566f3811a05b3ad17ccd9210e786c7cc1677db03eb0d8cbeae2bd4c19ac8782098f09b3f6f0edd58306d39edebbb3a269956195e5ac52f0a748d6e691280c03f7fdd25ec803775bca7026e01b13de8f65ebfd5bd216ad46735e47b1f85eb85fb1917afc045a20601342473f8400653fd646fc6957c90d8627e5492db93c42dd1ded2b56d17720ae85baf05006516c8f9361e3219e9f2308b388e3b1acf83ea021f98389500639d9254b42392523108b7c8104447bfba408f7b74e474f503ff5dec1d16a8c9e2081aff3903b98635864e29d24a54e5f02be5bd99250bd6938ac2e0a0093ca4ced381f0cea01c38ae3544c30c1e07dffd6680a389831b9c7cbe7065885e5cffc0c253dac619c6286fb0a705661d04e1c3795ba36ebee49773ffc0e68d38672cc152bf48ed66f62f42fddac3b64ec995a0043728ae99b73f5473be1dc878ffa0d06e11d2392c740af6e89087fe0be33f285dba878b7abe0a7d12d2020ba489cb5ffa4dc0a700a4157c0afd43f7af7a4edf1721ac7348e2ffa91ed4fb8417b3ec4e20cbf21be977451c6241d17863e5b18d22c5b4ffdcc9ee64b1a231912e7b6d97f65d4e39cb6a033d069e10d25a0f7263416e4205ef3253e4257472d61ed20bc98227afded1fd3d325e28542743f6fbea8bf5623651942f22df1159f986a1004aa6e2a139f977da2cd78bd1679c8f656a70b4100ab710e3371b1ab4464f382ae7b5eb86836576606f4d8920951043fd4eee521820b176afe33095e07333a6da41aaea2d5c0a49ffdc27b4c5a371a4d278314865b57bf2f5a2f7b90bee5234fb6a279da82e31be446a6ba2360828fff74072c1266c93f9e9bab6accf09bfb77f59e7df9a8ecf9f2b781497bc1ec07c2acbbc271e32cb5b5073931538b8e229034ecefa25492f744d0db8d63d2618a9be5619cf8d3c53aeb2b31099f981ed9a0eab7736c549f851a2392f8aa5853055d795368d18a88ab9a78100cff1a5ddcad6e4527b9555889faee4f0a262454b19ce5609d8e2a6196e561c5109e115c6fffed5b0a544af866d39efca008616953152185daed3440ddb799e4e63aa072396f4572626032cabe5e6d45b51a730d1e31190b1fa66b113093c8dc87774d019978db00d98a0f1fdcbd3b0aab4b20dad689c48b43d605354e3e40ad5bf49fff9bab1846d24811570579faff1a31cd0453a38e6b3eaed26735d361dc80144cecaaef0e805b6577a49e3da75f09369bd525c421b310b7cd44713ff738a97cb0bdfce966992bec895de61c93a64960004bf6aecdd1caba4a83d23c1779624ad4b8ac53581bd638eec9e43aebca1e8bf1b8bc451302df3c4664bea9b41e7f9ba4533bb53d0219a92f44e884a3395632e64b7d3bb59d27467bb8235dbd867922addf6e20ad3b037f9bda6656d5fedbd25910c71d63ddb4a60b50d01d74a604d6b7797539e24af254d0507e4ea9274ee0ac8273ee93fa0b9d9a27545dc70ebec1d1de31d32661ad0301c194c3b238613823b38cb6b905e16993f5d629dce4fbecd5477bd23e93ca72f49548dad0ddfa17f09bee50908c0662bb63679dfd0c23dee3e2f9dab613e5fa677c942cf6028763d16f921f4462bbd9cd194a39a9b27e280df72a2be257defac45f3800a513ba7bf79b49e332caafc6de2d8e21bdefebca3e4c53e5737e7f7a620c0e18556d51808254552cd53a11adecfa3c0b1cfa70fd35f6473fc77ef2a2d008aff324262dba544b4802bbe36b21f587e5bf87b3c2352a79469a44dc7653aead48513a3f24861d9ab4d1d4b2008588585cbd3c8e170981e92fd948742da36d81efcc93d2f8cd61f59a7bf4b300598b3e44a3c3ac3eb31218c564e70237adfec92683450d8e93e3847861e8f88c8bcee1ea93467e2f2879893b8a6e14f175953c31e67f1480a9fc91f4a998b4e29cb0fe132bc5640665615720c8bd2cd105f3a6d632043cc248d5f966d40fbbee7ea7293dcd0ab72c7d70b730bde1536ce8c8fbd9fea684a1b2c3749b72baecbf0ce3ff725061c501f38f3358db1cd3057bb1a21741288cd939aa10dbab1efe0b2198912a64a22c8a289f68dea28b80dc8e905ffed084d17fad1f563e415eca5a3965d4b97cd434e25c1a6a0de9113f4027eac48117cb7f97c3940f208bd50b3492d04bf9a1f76c8323e348241187c1667f2374351a283bc3ade377f9cd2e58c247171f6da2a3ce1380694fdb69d1d5b0e4f8e4a4a3d61789b216bf0327ff1936d98975c253111d1917e2e3408cb4378e398564d3162a27d6b425886cc87281c01d812d82e03a50d964083f66e9aea6febc991e6bcac71552ce1347b8614400861586222539de65fbf044402728cb82617ebc5ef837279ba5c8e48ca10b1c9160198db3832908dc6fe6f99c06632089f7c559c77a7128bdacbc55cc630b288eb4ebf5d8aa1ab246f8426b40c5c3213128d6c7fb3137f2c49d6b8b2ddb847febbbdfd0962801b097659c14b4650584eb37442eb483ae69e71515d4929740f262e5941af6b65e9ab186e0df9403c155681abbc874703cd249e12404772735d7b52fb7e19cd659607518f50a181584a96ea40558ea190790de4ef0ed723d39756146aa12b6db3da7a78d00129922b3921873cd13a8790b90aaefadcb5c83fce006e29471b7e297678807e40822284ef740be32df4f5b7d66bcf424962a398ff2a7211c207d15e698a7ef1a5cea1e98198830cf0c5498f235783c9b9f3c33351b51b06c3faf0a736de75ccaa0bbe406868c7da412211916fd3978fbaa249dbda6d4f0e8a1d812c327f5a3ab2e51fa65e1896385748573431d28d0772297b75cabb15964b5a71b5b6049a8dfd8d2e74ff1533b402c2c2694a36e127888a6add02af784c966d328c3aba2c3082d0fd99026add2b6e07dfe069891ccda439b8e33563b9826678c5e78f8db6218dc0091352d5950a35500333f7fe271c0244e7ca33a2fcc53f6183aead0d721d77e4157da3f30d7c4afe82e491e2e0773d5306b9b26caf0b0d586f66143d50122b2cc38c10e2a0e3a72497bf12daaeddc2034324fb5fbaeb18b3ebda7335481fc36cbfec84b9b14ac0dcdfdbd6640c271c59268733ee0a386f5755ab4fdf5e1006e25a9d1735d3c48284fda014ec9d9008d173dd41463305c5ac6f059236024ad0ea2f47022b1955e3e3bf5ec4a9d43e7939d95a81b0b3b49cc44ce8703df5feea972d8933fc623580ce667eb98dd0635879f62d21e6f5ed51cad64cd18687fecd50b0b08c75110a3778cfa9b51decdf54033222aa3fe146c38d6c4e978d8553c28c2743b40fad54053971a6b230b95da56ec3896e6719ff84d4dca4576c641873c52387370ecd1449ac496b1d7f7a143c15862e3261cbee29cae0c7ce01df8b2d3e750adeba6923d3d97d7548b688b6222eadce367c3632711a6a6a4dfd7af91a03c0c2fee20a3c5e25ba0e88b7a37aad48f0150a5aec9f894751c79dd38fd96f746dd3f55c845556e9e35fcb759e7b3179e91fffd5723104c47af8a0ca5d5f0deaca8e2e7df2010b026dff376dc3ef673b45cca684a98fa85e109fe178ab2e5321120057b34f1e821f062b12a615d43e738497732d54abd8cac2bf92e81ef7316c3b2c98d47032e7a03ff65c82896585e6b97f03462f7908d742af66db19b017551b8900e1f750eaabd506a8bde2cb74f5e3d7dd20ec4474c6ba07095fdbda0a027a13893f0ae84c4cbf71e3e175526f8d0e59a2e2256dff2a2daac60d8cbeb91c3e20d66f9f29bb9359d7c8363a6df4556e40b6aa44fcdab7e4492dd8ffa46861a9713db645a3333bd27cb656b7a77f4b6ce1bfec67531f1162a15418e7d99490b8c0f3553e1276b17aebba0ac58482f75c33dc0353f6790d5dd9512b7be75c735148a3cc5c658626adf0b2fdb69060d41e433a6f550d459142e5ff84c697ada24223dfb88c3356f0cf526f49ed4c1e199d9d32033e1b08f659309797cbf6843e6d1f2869b5b2091c2da5628f7213f2a0442d3a0afdd01dfb56fec9d3ba0f89ab5f1517a99fb07259aeff1d49d65129345e9ad47fc50f66c584372a3d689463bcf4c0158cb4c0ca897370d48a20d2bc2cd42f0bd0c475ce8b0b55117411263ba200be3ae78c8ccd829c855d405563976bd02ada06514810d0018c35ffe2bdc8e04d49d789f63b9ecde3e07f83db43ab5e1e77e0e6e4f6f750a636f86db7b651f19700fb6da9226e987911e6d411a00b0d393e663c7f60c57226e60f73be1dd6f048f01d4348aae3bfd98fadaaa0983572e8c8c520008cf44934aba8ef3702c7def740b0721799a08210e990cf55e05030ab6036fb02c652a3a07bf46c0cffe1f4e0cb3c7b7143c3904238a54a1e6f14e40c058228923b3d45bb8cd4a5d96bc5dc76f245acd8dd3221937f7c4e560531fe8307cb852cdd9274ed859b339968dbaf42a19100dabd8843fade65f098139f064c83a2dcdb117704f2861ea22a8f4bbf910935ae1bcea2be426b402b3c79d435ce240d822ab0ae7926943a18488fed89491affa698dfa39ae7cf6533c2e8ea342c8b588a76c6f2e5e033546d5f4ab57e5fc6f140052f01f89c4e9fc1aaedbb3b11bdf58ce0f207d306f54cb726df4aebdbb03df79165746703760c058304a785005baacd7548d2a0fbebcf5a9f30be01d200c479b5eb2124a35740e961b8241249f18310010140df92ee6aaa3e56c70b2f8b19f68d3173a4acc760ffef213765f12021ced6ef4c1bfdfd676147c60cee61558dedd1c287b5f2d374e2048358ab28e16e4da408f5dcd8d77b35de9685fabd8d4073aea5de43b6cb7d8a0d27c8f7915a013b9f3592743e1999f8eb2f1dcdbe7bc42060d144cfcd6030e1f2e900bf108f85b7f6636498cab5c968aba705d6d9510842aecde6527414f508a610bc6220ba9fa8f93b9fbffadf721a7e2a47c01c983f6113376d33dc11ad2f748d9cf3113798d437301b9900fb60e00ce34a273205b6ce9b25afbffed5a493f2706307e95ff5a26e1c50ed43d5d9aeea927022c555e54339f1edbe55f9d8151bcc1d378df78356820a38af3e8ac3c85e7535e957631928a83b338ef4a41208b20ce5b430f80a2dcacce871fb624d7214e4b4df9707d23fbf78cb224c09ce6d1a862c652644ae668cd4bd77f8c4e95e0563a8eceaeb12785ddd93d840d71b32897dfd16f306dcd37c25ebba38ddab5bf882787c04d7610f52d07db41fbe8ecba8bddd7a4a50e2de0c71a43480643b76f14590dc3b05a7ac85649cda2f906320d390205507ec1f3378a9b83ccef6ed03ff82a80d98e53ef378ff42976ea3bba422a4d34d75fecd7f251241d5dbd703e62b474e2e856671a8b0082f20e75032939bc7513d00b01d3b36fb7f5697194edc1dc333f96ee6667bfa7212367d1f2d8ac0a7c5b6381f15c7b8b97c382d7d107239b77daf97154eef0f693c01c6b7538da03f3494d900608d80463cbbc785931b65d86afa8274fb127d34812ce7d78a1b3654be4109617243547cfee4db73808f3c57b5ce6e13ea1f0de7263f96b52f05717e7015b2eeb4408047d01d979c02040bc5c272f030b67cde32ab0cee9a0e0c06caae8890d5d66d0fb0c509a8caa1dfa6b8ca64c0788ba870a6c80f429ce2c4f7715aeb192a39f8003f543127f45fd06158ca2d9461e9d88c321da2c2aeb5b64c3bae6209edfa7855cb7db962d83d7150be8e11f9bbd3bdb5a9125c964e82334eb1d09b671981c734cdc48a828d0ddb5e1ad9a257d234047312be15eacdc58e423f1b798b900211d299642ef56525f042e1ae1bf5df912df6b732024a4e23666168013e799680a4bca9fe4e46304f6f7f17b5d2eb61edc56530c18b4c6040b42778257bd6d905d1ecb2159db5b5b6ab48f13136e5d875db37f3d9ad6d23c016c5fe6956037778d0c45fcf986b549cfb2758f8557d8e29334bd421fdd017ab435565e5f6e191f6c13b4d644267bdba00d33bbc42d1771bbc2dddc229a1cd28643a4fa35c02fe748d5dd5d2ae7149cf69a94e83b6b0df4d1bee4bc3d9668bf4b3cbeca4ae64555006f226b14b64fd45385de91ede9e9e553bc4439cf0d6dd53efc9ea4805a6d4d34e59e09d060351dbf041e7991c8e628b8561bb7529323b6d673b68ed572bb209a43bee1c0d03b5be4978b0d81d6cce48fbd6862a55207ffbc0c5ca99be7db0570e7a521d9cbc6a48ceb09f5b6bbd2752506bac1446f2a8054fb2aeecf2a7f7e2300039698bb0ab3e9246ff200060f0394f331d16c45e826a5e9b1346337cd5b06d6ae5424a44220c7b6ca778c1222207c2ace21b579b1e9539ecfddd3bddf0f45fe46e6a163ec343a5dda32806952a1561a57aa9aca2a4408dbd905150c21cfc531f1ac607357476696e1adc40911839d91d464a35cc172e21ef6c87f00612a9e603a5fda431153985ecd0af0d7d6297fc0acc9b20c9a9a116112286f0136e871684f24f1afd6d1367f2d2994927eec7c10196a78dd869d112ef3a3d776e2fa4932975c9f683fae3cdb1a1c9eea8ddce6ead1f72804f7fd16c74e9930f02a0fe2ec7afc50540efc03d81aa64af944694c9f0f5455f13cb69b28069acd02b15ed95a6c55af994b228dc68584a28754445014f3c58e29e0b1ffcfce047d8a4d5a3736d4e8c87b1ff109c82aa271d58a47e8244bf714209be92b661f34867b1d217bd6e4723b60cf2578541de14194175d10f4e210e058bcace4b18e49926a471126a89c0a4564bb10bd3e8f8041c46f6eafa113516c48cadb7a93eac834ed3a2817a2de71c60ea9bb23e6462fb245d9cf36774945e60d149e50c5e1b72398051f7f4aecf4d42f720853aa032f0644cf20539ee5b908268ff4cbc871221647ee72605de5299553404b622abf864918a77af904ffa21b51cc044ee7649b089df75d71d20a2d55c244e1a936ee48e64e8e503ba994c135ea6e561ba07f0138e1f50a23b865a6f5da6034d60101039002f7f4d991a1be7b4bf16a1f981669d418f8471feb354e8c5724c5e0851c8b9d06d10be17aec1b8502dd899d11996a328adf56a071bbaac765cd4ca06e21f8a896c4f5d6549f95a6634fc3f39d050c3b2c282f5937d8a6a297f32e976e0e7d6afe3b2b5932d24cdbf30e06ec5411a855b114126b16187d6a5106914c71c31459ce6f65a501e077de830f1b433647c96cd5d1a1fc53f3b67524c6aba4929d5b80eecbf76cc7169a2e099efbef5867374a69ace6d79fd00da2b16908fc996de660fc777e2785be32eac1e534148eccb055c9855da2ac9aac672b31fbe0e5f5a203656967fa5a0245f00da2f1db1b4954e74e4b0f6c7df0a9573569d2ec987125da64ed5cff854d05df1c920dcef54d1a8ef100325d08a0d906b1669621bc51e288686625953e678bd1798c8d72b90ae218f9eb79f06b9e05559a4e5b9b2cd7ad67ada912ef58874df916bed8f4c690ba07e586d96b41cd107a7ca00b44001e2d166eabfa432399a927ce7bc9e618bb09f4a82c3f3b86e68bfa89dd1fbeb8bbfae54d94a1a742266e4a5dee8d6925750dbd7cefcdc08814f4bcb49e15edf4af3a392327ef6bbbf5f0de5c4976c1f42061de8e912ad2f83bb4ba6cc03f976841ee2a6f7f5129ec8bfb290c4446c0396a7647cfc5da1944827ed3c8ed945bbb947daa111a2a85e943718e463699d48a40b3a8606558bc76aaca30ddc34f4b6de782484581ca2e6421de5f87c7d95deeedf2b15a734df423c0f5b04883a4bad68bf26df494ad5067a4fb70b6cd748d1f46527ddef7b431efe1d34693938021a0ebd5fdb4398af4abfd7b8082b3d6d80831941f0b20bde849973b3a223780ca27b40b1560a82c0d6530733d3ff1a8acf9b952d7205e9893073bb2226937c8ddd5e19c5d92b96bde18eac0e9c3729067703744616f08972b5ec60b9427ec2439d436cba8b966c5bb21347b7df88b281bc119d58802748ab188e3618ef693a97bc48c08a308025c3aa696b8897603464a4aab48e427ffe9ded941e896c71c4aab2922078051525ec4b8541d63f2ec19700ee83cc3a3a2204e85df29ed38346780fadf12298f367589ea5a2c24e5b4b4b2a6429bfd80f57a6ae9a3f14f241de936ac736cb14784a180d9dd2a81e37975901a9c5e5d591980f4ab11dcd4f1cd2e6bc54f92a3b737930563162fdac5c9c60907bfe95f2d9f79f2969a48c323d38205015f8736fd0d5e53f5cd239bc559b076ddace1b0972c379ed3709e1d48674c4c69d1ae633ff11f2f6bc816d35e60ba9dcaa5fbbf99fa20bc191557a64cfa4140816a9db03ee3d8f3543bf81d5de1d1e21e4b08ddf35e7776926bef2d5e848bb88a77a6a194b977be19809fe90eee654179314c0996e5eefce48e9d188c0a70fc7719797fcfbf7d6a3879642ff9c664d5518ce1a68f1e25285f95a6ad6cc35283602138363322e78b28ca9bcae9f9e4c93fb8af7c9272a6147b087dbfdffbefa6f748efa221e0e56378022ac07c8a91cd9903923411ce2d009fd08447b828ea4bde793135b08c6558fb7a1b06ffaf982d2d695bbdd6e8fadc6803e86382f3fcab73b36f4596cf6900a5176d5156819f3ffa3a3af4a5ed2f24d49b08e91cfafcc10ee2824e563d6f66286ef36f710900df1d74973db16e367bdf9e4a2d63d23d00ecfc3934f0820bdc79baacde9b156ff57e1467f0b09b26928334d5323e70a5d93d079a6f568af9465f2693d482a771ddc5f3fd11214b46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
