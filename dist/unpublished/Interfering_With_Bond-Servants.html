<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8c91e04c8c774d75297688761545c1185c6c845c7d1e1626e4fe8ab0b4ff31daed90f6a042fd8d7067e42a0de887371fc6e6ab652680ec16c1f5677f95a4c1eef4a7372e10b4860e9fb041c641e9789361b1716fcb5da082756d56b2f3a193063e1cf93bc87d44ff7ed18fd0c97fbdd609804f335b7e70d93ded70b1380505808b8d9607243bc2d1b498b8613ad53dd0077918275c40c9cc43db7fcf31f16f7ace69a38af15fcb359dd7951134baafad37cf6f4d9fd8207cad105b4ccfe0fa54a68b4a15f4133e6317209595e2d7239c8d327ad2ff22b604e3644e4ce59ff606b418570912f95e238bacc8b573c03f127fcbe5b6c4035a47a53fa0298c5332d889b753381b05fc68a974281aee5e91f68f3e3ac1fa2b393797e037188b94d40ca11c533ff54529160cd827a9fbb0c964f7271ce6926c641184158117888a671e4dd05dc37fee9ad5ab861d3c2cb982b22aaa8fd83193f4a54357364d06223579d08096b8cf0bb4eede505d569acedf600c4b6549b52359b1ed8c51132e5ea2beaacc4b9b54d743f71152584ae57d7a5629b1b4c5a81e6c8ab94d89829600e4b95f7453dcdeaa032f65189591599d0dcb4751797af68a33d2548ac14052dde74cb290f8243093b84e0318313d500a50e533f0e5a7a4f9b89a41cb49a75c625c38247fad3e756e4bf43ca439ec693cb977f105dc02dd99973cdc765c33d91a76431b51d6c071432236289ee28ceb7d107a020e88de24d7ea70ac4e6825c8d4d656e88dde8741b0f896b41453d7a2d1ab277899ef4a5d4d5e5509cf9098bba41eaa502d6906c09a1a25cd03fb6515b877ff025f66708e063f799942d6c990360a58bc571c06348b9176e807cd2500dc9c3d4e98cd12b2f3f0a7c86c76db04e1583f73881c049b2dbebd4dace42f47af836571aa514bebf59e23ac434b9e1f9b137cb0c4800ebca189e5e2b717329e6e8b4b048a5cc43c36086d3db4187f9d492ca06f04315eb565c27a54cef6a5ccba324d12bfee6a9cda481f21f91a1a01b6c48ff520985c8104c63dd0d3f8f6543a0da3188b5c2aa3423e32abaf91c3bf76cc6a5649d8557062143323f74e9977cd4daa9c6aa949139ffc96c7197126c769051dbb38e77b9065e6bb7964561a704e91b705c2c964addaefacad319c24945d01291c75e939fc399308da74503eddc498cb7bb274c623247ed25bf59a796f23b483e74be35ec9e30dbfbb045f796d8efa426a1a83d0a6c87343142c05b98b62e34b01e34bd6ff72ddf8347a07c76de350d4e0254b84781ca46c79d034e28f717dbe273500e70f23506964b4aaaac46ed578ed83180870c003e802441619b3f28d6a9ceac03b68d42159be51dfe1ce814cc143aa887c3203aef8e2dbc538b598802cda2bb611e1068e0bf420bfdbb14516d18f627f8f174207a23851b24b814d0c256a240e781e0b675fa82ee61c442878419ef00ac5244a1f258d034835e41f66b14730a9c23e7d972de1a8e53abe35ee13af00f4a188489f47da7a8b90baa6e15a184eb2f9e18bca89dcd527daaa931648f31facaa565f829d2973a9a72e7252ec93e15c74f2e29e0e43b1d61a125ae9c0514ace9fc6c163fd58fee5ee2ae8d386012c13ee5dcdbe3dfba7a900e39279eac71eff83d018c7c38c99598f5def461ad353c62f2cc380ea806ecbf6a0cd98d239383c9c8d22a7d8e4e8812d238c983ed1e6a805a19c368f655495003090e206f3cff4d046dd404ace3828055fea294028ab40b13c403757cf2ad37bc6668e6cba4fa1cedc7c68f963e9e0237a70e08e03dd0a64f29a6ee7dcb134550b328c262559eb4e53ba774e7c6c34f743f87efb2b643815d9a700910ba69d95ec40cfec2c1782bb3be2c7f1455a26d42d3647c4c909e78fb51712839882e6eaf1ef586bddcd768d629ef35a30f179ebc93eb7d4c0f0e81e595f089fced2c1da388cc8616c04c0675c587883dbbbbc1b0f43b31b6c669a97b488863a9b85a063b638b863e2a821fdc572f8d0c84e196e4e912a6b3b732fc45c86b77982fddda16bf8c897b408f71bb572c122cd543f8ab6be4ccac5ee7ec12ed8953748e90b7bc22cd31943e2d65be120bbb03ed220fbd82ff9e0efe2db2b832e7e0cfb2024fe5744a04bbc8b6f9e2dd829fa735bab4c38da122ca825363912ba9ded4b83af08a7e529ec09bc30e77e2eefe756f7bb48deaab40ff1d64418f8adb39ebaaa0c500d6d9b7386c1375734b9923138eacc7df68ea014debc568374882bc9307a6fe37f5cbb73c3d63f24dcc5176586749ea2ee4853893d02e19786d12826878b62164611c5dfc54812654264d1471bce29d19545c638ff991c9e8527df56c9491476c1ee0d77a7016ed3bbdbf93414ac53ce67c884f5094ade52568c8ae4e1f2c3248c7dafe2b9daa62c252b15376f5baf951282c1f6e5c0ae8d35cb491549a1460f7bdcfcf913f520f82b8979aa3a3d41e28ac5d08412c3fd2d2da0a94e863a7939c0bba1ea969cffa20eedfab90a818fdb6b1b38acdbc6472cb021dab82613d780658dd6b54193e18aee1189f68bc90fb896395b21aa61e6061474c58ab6851153086b6e6220ee1a918f9cc14eb3c171fcb484ab518135490cdc0b7d2a95bdf716501fd094690b1cdb527d131fc29310ccbc1e435364db17e3a302f23b841bae650e48816e4cba32a5428e3ad299c9265b8ce1fd0a3315b76b91b45a3b767ced3024910a9c2c18a832035425cb32f4a7d29dcf14c620b529cc5d54e41909c18912b6e8e9f9b8d5bd6487eb42ee2cf174331509cb51345164eafd904d3d80857f45f923908e820cf0cdbb651b14654082ad40c233b16dfaa8a8add5c44ce67cb182d21324d011a6361bc896ca584b88be10b5136a93dff7ccc9d495f4e9079ae9123fdba898496561f06a670b3426129bc94ec8183e786624472ab029b73e5568ea61d74fd6d2b1cd39f41905ebf0f42bcb228d495d022642b5642a8a9423e8007ccdb56e7da2cfa1836f2b0e21034ab535f159764a74266c9bb95a8496e3bfd65567c3b10da7e334c7b2f3ab5115ae36888c1bd82cda1a70d68a84220b9e62f872a9009ceac489207674a85a202ac5421ff7773ef65ae84cbe36c07bd9d40dca45ad1d2e4bcb687997a301968150181f739bb6836d0e330c03a85697ac13d0adffd88503763277ca1423cd19abfc1658d7b528b0ad0d988c0e11a5fcdea59774d68e0d843ec689e1ca296e2098559afd75f11638795380a6fd2c7e6690d11b820b3a399a03bf84d7cb9f34fe5fb5cab6ecc7ba80d5542004bf2d458c4bcf502f03ea003026c57531a6476768922a19a55801b0acfd2885193b71e7535d579e41dc3e52ee44298c0869640d4176cad240a321a48c19d95e1f6449be363fa83f74332cbf36bd059213ef331a5fa4d8a71a7aff9da2b0545bdb04ed18609093fdfe59b59b3994a1b7187a1ee33f6adc4d3ee779aebeccdd8a3306121b01b3b6ded456db0667dd1810e65271c579955f3320f8d79bfc2f079be3ed2eb863d2a5d5745dca887769170e2db29bf992d61238889afdaae29b2605e0ade7c96dfb677c9c5c86214b6ed51466b7d1e5d66f5d8a7b9eb1ae54236144aa23afd96aee013ee721ddc969e8bd444ddae9081b1f19ab8b1c07e7f38268a55d2e88a7f07001218cc5d3e9486819951a6348fd9996880d410df296d9c1ccc87985e21b95b4e56e0173e428c13c741ebb22c6ad47055990cadc1b5299ddc1b11624de8bfa5846b3e4ff7e7280a32f9b5930c3f27340d669180eb884131c5d6ebebf0e7c86a27616a556f047873a4722ba8e3c68e27a988a3f0c0431dd9cb7037a0528ba7ecf470570d1c53b60b564786975ce4f5473baff3b50ff21d679aee3cc462d84df884e902aea7e221847056ba5e9248bba97ce9d9336c8ba4e6aed39fedc016581ab1d5fb98b92f6f6cbe3bf78a95cf77f38d810b279ef561f458da7787899e02b0738bd6a291b19219a4221eb661bc2590da2213a17cef318182fe2424be5a6a0ee275f993efa7fd1cbaec5f13e095e7c363a46e1ae9c24452329722a724ba7cc89b6308e774e698a21b0e1667351a3398725d7154285903fd90c0c3c3552a2131336e8622eb43f49937feec23cb728a3870dba15533cfb38c70bcd2560f605b4ebbc7fdacc1e505224556b8e0fa4479b324bb9fdd74537d84c3e1f12f53c1a090f8f7a3c0fcae97890efc0c6f3b5b123c562ab55e31145cd79a05f58308db1767548862c5c6298d8ce9ae472d98404d0522d56a1745334952daa8a64dec7ff5e0440c8ffb220f62a3fa1eab5fb813c1f299d6ecc6087a15bdcf64e164ee972d82a4a20e27f376167feac917a1c8237bc4c2fced4babe50c9528f2eda68a28ea32dbdb70636c70d09e1a0c930c4e15903430ce3aac02e3f39e81dccdb03b377a8222382bb5a63d2f2bb008c3691c4dfd2f4bc45627331bc6b60c0faa4902bb321c5711a55c6b8dee12605a6dbaa3037b76e81be5ebfef411366ea9a3119c2071e8a2dfbfc344785dd345c506cfc652046769de103ec0842a1ae0a80a81bd8fd5a8700371e99100b6d871a52d396278289f958e1b0c9a566f7b2a20be9c1308571fc1c296a4f359679d25c825885da6906d5955ab83b93dee7f10e1d225860c79634d9a58c3f264995c5e6af94b76b859f2f8a647f6469439379adcc038925fea79b3a8d1a611d3892f5d54be54120fe13a1d00c4b5288f7d0b90e76bde39e3d0f13afdb86f06b975c9f7d923a71938a97911c8f6bd6073f11c07e1bedf0f45666576c5605fdd8798e6837c563b86ef8fda7017a46a73933ee251bd3cbe714b42abaa6b96208bb33dfd46f9c2bc00e0d7259db1847355582b8800e249715bc18f931764051bd6a935310c47c3803d69940dca43cb417744e2068244dad5b8415387de2ff2126e26dbc30aff0b0e4b72e62eb79ef51bc6171510dbb27230d410f08c08fdf43015418f90a7e170832581ac94bc3d821ac51de8da973c29ca0749d36adfdcd7ddea12ef141978bd8e70f96dd8a89e860c4fc156472e6cd7163ffe9a41c6bcce4f8af5123cc8872791d89e08cdc2789d43725a259c1c38de8deba7f4d7ddebe668ad22b38dc4f6db1c0291209a552b4906e9e324bc2b2dff3b14307f76aa3874958c10f799ae74b6a6edc500556c17aba5441853b01e028d6e67e5e944d3ac9f968a5b177d170426cfc9595fcc5f01edd0ddc8ef822a88af2d56331076ac14fc737256151cf95fdf9224d4fd8062a14e15f0820df3446ddc760a8fb2337a2540b2a8cdf848f89474e858394c3b854751226eaf4147dff8d9ec6590f0a4d6869805d95592b8cbf48ec07333adee55b3b882e61d78728563f6f9e965c22aa8b5b848da8142358ed6ffaa20d2d3c216f0230bef6ae3d63b694969af4fa22ec1018d41459d8227862c57a41d6cbc6504bfab7dd51272ca1ad52ea36120b40c312079def8780c58990f4b737e5ee305bca052c2317f877f847c341261157c364f3b680369b34d2143ba5db83c1cb30b47fa32e91f74f2aad30a329c1df6d857377a7b3f1c2de950cef0e625bd4d06c170b235542df8cd0ed77bd5d6eea56e529a101c2e89eda499653e114f91af9a128737d29d22bd193b5e009ac8263ff9b9bf52d6c0ef700fef1c0e2603c255dd80c664f37de8bf99b5856fa86d0df3f9d083fffe941f96f76caf26bb44590735a1feff256d51e87f5464bd9c75bb51c005afa29c42ee630ac51275b37c020b1a38f5b97ac8eb61a0f7d579d85b9e0dca68bad965335f3d022b5d5e1410c0a17478c7b66105552c115ccc99f60ec0754d5222477deebb4df369a7b71206b8d6c8625a15bb0070ea96010117bc41cc9d02668e80ba857c6d4cf9caa3f4496206175d7d2851cf639b1d57cb4f6a2ce2417ab2046c66faf4be6e2672dd9ca8f17f1189df248df7233a762ffa0d4400dc76523f48e680c29de8440f6810c2467c1410f0bbb33dcd40d644178f6a30dc8bb9edba014f7954fed54241c18f1e32eeeddbf52217ac0fc87735cb86e4afe028c7b00e558a7b4bb2ac6a8f50aec088c4ed4accf977794d8e254f192817dc34d2ce18f7bc3eb150deb606953c9e714c2c23202517a1d5da072d57c013876df2b9815b389aa2f3233927f75b43ad5b968affbbaf4ab1e2d7af8a0766d8e8f58a9c7343ae33e1c9fde163f855bce98620982736c0f7d811a53d012eca552b34e3f952dd079160b6e1054dae3f12f625f1da956b7739374db28ea9d21993540c106beab6062857935ac09e0c4d194c5b1717f7e735f0117819c94344adad6ba1166b71ccaacd92126e40841dfa8967d96f6ca58f8fdcbf3dd544d8311f99e1fa78d0f94bfde24b8512ebfe1b558c74ef3b6c70f8dff24b3038c9abe8d2a406347bb2067c6f89e4576329bc1fd911f60a872ac6a8e226fb54088404128d3a0291a850894adb5e4a78e0de8ff831565a9224422273733376a422ed2480077fb435cbf6deaec679874a5bed4a524d23ce6745a039deb582fffd6ff4ccad64601c55481ee7d19f8a606770b9e0faff9fe88b9b7b2db384438f1684aeda4e7fb2809fc07fc5dadedbc04e69113e30c52fe27bfc010a5643dacacdbf7663ea3f89eab5f87589daa956fa8589a1c70d702d1161ab22d25804ea73fb7e7c113f58de424dd18be906cc75a3cf5aed2c7403f893b697251041a7bf1a876a56e66690c9ac817b2f92da1e1f369f08c2e8af36aa293d5473e275166f50a7486746deba51c23d38ae2e23cd3c5169d11a28f1eabf901c7d0190c29a3303b97981af498b9a6ac4b9eae9acab382ba77b733d0b6af050d76e5a542a1eebdbf24e2330bea8641772a47f2ecb657ff7e6afc3f0afeff859464eeb9e48b6390ad22be960a399008ac7db158e22ea8e507075e896b1219869bfdd1a96997c2c6c7e605a38df5493d19c72dc53a00fb71997ed830fe6a463dda775e4493a1d60da53d3847ce7c5de203fc6b8f12c4282528dc9864a0f6856324038772ad0c9173ed51f931d79b11f4a2266884a1255b41ed504b82ac9ee75f20349ab69c3baa26eff75671c77400696e538cf6dadbec400f51070f7fe75a69db29abc2d39bfafdf200eabd4a5aa19da1549dff0c50fdc8e57f903feb85e277559c38ad920479c8d05fbe199a9d4a993b3410010cffc15943a952a3f241ce411194d565612010c7ab54c2abc9a1dbdf9e9c2f2d23b18cef316b5f359279a356e8055739d0cd002a12baf4f98311273899c4e96ecc9a45039afcdb0a1b9eec123cbbb83cc0ab0537f725e89065887e3827b089f0a5d5e219c5261344ed5a5a75dc34fe5ef88379ea43892a1d0c43217f297bcae7a6c9fff1187ac1a863d1cd9f1fa31dd56d2117489a92a1856756a8a7d3f779ab286a89921a92660383310c99ea124d2dc9ea76ff76708efd54ffb73ae45199ed81c484a88308b795b97a0262ecdf472c0b78a27e8b005a0a27ad90409d4a7c1badc01eaabce8d3e858344d58f0c7194aa1ce013334dc9f511d00f3366e3f07c8f649c1ae9501ca2f46ab2afc25903ac9ecd1fe087fb33146736a70c4701403ea04822e86a714cff26546d3ad982fd0e0a43f6d8f721704397844e8f001cf6cd8c7ca202d52720ef845b38e719d8e0e227f994eb79fe1a02c8c611e177107964f210a6984a9164fc068709374059df3c1c8aabbdda7f05786d78be20c44b2fff418bf34f468e8c067758c777ab2895c761c79fe62a744d5cf3ee01a994db47f4be115fb94a568a53617f215e0475dd4bea687b02f256251a6eceaf2a54054d778ed8251b6ec21e68f3dfccf1cc852535e77ceaba8ff5c8547a0dd8a398816d01954722fd930cd93a706f2571ddc7032402490ce2c3d0b9a2469c8244d2d4ec64a0f50dfe8b32fc7e07614947d686e777d6d7839effe3568aaa71aacbd93183ce8a6a642763048d6a39ebb1bcd3ea7f9dc31aeabdadb587ab6ceba5bc88d2dff4f024e49ff4eaf1e4d300bab878e33526293ceb910da368770e0a244f73c12f0231699617d46dea8a40e1743f399ae870b770c058f7ddc93af9a2bb452370afa2a571e421e68950cb1f3d2608363f3a6c77b93d4e598eeb6c4349032b26a0b11c72670c6bd835b45bce9e115337eec243036313d9cb200044c74c915d871fa062cebdf9e8eef26b22612f08f388808b8598bf2b7722c84a48dd3324cf255fd72b879f7b925170868c96a032323116c07052f4ad03d027876b4dbd9b9769c4de176c170469ca90b0d8d2c2ae80190b79837c9ccf3194356aaedabbb5ce8a8021ebb9bed83f1ba203a4838d3ac6f782bfe9a66766ba817d8322d067e57554a4e7d5ecd2ffc7d94c890f880dda7784f1bdd8dbe0cfb71a120fe5a80c3b0dbe7ec32fec6197897f4be80cf81eec890fd043a01697a83e39c869007d51706a27461302f23a13a8cf5ffa9c90b4c57819a7d47d55062241a622267b044f13139ce321403e5a5b8203e4a1af0d3ade1714d3357b16cd1abddcd1472004838cca135b9f8d774e41b69c9ab98dc86b45edd6b96b86fb77cd3533ec600bde16c5ac293a84d292e5498d76a6301b20549feb57791a7d3e0266805c3be78e07ad8dcbe3e097ccc90d6655cd333ba94a0f16fa778a1723eec0679e99eaa69482cfff7a625ae8a3fc8c6361e12e0879bb1b70f5c7d7a62135ae040f47bf8b2d45220db84e9cbaf0300380991897dd30df675db2ea199f81e1fd3b9f5978507b3dd1a891c0ff956ae59b4c6032e677601be8b1905fa0f8cc2b32de403ada2d32fd82fde085b65dd606e4cc5150406efe0d270efef43a161acfeff5075a0f97ab173feae4ccf5dddfc40a52d38bfb01e6db7bd37e2eb1f69f35297c7facecc4799673adc41f46d8aa3fc8a20a9eb8a0565c4058bd5af920ccc2aea226ee7a762f0ef23456872346b302cfa4c9085944ec36a2face4d0966a1979f871ff89bee36875da72f551fec83985a3fcce5ea07a98a9093c4ff1f7ab42875f3fa307f04aee3bc7157fab0612959abbe9a5b18752565d7cc3126b60b2c3d63e1fd11da9d5f343e17ec35ae956b59a245238a86026b2d2b7e3a02748213948165bcf722f03ad6bf50a5d7854bfcdc8b1efc3fcdb6ce98b76d65b68720aa1539084ab74a9cfa7637d210bb1251a417feb96d523f2faa6db9b8b4a08fdf6752a99632b3503db1d8d862587dc056e0d0fbdc74b01eb0713a0b06b192fbb8ba07474b02c83fc54a438d487404e568e1305b644a9eb6ffb9e2bf1bc0012aab1519d176712003e7e123a934a7cea634caf501371ba7ebbbee5654f2921e44d11b06b89f231ce3073fa3a622666aac83f86cdb31186c3b2ac71fbd2f8dbb4780cc82bd835a03bee0ddb8f9e05fe5b35096c742cfd88dc72786c65fb8ec6379ecd90b6d40a4976242525381b9ba7bdae2d9f524e25e49819f53d7bfaa00abfe22e5a4988e8e23fda4957042bc6b0415bd6e5d9a9e644083a6ae4996b670a035e7e5626715d005c9242b8da5680509e4b7ce14a6ad79b84440487f4498f6b0f56ab2b222166785e71362a05e079ee9e023e168b26b69c53bc7e3f3601257d1e840bd24b43b8f6414652813bffdda9e1bff012b02f4ba83d46e04957a9dbf6a6e6007a3522b9fe8b60c381edca7d8105595f46a14b38f9bdf4e0b345baa61d5448c7f39a345e0d87b9967ab3bba12a08694084fa2b40d998c3726506d5bce36b71bfd4fb8777fc6df34d8781831c8d7bed0babdb31cec7f38e58940c71e7835c28f69a433da0d18dff581ec5ec77564f9af9fc48be8e5c528758e17ec127c29b0c014b39e94db265e93a57b2cda83f7ac9349baeccd06404243e625e566b7dbab31e0881ce7cd2da8ba01a7572ccdc5530c4c55877e5d90a0286c3073443c39d4a14f6fe82f9380517da68139194ce6f37e7a053245de605fd28e71e32ac17dac66ed807519d0ec5fde2339b3f762480947154e494cc20700966ca03e33a11057a4e7f7201208b4114584126fd4f8288e2aea2dd4c31da8f50b2764fdd872a544df0e87b27d6d470c49fc4da36bd6af4cd97f81dcefaa4624546d2c84371884cb38ab3ae41c8c3c356e4fb5a110997517f2e54f468dffffb64558783d3ea762d86715e6c83e9de2465954dfef7cbd0c06f1f0aaf12825ecc333e2e617249749bf74bdb28c8eed97007bf6eaec91dd987c802bb45102dd2d2a70144b6bce24baa12fb7bf1cc22e53f0cfcfd185f54efd80bd4ce83720f2036c22ba1e32fc81cf0adcf3762b3ce07eda1c4383ef2f8758451d335e69b0f2109b218f67c3a7cd2c735cdb89241fad1c24eb8410b89f98d399ced97462f2b96b7ce9c1d988b75056ac0420fc3507b138230bf184cc9c675fa5dcf673914bf7f645575ce24373de58d43b5bb791d3211b625df13ed9e231f06a63a69a71a7689f513a7a994a8065a55a67436a5992c92cbae5fe8f3549228bce231dc3e23a095ba3b4b287a6d2431da963d902b8e23b3cb251af9cfa731dd75e9bc944a8226990ca218d597be336cff285399285efdcddfb35c550bb8f2966e4b5522ee3e6ed0281ef283b37295f71e701dc0d6f6a289a38334ffe3da1cbe9fc0bdc13ade15b16a9f195d6eab341cf550ae943160dde38136ca8e339fa69223d6615fad5f8794cd8f4f83efcb458a77f70c70eb950676dec24ce25d97d453c0944694cdb3c1fa5314fa9aafd50e9c7243f81f4d1758e52d547cc34b0679acef760c8ff4e2e85e8925e4b2d24d45870df33ca59422edb4a64a7cdff61fcb0f56f1f039f7011695992729ad2cbe878942b7ffb2466da27c83c44b4f10e45b1655ead70c89a0fcd2e2494afc6da207fce93e23a9163662bb7fe31789c0e0774c8179414b9ebd2b8b950cc83cbdcfe8ef56cb99400e9afa7b0442e09d1ea124bcc5c22e24bc9a995988e7443676998eb02e4a562f6e3e23e4eaa7aab31f1a5bc549ff882668d534090b8e955a1429188a8b1c7e4cfb13d780d83ccef6518a0dc254870d79d5541e80f5ed7adb262972e1f13db775bf8b0e9d530fe4d313c27eccb9ef6299ac663d01ff94b23c9daa9a7bf1fb63086a293811118997043136dd2655337dd83cf7dd402254b0d963e0e70418133dd64f7743cd866d68eb244263426b17316b714f6628011c2b90c5712af635557fb4ac16f79244ba65b1ce0eee1106e7473c18057c43aa00ea94c997cc111caa21d3438dfa61ec51c8b22ab24aeded3b117dc87539f06863f8ad4982873c6ff0ac9d51c478388c9140ab12c1e0814bc904dd166856ed355f30fafb865033be1e164fa7ae393ce446abb8533af95f1e673f14f13bec01667d3e22ac646b6eca262f27f73d9f8abb0f753ec1b7e1e9cd59d29e6fe3a3538dc68b45186b330dcde61d0aff7fb9294fa52d93b75213924259c25131cd0b0249388db11649526751d3775e80202debbac356d362ee0a54634d1f6084184ac30f25201299579e0215ac59da962422f33b61753071b749cf231f7fd7d734b68378c35aaeecdf695036aff1ea909cf83fccf5bd9cc824c7e9af5ae8c48a10d26eb71f1c0c437ef30b757844199a73fad70f12bcd437b97a06e16fd34dc104bc688cf3177c34bc35bb7949cf8af1687bafd87b9bbfa29ea6121804d8b4c1f7921fb678024817e62a2b9031c74dd6e1a52c1bfa30b30efde5eb7807d0bc79d09552f683fa3e08d8f1f5b55bf20f550985535871666023ceb245196e31c5d56ff59695a69a424bbca0758a7238e60dfde59af383ff097de2059d949b27f74cba1cbebf31f622effa2de55d9c9adcef11983a78d81b20530951b7d990e4fee3959194b2a2a0e118c09b99e4e096ac80301f02a770d09b35ecf95e8d736aa9a8731e107c170e7a83b34dfa3b3e0128706d4467af0553e6d5ee9390bc62a4a3709c01760857ba7cab2091001e7f9f542350bd4d26afa1bcd97017f5b181606725ae987da93ce667b999ad63b0597a619294c219c5df203ca4a886e9a761a1576022e0d086bdfb455c2062fd8731ec1782b89749ad3162aa4576fbf99ceafbb674de6fdf1215d157a4cd04950aea488f23699872aa9fbe681b626728a56b5a24ccb8fb35c5ed6588f03a02046744f85d753560e4d0c0a2199dcb695cd82e53e3721bb5e70f29288518a83030d9c149bd23d80a69aff05c6d54c91f3ad1cad8286c9b2314cdd34527d4e4b24f1d2687ca89618e62b5bcb65e3b4d382fcf77a34032e9ce1260239374ac93a5219149d721bf504a4d508a5334476401d20bf66a8e94f698f18a3b1cd5ba4e692673946fa92ef69f1639b2a95572607fa3f27424a35062d10fabd01333056ddf4f73e28c1636237a665277a609ac6be3bce02397d8489e10d5301d16fd80d29a590a8424ec9bc00afef42a4c1fffe2ab8087be43865eb69ec774f091f17a54935a3fa148e7335ffdcf5c33b212e3e9ac100b90784790e8b419ead2f275208bfce5f0494e20d7dc05c03cd62f66f59fe0585836e6e74a2f66796ba7c9ecf248523e8a8d026823cebd350248b9b76d544d22bd1ef474dd1b559a47de2082e89f443eec16a076f64650e28f5f5beaa1f997f4d640b0349d6ec892b758e5d18b8e86905b0b6d3fc58553a7e402dc775c4376b6952d863736b8d6f34f604afb1af3fe6f4449109d3c77a907d8a62843fd1d23b92af04e70b54a794abf443de1ea6463a8f295684ab63d5f5a2216589b9f710228b0ffbe49a05750c4005ef59c21400da36222ca2c29668d433c3e275a7211cc8e07968af49733766d2bb1f07d23b0ffc12f25fac22814f9549775031be75c0d3cededf4e3d2683f8b39fe1a88d13412c4461369f035ef8197fe05735d11c1772ef2da2457fcdc90c650c2b03f29b1639b8b19401702fcd1b0aead9e97d95cca8a68d9512e63a3cb25411fdc00c31f81f334e786ccce63cb1803d222a167b8e8d1a6cb9dc6e95c522a8e147fb5f4c8cee8dbbc6825a77e637d781b211895de7c9e82b5bcafd41852250c2068440a265032dbb921d46e2828454af08b1f5c07e5e30e969dfa1e954b1390d3a9e0f19723d8eaed2d52de3a0f9193722f649c001b7837fb1e0c935c20a5345559e0ce8fe575b89a88afc7025f4563e202a4083b5c700b1da147df3927d5220818abe8586c97beed578145b12547841108b35ecfa7fae1d2cc868d6a8a4c922ccdcd21951ee91b537a193319371f21adf5cf89c202ac0a0bab15c8727c3cec67aa8952af1872145121f44be20763a7d7ed3f01d9001330c75594c5af72b02f636fecad0ba3475df5af4f026bb8ccc6ae0326ef903279f66bc46763f8243dbc87790d7a39eacef423c4104278c1329d23b3b97a27bb98ec82319f24db711bc3539631198cd0238123e9505c8ac09670e3cc3d4a573c17467e4770f5726162c1e91ec63a58d6fdd2b32e738303add2c51bbfa36daa66f260400c38f62f206b36f74a070b7e7e6f9bf762ae663f95f4c24d7b5768e2ecce7f82150711737e91f99289c83e30d6a4b22924acb26bb13e8aac31d1ada498e9d9ec12515f75d06a77a9b8131f04dbb6b1f80941de46fe040d43e2cc0693d3aea8c992def76dbd5c5407c39188596ed178a0ed4d99db7cd7b1b4fcc26b045e51a5ae7eecf187a13e597cd22b601fd046b33224785505bd5d4cd69caed041e9c9dd0932a0e0a1ff25431c2bbb70aa9b18ef6c9d044c07ceb8b5a7ef4c58c1a21ef56e5ff2b0214708c1caab6afa8ee9e721324fa4eabd9e5c9143a910be9b3f1b8f298218dff85b3c6d486f75ee7f7e063c5d9fd68f557a28081e8e265c11c9240fff4e758ca87cd00e05e52f6cc7b8af7b4878d4f5b7441c0ec13ce4f5f7e37514503cc1b92f03be5b4cf2d4e56262d79b87e9260eb2503a6e25131e015110c268ebe7bbc124c8d4fddfd2e4780cf36a19a530e7014685a36a88df8442dabb4d80aaca2291ed3642fda5eedc8a10fe2f116727255f5586db8d69c2c734ae2b8158484daba790c3994f28bbc8b7a167a72110452f7cee0ed0d5afcb0a08f4fb9752b55fd7845c0fe2800c10cd97496ef07f423aa440b4a79c9fd6102d21e9ebe56e70e680515c8127dbcb1e4fee79cea89810f8acf4283de0fdd01c0720b612e0a5a1383c26992f76692e4c35e33e8036a812883bd80aecb21053bbbef2651e35963771e647d3143422393930aeb8652984938a7c72183ed7c074df905708affed3841630fd45decb8e439dbbafcfd7daca655e30183a2a3df18e3e75234ceac5c5dc3f4f503c88a97ddd000a906ec7d1377f9b86dcc3805ebf6302c6e6c61e8759e0044cb1dea74820bbf71e9aabaef4221db6ac169c6892693ceeb1cf3f447eee37c6b31646857bf2a2eb59256480d129f7a11eb7b181f8cc1e5339a5d6b88e19dc4bfae4bc3dfc08e5559cabb36ab0606e336fe26470577d2466087988bf49a127b17578da4d13a7550335f5a714443768432702400d2e326fc0c4b9d5f8844a77b4be535750ec4627617ee76f623643f94b8169eb35dd15b6c12602a1dc322780c8739a7deb76d421c5240b2e080cbc5d992b7c520a8591f2f2256549eb1f570d8c98f18d5f300aaf80aae5bc6c04cd02bd71351f77f527f99b608409936bed4ff5edf0ee10a2ceb67ca5dcdc70c330f68e9aa7e87b4282e1d59b56b56946c062304e621390996adc001f44633372ed4a780b98a26cca0d9f599fca1804ed73d8adfd115b492e98c39472ac20f7a472b4f754d4e20fec7db06958b8e336049cfc874aa3c6fd85a685a905811fca4f255d969f6f951c72a1aeb6e031490083bdf92fdd0772a98f5ddbb25cc9a50fcaba93bbc2aeabbc7afbca6edc7daf0fd98bab3b221bb1c674e620a8eb2c83d196a523605b68b782edd1cb5878efb2ba1e5a61701ab776861293fdbc1e930f6e68cacf2fc72926b554ed16a2c6747adb5de07fd0e990a05bc3c615b81cc3e6cfec8ad7e2764a7dc8e992bc80fc010598729481b41a2f39eecbc3a68d919a4f960fefd1a6d4884b17f30055945546324c45253979ee8fa2eba5dc0de049bba95fb9846d5fe53bce6835ae3c65520b6463948fe4754782ef45ef45128cea0fb6cd8261c4023237c8da1fd8bf62c8bd7739e168252737b164480ba39aab755e47575fe661e23fe9e2f68deab9ab804a0b7a0f8c3b6f1ce038e56e8bd521d7b65097dd0a11aa9f798fb430e260cb7ad108b13a07fb3386a2a7b28d57bbaffa198fcdea6954f168afc8207320138752260f1a1d2c03a256d6580943b9ef6e567bfa94903955b5d0cc01e0a3a877c10751d98237e86f01a9c36d4f84bb1ccf3af93f6750228a3e74412c85ecf6ec34f6f716e012fa3b25b45a02f836316081a04ccdd290dd3aedcb5b36614db8094927f8c79d984a08e6e884c659ef2f70940c0e83f904927222c139ea5fa1513b4def59c9cfcaa83df8cb1102008094798083e440faa419f03d8f093d97098d434a5c7e9ac2a80f71c4bdf5f5cdc1bf9b5c7244489787293635dd4381de189a3b8471b6dcdf2fc30787e0606503ae23ed6fd4faeee04cab7dc24e9d0660a874fd74f62705fe13e96fc9a43dba8d651ce438d78adaefec076cca730b79e001eb6f4eca2c268acdd361d2ac0fce98d46c95edd911da2c3f187decb7da21dc05290c0f6a1873ffa7e24a49276ffd8ebb7cd5dadcee9c39f39bb0091f6ee601d9e98d953ec14061eb45770e1025b425e9b4a46e496d5f34d735074121215e5aeb41120883eb01573aa8144466890d25b38899496df0f0eb532b42dea806ceb21db9b227da1f9649007b884b6ed81218c95ebbb117de924a88d95d995a05f801bb01902cf9e87e9d5eb38dcda4b9faa84eb4772f37bcf95be5a43a325e5616a0f2b8023c345dfff43f9ab219089dcfba93d8632a48b4b9c407d3514c43e490acc08cd41aa0e5606067dbab31be4200570c3a12a6672f6b5f3c4e9265518d401d6d678c40056a6ff35d988d94d80588480728e19668f1ca501df36e185aa09a0293936fbe31c8fbeb878d221def863fe92b13882e529954ebb545dfff8c631cd98cc269a3050af8eccb35ee353f4d7c73c31767635541ece965cee1575d65b99f1b1dd2e19e46573c0cdc8ca12e564b5bc9da46d0e7c439eee2e31598c8e0130595c9dfc4c265946314b56e7e8d073610ef892b58679e9dfa37d0178c3c05395a28601fce6ec61d550ed688cf2b53e322458cdbb9893309b2b8fc5f50eaeb2f6ddbbb8cb6569acd1d16fc6bbaa9b9c5a4b18a39c352c494125f881baa6e87642be26e295115357d2b53e12a2efac4792b9ec704937853e3afea4698691bc966235584007e9325e31e4738c7b1045569072bb9d56ffceebc750e8e8b88a7550ff666d2fa2da7a9151c053b8aa6795a260fe84db706ddd88ed9ffc2a4893fe9e799963ba741d20d550b30928b7345da82398036d052ec74771c9096cf3d61a17e8db1fabb0b2fac8558269fb75fae6f9ad97f609ae7d1bf2555d95f71e8cb00fbbb26752963cf99ed11900da3c8fea8c4ea82d5e65576cbba2cf87877e3c501905a7b8cb85dd7e5d4158a2a25f14feb2ef474fe2ecdb3191e58c7be29d6ed0dff6136735d5e48eb0a390040223a5248edd09143ec113e0e1823763c22c6ef3a7a15375fd9ae9f5dec2f5a2c4c1752f1f2fe043eb4ef3ab74fe36da096945c19bc8b0df4aa6da72aa5e0e46e074cc54ebfcf6b1976c1253d63597195aa643fed1d8fac5c530062f9d85f2d45d8727e786b6f12e2cff8d0b31695fd6f633e1154b4c2f744623fbb4d9234216a756be1068dd686498ea28e7a1f1f4016f167fbb15294a331a59fafc620ff6af0200b6f9cba72fd0910be1faefa23ed855e73069961670b473faa6b1cdc4b2c2be5794c75e31edd9761a36e20156c168b1ca8435f1cb4137bd12c02f88c09054beb7632e0d880fe41dc12da60ccb9acac828f4b7269e9395ade55a9f53a4751ffed882ea96d86d6004b6cbd3bf5b7afb3ae1b9b57f563afc81b180ea520263d2b61aa721605b8bcb12bbd2b2092b61996ee0c31e04543c2bd49dc4930344808e664d497a59fca41b6b35efa55642875439bc4946337cd49e99d55dff4510734ab75d85ff87d551329f984de3e8f66cff725937eeb61f711556f0f7165810443d4fbc40da2ca9538540e15015857e1303315407b3894abbf4df2403b214abf7df7e1d32469ae1871c2fd3d65c7ca9515171c9c4c56d7d3fd82c69e96e829cca402486a9f1cb1ce717a6d64e70ba5bf05082163827f41cb18a4452b9f446c2473b7ad567dcace62a75aa0c6b9ee824758bd27724df4800705cdd36a4cf8a5e00891d58cda96e2390602228aeda269f21d728f074733234e21a0e4863e2b5291bde105617bbea74ceb1d617cb411a9ff58a8c0c0a374e03974537672a3fda6fb315b8ab29011cf59ec09d239f9e36881e410c9dc99cc2a25601e83a0588fe90af1aa6c24ab6e3f10fe2593b9e14c97b9766dd05090b25e4ea307bead403a592fb19302f28539fb8a0944d7703e30aacf33bc5dbdad6f311927d7d3b80ced41b299d3a3534aaff37bc2c168fd40bc6265e71d5705bd4c38bfadfd4e6c5c140d356c149aaa5bc51fbf4267818b1b725eea3a1663e116d4ade34800d9b081dae4dd46913d33c6c2c9f593c92e43e0e8e0fa0537f0038e4f34a3cddc1d232710e00dee52f560d2b3283cc45c03a14845ff6990e711eb86e6456755fab9e6ad1e1dd2caae4343cf6ca4e63d164d60f5485a89c90135630ac25618c4f720eeb473c7c727e94b5106af7a2632e7be731b4e386b67ff232e3ef837486c980668a7bc4aa9d2ba7391909d521a7641e1198bf3f2248d1fbc3fe419330d5f7c82f67284c7b75d9f19847fa7f904e2aa0cc100d1294e663f48c0afa7b1ee2d89e47811cf6ff483d95a9b81d2e75bcf52d37970903b26e863da8e31eeb5258efedf7f4b469ac734657d89d0da974b5b1590c790dd4ba391ba539232d8976ab1454555f7631c6c93387222ba7c5b6ca20ff46e29ee0b4aba3c667071b25af36207bde6380d27abe6d2ecab28adb8acbf02a05d805339495972f1e84aba2d32a1b756dbcc4c599915a5910e6057c21ca8019fd342fdd00fbfef357c20899d64d2f897b5c1dfc7cb98cbc92591c691a71c803d8054ba2d443fdc66722223294a5387872536bf947a154029e8e39c75a584b7d4f5a2b469f2304f067de2179efff539a1b818fc371863f60d89c16369c7ddeae676aeb03cdc98cce51b384dcc06484cba7e5d2d35e23a27474c587c93ecc2c09eeadbd11af37544d96a088a2de9c91bfcf8cc604cb2c33f492c0489d1d04d77d35d89683977eeee837948af481da1f3e1685a92bad9c46227e5aa70ca6ab3c235008586490cb28d6efe5495c2f8c94f521537289ccf5f0047a7fa01339c26ee7ab209996a1709092e8854d9211595729c41512b2f4a18a5712d49b47cfbd3ccad25a93770340f958e6e78b6d6ff2415a9299c23c3d736d89ebdb4480ef8b8d612bbdaafc76dddb57a354bb160e6a594aa30eaeb1136277acf5dd6ab865f71bba08df9ba5d05dcc350fd9d86888d08f07c325bd7c4b6feb8531a1c21992cc2bd346928df5b2affe72eee99493ea18d80f92a85a4c39f58ba6bc5287f8f5aa36c59ceef0feec7a80730ba581e4a573fb4a3e8f3f52914b2224b8c00e7e70310f760cfe4d001adb139c9aca70e90a5899b9e31940fb6a2e4f93b48cc46dc36187cefa26fb24ef5e7fbf7534703142e17f02540206da56c7eeda242ff468180e6d81c16bfc675867071cef4a7db21789a467c9ed3fdb7f39464ce4c4d603ae6b73e7ab4d529a311701d3201b58eff181acf6edc53618185eaeed6f9053bbfda7c3b0a6ee4a4e7cc4d7cbc9b77662aa7b54ce6568efe7c6665a0db27cb3c9f26012026416768180b739c33bd54df9e5a8b45d4e2a31bd368fe3e5d226de4d8bbdfc6fb70c3d4908ad2bf41c5b07e7c055bb7b59788a1d55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
