<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8fe0175d6e02ea8e60b7b7d2cacd899f7d6a09ad151f4934e487dabf15c88ce8710e1db7a0b0ee3967b93dbf32d2fe3181a88b1f508ee57fdcc7719f082e93590e1bc27784e9ce9150a75ea1902222c8387189e2e9ff15d633c877264132462fba705b525a13af8c8349591d8bc16aaed30e487cdfc857a131670ef2847bc5d192f6e5a6ecb1603b7e5dbbffbea46e73ee01495488287aed6ec988fbe7daa8822197cdafed281c3241f8ff41d9fd536d1319a6297e3223a55913eb7ce2c362221caa3c2d8a56eb09eabfade142129f662d6300d449ae3f6726ba022cb9056fcca0e5f779452e44e512fc5969222f9f8299fc7663e58b88e7e34cbf153a7de11831484379b0f094ca4efc3cae22b76fd7ccc9a0302da124ec35e4cfed6fc07ed87cbb9b290b02b2e73da764d3fb38fcf940a5b8956408a52a51167633502e17faed2c2b3246eff0f2188d7c538b229695230a42f5ffad4f5ee7df7b320bf5017acda0dc2d948a8a3afb4115b86a497f337e8a4657010b4c98366458235feb1a80850432c7c362fd78aa43b7306332cf34bca1f078873f580ae1a3725b09f7e478b11796a770c6a19fc1df925656d60b01e47456926d3292066451ac5b7e4868ab61ef451d05ca2a287aaedd3eed17870585f0c42ce06766755f5271c17c5b1136266d257a438d4f060a4bf7d3432bc8c0f9e06c24b0f2be74c7e3d963d7b1e4d92df306c12b98c4eaefb14c30f5b639c9f9e164ddfbda1a2f0d47146e1673a0579ac78b779c727f870021123350c503a4b8179d3b2d06a96b6a7e5520a8f4e4b52758702e76fd458839ce0cc544d7465c821eea2f4de9f11dbb9186c4d719a5ceceeed923ca1352b1226546d6d2f32d9d85ed28af2089517a59132b0b593a080072310f361971c0145dd6660d8053c9e374bd1081741599c6ba96f0395b08ffe83d596cd17705404300a41dfdaec72ea730b083e9989c335bdbc0d9a97c7a0b271de64a38e8de64b710838591574b89fbac25bff8f4cc7787dc8d1b0a78b1d9336872ccca8d899181dafe1a37e19bf63059f5a853f575daf32b530134d26e34f19043302886eeea4a50638fb547d6b3c9093ad8c579ae6cb068b3541fdece958571c7dde609d456d501cdef6e6122cdd1d35f25807b8489ce29a8ecdb18f1f53e8a68632f8662e42ceb37b703aa03f10b519255a6755285fe9d16a90fd77863d703ee249be11e017d907c858c322b86db2e1f07d5e79c61bd3f158f610432a87744ce9f7e3be22acc1e819925e06d6615cbe3bda2d1efe6f56d6130c3a8a8185709ed368647f7c4cf4c8a4fff31647c1f7ff1029653bf868248d4bc6e127b0b20dd546d96547464ea1437f53c4751deb3e95064a3d210740486f67572e305ae3089d26d6dab13c03ce8b84ff5a621aca474adfca7750943e6f2a12b96b26bf72d670b2f9e1a1c4d323eb63c6119cc825c7d7232bb4268b54817115d6ed1f44d45ba05a6f6aa8e5ece967c965e747f86c1806bf6411205ed7cb324b429cc137f23a57f8df7c6994e94df211f144c970b4ad13bf39f634ada6bc271c64aa2624222d9bdcd9bc8aa4e8d2d8c34d5d5fe67418af5f26a472580622e29824ef96fecc84f157e2020c26f55574532d6c7d924052afe2029079642e4d4c44dd52d50bf9c77cbfb9025a566181d56fe5b9dbf089483602a319cfe288981a03e4970ce004efeecb6b7fd67145ab2975946c7856ce615441198e8de272089da172d40da8f05df8ea8c3b52b365e9d905a14f8e4657cbf5bbb502b15199b49cba9da096e106774035c190dfaf578d8e7d12aa4812b700812b2fa6a49964e0e0563dc13fa5c21c34e971e693f0e624b17e5641aec69888b8322c8961ea7c0e3133b1ae1b5bfc9d189bb76edac53553c4b4a5207f446a93e02ddb6e503b55519f955f89491a3940548645ef1520c5dd229d3517683d04627138021a9fee87222369ede8d9b8c3a8080ccba22eb66d65a05a1f3d63846bd7dee218e4bc3bff1472d88dcac62c635573cd85176d214f644af6640983f83dc7599ae9c1a3522d84e5f5e1fda7d27236f2ef743b7d172d794b7012717ffc77e0d73d022ffc343d4bf05e1e1e5182c4e470494848d1023c139f1b6481fdd0e588e58648dc22d710c09b2fbd119412a1684be524f20b35fe1492c7ef1dfa4832db723b84f529cb0986c9e2d455f3607620b42fb34a31c4642305accb4bf0fe4a7712734b3bfbfc9aaa742fad0f60f72a5c0de33e0bcc54e696d2d14ce4837c087e9ef0dcbb4d8b7791e456e543a91bf56081f34e7a1bd9eaa09c8963479e30032f12b570338e6075fbc2b8b8cc976617abc1ce3f2c2068cbb818fcb60964ef418cb28d88ea17e3ad38040b7310d2378b74f6e55d5b6d751920d2c82a57a8bd706a0d76d2d68e777be33e9cff1b3c19236f12cd823d8437019d1a7d3fd832ed9314f18d0201c7adab4ee7db44770f8b965e28938b19c40becc14487d71919371406d1cba0a5b71d407d29e9537186148ba832f85b1a93c465594a870099be908c9cf92bb928419039a8ebef94b51a79126651ae828795a3ea473e713bfb3ae669f1c62bbad274c9f3fbe86b1aa01c96371f763d271957c0cb56549d311b597c94e330ae50977cf972ae2aa405ecd8e09a087b2a319e0a21c4bda824acf5729d51c346220504cb84295155ed92206a61c9d6019090eb69a49bb2a4eba4607f5573d10d4d79d7ee691065224fafcb0eba8baad7785d93d1a54b937de68970af6625ae23f7d4e0c5f996752ce26bcd2446440a4f3b17be627435d94e99143b03a0d513d75cc0f99d19bb3529833028330fc0603bd31017c5edf2251915160afcfb71e6937aaafd2d667196c0ca15ef5f1d24d2c2f0433420f86bd9420f6831aee03dcf222aacbc051ccb197d067f710ce50a6ab5ec26482455f56d8149c76c80957a944d36a58db64d02f2dfeab9b1b2950b155e49939f8244180e743806c017317d84426c3a763f85426392dd4db54d107ec8dccf65a69f5d8fe365776e7781f5889739eaac02c09e007e3b72e1d29a472d437115dd99bb935be5124eda87b0fa2846859b074a799c69d900b9dfdbd3e976b2f7aae1a2e427db0a6930e414f0c83c5909fedc67201560741726c407784c5f305c618469c0150af5a8f32d34777b989bf2b4fa1f3aa18652169963fdecf4365f63904dccab3c9339ed776548dc03015e6e9ae3f5be9fd47230746076ea352c6d4fa4bd85e6dd37450f1f491dd6e42eb4b907b3ab8284dabcd92a3975ab3f39997151e4e3aa1fb459b4c6e505c139af67381801c8117aeb3a830f361087c590084ef163af935b853122ed323f16c774c2d175961b07bed111f0e7483a9b2655e2be1efc75cbf35aea28dcb5978f5dfccf35cd22cdf3b37895004fb2f6a55e42443a0ec8dd63d639692de00d03d88ef3b95f5221b4f6ff18aca37be23f132ad465ba22fca0fb38221815cd391cf6625c6d778870e900f17668a98c1082b6eff169636df25cc04f5da068529624315da6efd93fde41d927b847196eb72df14dace0c5ed558f4afb90c1267f57a45b75aca406893fa24f01cc29c62c8fd32a0641a155d49f7bea3aa9abde8caddcdbb612a1a21c9bc1e4aaaf91aa7be69a93c856633172f29bf472ee23734a265dc2bc3c67816d5f5062ea5de23cc7d1974c131614388926896d89b38daa52c65d446846a75628648fbee9ac787862014651495771ff709131d897bf165f26faf794a207ccd31800f39d6f903301d30dd16cc50b5c90c1addeabd2a735f407f16d383ec327bb6a89bf9ff190493ca7a98c045e17d68a9cc5b4ae24e3c71829116abce2eaae2b3f2015090c2edd9a691aadd467a3213a9079481e2ded7c80f38023e537eca30b212f7b7f7a5d22a0bc71bbcf688dc14b5b932a86331610292c2d633ad5d943000550d5dd1014681de610522f207e7bb413838af55e7fbb5e677dce6e462ce84233cbdc32508384cf5ff08dab0e32f8daad833e147e2b7dd7862a742965e4921eae0d79f54474bba60d87c5e03e0a51148bbe8a759fb59180327373d10d92b36f5d8ff41a67ac98672ef8d84f1d8d2a18f1133f66f28cefb949d3c29c29fe8f3f6fba21b27e94462dc2fb594fa93ac3053629874e291a385ef8aacbd161609e8b45709e8e6d0fe38e1ea70643e9c8ba372b3235cbfc0e1685ec31172b0abdec248c5c363eb18955a78e63041bf25061e379e57489992b8cd47859cba6b248b0f1d8267e8d25dc2880faa2550a6e5e44bb72d2e95bd547e56bdf67e0de4d042b03fdb32b86535fe3aee63fc36a1a9af035cd1ee35f3060ee6ae96cbd31d637a6a2c95bd739ba447b8225164bcb4287194994a154785701fab8f751ff7989fcbc728d77637061f774346922e0412a2959b44924c2c426baaf684e4e4ec603039d74c5cdb02ebc5f9b8e22f99001bf9f0455c23cc90ad6d815951dde47ba184e42162b027a20797fd3619e281f5f6aa4c67ca47b33ca0428d02252a4e7be8659c2da43a0ca81905379a265ccab1506a9361272afdda8ccb40084dbbee9c0e7c9793ff82bd4d141e715c3b307286f3545447fd0482192e278d8b7bdd818d6be7a98a3c214bb437af69f14a32efaf801dadbc1b805c2a974e708a178d64617319804cebd7c5d01abffa43a410132e3c46e615e8ebefefb1b6337e0b45d6473fd91a5cd1fd1a8d4af389e4d9b402df82ab1d3de2e896b5263b700ad0d756e22c9ed979e3cb6cc3a13a540ffd97441542bb3aaa56225df4003fdfc8e198079e5fda72442bc0fc63a7d7569bd31e141dd31411901ea17b0506253e3df9519ef6317dfcb642c180da7e2b003d758ff81e851fafb18c9c9ba1d72e6c11a84514a9f34b3620e37d5080c57a08d3bbe8a5128f2ea763476f2396d808bc7ee979ae29cd3c31ec50b69b1960ee38fd60f839ffee65ea1b5c5482076640963b6cd6d57e84b7e5fcbc4da04b56f1c46b72f64273d61c91380dca6fcee953797b149e6514acc3a33324acc15a2b54c96b781f587c767ecbd2b52a757b1d6c3da2c891c9224cc5551ecfa73632afcd6073f7a8a9ee0fd8e61c723fe9ec1943cc011178a1f7fdbdf3b1eaa342af7e6885cff3081419f84614847f718c6ebe6807183755b73e24954e09bb9b42e8bf1a71ed25c9433d2fc26658049d9b9af616a83dbb7cda9773fec15f097be4a49e26b044bb67e3131b005f27f7eb3d426487fbb3465ecfef63c9fdc52d080d90500a9410d5cfec15f919855943aa40653e8820571bf3066ca74fb4ddb155dfb05f4c88123e90e98f37d4d2ed32f33b7c30410dffa0b0415b85c05166c8a63039d262c8435226598a778bf9712d34878773f6ba3278b61952fdfed291f734277bbed711acb40354da7e584c9c949bd92daaf06612596f21a1b929a303af8aad28c1d86fad6a4d5f70dd83cc9fb623bb79b32d238b1b466a1b9273fe5ca817c33244262cb553d18647b2577e97b84b1a551d9233ec2a019b592186ea79409c6d06196dce6ccafd23833940f51ccb90609d4c7e758bb37a9e6dc63ff411cbd380f04c6044ff4d6260bc6c0180bbc6c44c92ed715206c50d87de966cf588bdd37e6563d554c35a7780f4b298597971154bfbe973c9cd8d029aa958ff21e98a9cc346d23015a9d4190dfaca40b699e03b2d6c385fbffd24296105ec8472ca450f3d119a98ce9998ee10ce2fad9cfda9a2f0856af57b21949877aebace0a16a1d144b14440ec68891e9352a3e1a2dcc57986f3140a1702d4b98a367b8053ddfbbae024d2d7b4b7312d03ac3b534374b48f94bf4b973aaf7d4a0c5bcb9b0a80180ca087cbafea0a1b112a2069c511fd153af6306954afcd2df9a5bf31962c7db6bd45c8591f73b1abd1b9a0961a45e9b2a43e4dea9e13915acf7e8689a7b4dff92acef84542cefa6ea55b038f3b0d19aaa6fe07c0c3c61721556892472c311e433a36a3bf4b1dfb290fa741c8966662a50d52ee2332bef605773170c0ccf53411cfd72412f33d6848dd958f04b20516143bbddbc5a3c0950927cc13b9de7b6a04f944d4a79efa654a493ba0c8d4a220575e8b3f01d6a9810b2f95014c3763a69a2ad984bf860216e924e1b4a7f19684cdbe28795f3421b344277b1268680194b9347b04557d2d446c7685bbdf5a7ea2f39a27d566b5f3ebe197c61d13533685989deb8f87a1a76c338983579829e136dcc648f630d1c5072cfb061d55aac747893369215f249221069d5a6c8bef517c9e76904184bf1a1bc5edbe33f84bb988a1f4adcc701641b910aa68ab87ba3b9830b0c9a014978d6e31ed82221ca3b5801d3cc751a797a416a2655834c7a3290ede640e2cfe47d18e639760c2da4222493b942b0e262b54af1884ef0bc8147aa7dfe6d5eab8d62e45bd7b7b9f51c74ed78459aa587583dd8d337d12b8c3aec8e3de01d1cf008ca2618d0e7a5f918101b078382bdc6c5a63e28a268de6374a7b5a3912d949cba58bc7ecbd2e4ea3d74b24846960123b564f9233267a0730e753acd210f494eda5a0770329719b5aa9a73ef49423677454ad8c41194c3ed88be56c183b21dade8ca2be74a31c67afec3fe6771c348aa0643c740713e73d64d201d152bfdb3941a965b96bd045b8fb51f31a7fabbb57dff9dc4fa986142f02bf7aea49d2241db5a7c66d32e650feef6d6ce12e6ce688b5b5fe74fa20ded67422bc0572c17fe23eed5ab5957eafbc3b5ad2a3e076c721fcda775b5bd529504bb5d1e9207d215b0b38ecba5ecb45aa9934d8f9972bddee03a0e466d624b3f506c775eeb5a32acae62a5dc36cc4b31eff3d0d4bf2a07f0fe97a06d7c52c3b220382be22d4913db54248377d3f4478d81733151d67ad2e8e086eabbd71a3a43b46f366f7b38a1bf6b354760fa74c243ef967dfc20b2d12231ad6476e1ac63c726cd8acfe4ba38c8df111aa962c4974f85e4cd9f851339a115bcc07ca88418d5237561480671fb5bc5f13a780096195d6861187f5f8639c55253a471fb5376a48899d570a3f1dad98502b3e1d0d0c8007dc27479981fe7659c6bccf0b6fa457a6ea82aea25f281f47464f66b8f703fcd8f4b98f2f113b1fca7b8db48f7cffba7bea49ccb0e655b1c28885243011ac5b416d5330f3b100484c58c3bf023cd94a617aa82f1858330ff8b6138bb3fe4faa5a8f1c866dfaf3a59ea37df059cb049f5727d1b66d38d8a339d4f71606080285799e294bd119535a5ceeaf8df25ed25e24862e4f5bb70beb932b3e4c218c49a8b0d34553ae3e2a868c28e07d9af48163e188f2a07f8e27e0dd46b4a1b80161a227d03d02e551d4b742a9411a504a1058a1b2125f72786aa864ddc40b49a222f55f5e45ab04fd288a94e209a511afd107377d7940443214912308b8972f850660e015d58736e9796662b41136c952001a8c23ccd29190abf2b2a8e7c850c61ea9dc28c6dc86308515f4687dd6c3ddebe800ed94a1d229ed6ca1926c3be2e5477de9dd67d37bb8ac00ee9598723ffb547e824e0f01dc436d1759194def4dbbda0125cd90da2b63ee0b69e95f0336b7d14e6f9f022899eaa384fa12b5c8cc13a63cb526ff02b9e18b098e4f8758a1284d5b26b7514402d9d66c128e4b57b606c959b1a1dc86806af37112b31d3cd2e47bd20e8c5ea34411e0e89da512545ed64fda13f646b7abbaca14353996dad12e1384314680ea7598e0df33a5828ac9cd0feb2529e650bee9225c977d685edb7b43552a70a1c4a7c1ad31655c4db174cfc480dc968c514abd90b2f2f5cd99c3e7e08ce8c2252ad61f746a7a3489b598804a5b5b93e0ab052c6b5bba3e0bb493764dc9115b3f8b2c21fa3f039a088d66c6e4607ce047ae7eca41a2bdcbf0a74eabcb3a3a0cef5d7af4e8844745113f31833610f8a0b1315bf9b2371911919985d926546d3613f8ac7b174ce4b8396adbe0e9f5e1364882f60b1b165a00b133656158c036b774e2a4aa3059c0065021166b4fdaf9909fea28a1be2be9f3859daf22356c435ddd33f69cfe05018b127fc20a3e6be6a2766441366f0b3a614a99bd978a1cb1b74c0f5799421a022ab61d7cd4da2cc66a10d0714e8ab0b9b0b301d58a69b56cbba477cc3b3e7563e3540a56dd34151196ef93d1e791158b539934f69bdda9cd926e366d2d8bcf3f28e7bb725c6a7bf60b3f94b2fba4cda41f1c7cd9cbb579b355b2e02162bc1786fec94f7e8e0a32b7e663136dcabdfbd7755aa1447d723212484a1320505d2f4d88fd2b8c88389f8357a0969bac295c0eab1728567a6bd4d679f4be0c13b810db16ed7f5475abc17b034f7fc6494b1d092e52b4606c2d825197b4c9584349e0ad792e79044b9d8d34f05262061cc6eb68c49a04bbba3cf4d10faa4acb9706b5ad2c8d8b93df4e78404a51755f2a8be79947b377f1c75710a95c89326e1fdfc39ab95de49b1ae0780e8c277a72705b1232b53302513cf9c99c94510fb636b77f110c13a03ea35634f2aa9a7c8216bba81e8d6838ed3712460a3843ad743c1d3a162bac4d2c76c49c5b3ba9a1ddad106a14a4ba8437a7d47af04ddcf56dc044f9128fb09c749b5713e263bbf25ac6041010ee761502cc534bed316e3322dc00322d0700aa90da7b56bbdee92987d3cdf40cd2694c09ef1ecfab6647a388188ca77a77b66303b34d86c0cebc063fffdb767dc09bc37171378c2addb8ae4b6a91bfa56214208f3c9ea1bcc51ffb58fd17bb04956a6f6507a2cac76d5935d2b32f47b519ec0a86f2fc6534c98970e427224e97c1bfbf310bcc8ab6226a4b9d1d1cd739aed874ac38cfcf9a23a5417c32e6ef4f10a3c9e28904526079f3f06fe7d65f7800a4b14a3dff22483fa0216d82af116dba69130cd153547971be4b5ca333865edeabcdea84f25c6eb9d2b6767a39aad6660496a4268de5b15e60b1ea6dc545f27f746315a2f236cc3e7a940b40d308e3193178f8f8442a8cf45b7e9cb0fc2f1323a43c7871e4849cfbdc015691ea2cc84fc536aa6de87914753bf04eb9c90775142f9cee626c6bad3e5d0eb0c0ced923ac3cb79e64aea9defda0f25df1e4111f558ab5b7c28934c75d30b38c066bee64869be73aa7153296f8a52b78ebfad055d4b06d6e561181f38a6cfbd83a38077e22e493b1783743064f78d768f28091a3c3941d7b720308598b994cb5b875e5da9750fa736efe14e642a18d4c612ad2693c0c60db6c27b7e45b2b75fbd432a74da8915593004d01b2a445264a6d73039037bff73bfd90f24e951cc9301792ea4f1edae55cda3f92dde388a46e8921105c6779f664983d010c9378a376a283c1646eeff4069f6970ab4c5f1bc6316cfa72abe9aef49144ea0be58ee98823119ba3f72af4c9e1384893a6e3150eac4ead4a5667e916fa9dc7120df587d89c5251c84094506436d940b26e6a34150532737221a301a5695fd593289c45a056f0eabcecf3a8d3d62d004c0346d6b1a576f546024ac3f036ef3abd93a98fbfb3bbb251934c771afaf9d817a46a28f39a44f96bc7c118f1d2335acd46d684d4b130bca9aa40aad8a28ab730411bf39e15f1bc5f9421c370cf167ea4dcc5f356116ddf636cf4b33fa7f17bc2e6622d4d4d36a6c4554f99b6ded36e1eecca4496cb969dc92f34d08b7636e0b27a965ae2fe53f1c54d3af3bfd73d8b3b07fe382c06167b0f5fa95208ce2684883dbcbaf6f7713288665ab51b0a1de071678e9af4c3ddc942599a851f65b375971543d80869bc035bd1fb5833bda6ab5a0dd0423e47259b0f8f8516302185a09944206f3ea2697637ec00d0c04ed5ae185b68eba03368aea3278c063d33f96b5e61001f0e01e24e2d1ea909f23f926f1c70d1df9afc863c45e69f049ca3fa22caa0de060250e739f5c50117c27bc0c6bfd8e4bed7d05dec2149c9e4ef141607514a2ab44cc9bcfe77314610a5962b0b1c98a28e1b98773f66bc63298df38c5fba842fd6ba216c769fe2fb43dbc51a8b811a5fd5027e04986e04b4e73cd518cbdf790109506e1cee681b45a171a73d147f19d36044997e6a4369adeb15d90409874af8213fae525afb9c62b947e057d4931ed13cd3b9d57b29ef0c6fb5be34953c1d68b44dd4ef5409bbb5cf4744c80f60f32ccca810f658c852708cd0af7da0e36ba8025c5fbaf7bbcb0e86a4f549eae32232562cd15e3355a4761ed6464f69acdcee42f65b12cced88c1b4d10187f58ac3f72e3a80061a31012ccaed32c2b047121a5111e999a2a691fd5ed279636e500bc1c991d7f3ce376de9d1695b36461b6fb89f2cbf6af050ad555335c8de26269f05b0d3cdbf477ae044f889b9e88bbc9ef5f73d6e31220330826960e628278d84075884ed9f6985664f44c27320a3155f87d34212f5acf244d074033a9aa43e0695b18d962ffbc4c09b54f2b9925ae0d188d0a4a01046f7dee658ecc7315e50616c349015f6b6e2e7df786b5c7ccf08061a61d7fb69db588ba59e3761d603897f1e661ebb6d05f58280bd64d14ea7501083ce16337ff6ced53a4e1a1038d59a1409cad0973dc38ad0a1df6a58cd7053a58900ace29125055b0f6cb986ad1822196fc78620d8dcd1e5a2abf938624e635cf420d62724f1d1ef17c680149a56487f1c3033f7616919384a7ed1142ba8a33b8a98890d816a898aa79e3d1297c9d82fe613e17d42c20a5d42c6eff60a6fcfcbab3d632784ccded01a253b84aec603a9364c42b0361f5147be170a26eaef43b8e0e6a3d6041d2e4bb3b708fed690f630a84b4d330aa34046f5434415ad3cab422a69c7526883c37e01169e56bd381a47dffdaef4063160d84aa989c03e66b0e3f95f898222a730c34deef542609cfb206d75feb0d310f1c35fae67d361b4ce085a74bf998dc006071b179c42633f1358ed4a8f3e874430655f8667a5bfdfac196d41f3e279fadd6fe3e8a900e34320b770e03e258a03bcaa689b3bf46c2a79bd740e3c3131db5d2c8c6a347e4481ead3bfc6729d73156652b3d636982798c6721d45583df8fea1e7da23e49b302b4101212737e8a836c946d8447f4900aa6a80ed25e5e938e0681b537eca28411a69cb05da7a7d6b4cfa4d5ff924cf0ddcbf817399071a959b3d446a00dffe860ee19fd7040e843c34047764d821a42c6a0a862d52459388b69451f9429e2850da5e77f5985cdea7093f204b5c0ae65516cc5516cc53adc5884375366d13603b9d49a3c5608debb4a2ce198ac393007c4d9373097de78145edeec0e6a1848f081e299048f69ff7c6c8bd2106409da31d5d1d1e3f0935bd633f1296ba77b752137cbf7e5fe37129ad486da1d1776669e0a318102fc33408908c50131d295646d61c4ac9a1b985d0e2a8c436d81fa412ce926e91d817f43f6a951e502e503b5ab856681794d8ac027b11b6777f9ed26d2f3f8a414fc971aa17eb6c355b815a9639c60e85c48e0669768ed46b0efcfeb217b05b75c984e369be89978f4ca27a0a707a2fd0c62dc795e5192cdf6d8e0e84eaca36dfd70e5da29a8396cb7ad873ee9b324bd5caf76b337c95fee088a1e724fd93a3f56ce87467dfb3ef4dd7507d1dc8c7dd4738c1c07a2db02b275214603e4070d1d849d933a87838392c530ea7fb62221b8447e7043e83956e639c66c9fc21d54a026b52ca78b14b5e5f3474a90655d7a10e710924cb03e512e033c9a3ed5ece8b6a9ae5c306c2ca86b5d0d31ce233f85dd84fcb70b715ace537a5a274bf7e46f12db3eb3dfffeb7fd21c1fe371752321ccd01aa8ef578d970cba7e6c4a35b71c6fdc12b3849e62ddf2eb959d7ca9167df9146055f2dae8e8acd7033769b22609e8ae9233955c205c6f6e23dfcfd9f80a1dcb219174ddf7667746d17103ccafe6d39c0c8ec55d32049e98d0179f4e96b4ff9500d0df0f0c9df692a2f8f87190474afe776bf3b7812cb3197051e0b869ffd642a25c23676cb47a3657d25900fd8ec22b37253689d635570d292bf1632927525e2921d9cf7ee44e7e2cfa980f67cf120e3a322b3c1433f99fcdab574ec89ec340c8a9b3ccf88054eee0e2dcfdd67b5e35f161770afa6ef004177592cac8baed681dbbe3ce865c641792aa839a03af89fdbd295f1b36d873538b4cfa0b4bd3919df18b87ac06859e47d43a52c0510c0224e734170be65754323754b3b0ee490eefd5a9875ac88e7f6f6d37bc5db58fc894f5f60aa85d8656db2b6101b5d1f93aa0db36994fadb2caeee8a17a0fdf72c5f5c9075dc792069a312cd8cca9011ae77f4f80ea1003961fa8d704e6da2ecc093580e68e08b0ca481ed0141583c259dc2b9fa64a253107704edc1adb227963b9c75eb154a8cd14015a401056b3dba557136c9a7fa9ae5a1d5c1fddf630d2c55257b856cc3cd3451fd0dcb4ae2a18a9f66a998892a5c5fea4516b13441c58cb4219d2f6de284c39080ec63d72a878f74e639beecc5a383cd40c886acccce3ca6f93e2380e03b9fca2a64e66fcf1983a7e4ea1a78ad06aab171fdc0613819278e936287fd03195ca0b4bc53f860d4fb8d402d536cf48cbd102fc8f058579bd82c7592f5dfc6cbaf9e6ace751662655ae96003a9d0fe18f6d17cf81a206ac0c9631913610bc8287678c853c5062910e9dff9ff0e6bbb0834f0e9dca36bb8af49d3c3afb8fbf147ee92f83308ce5bc969edf68cce3b1bb33f1ed6dbb3f0cf7a90abbad2063cbedf8cf29bb356f11994bcf50fa21b49ad0846dcd4d09bc1c2b9b01ec6549a7cde1007c3c993857fa322eb0a44b5cf66b7c12108502d11578ac3217ecf97a1711b9cc63c8a20bea74defccc4377a82274043687bdbdf3c219cc2720c00f2846c5ab38d488e75585d061063684063642b21b16184bcac574e0f085778aa14928bd87309bf41713fe6598179618ddf6eddd9a8438b4aa8982dbfd719a0946d557969101833657d076eaf7ae5362af314842df17082c62698d30067d942de81b86cc5d3e01835ed74d8cccc3509a81f239762241f5b5ab1876f165861873fedf0acfe9b5daedbc6929588075a80161f7182b8be19e1855937d23e0037c1cf6276440c7cfca04bf4a50e010e587b7667e956b761954d820d1f3bd4d40254b3c1a2c9a0bede60876cc53bc240fc869c0dbb267a4f24bc6f6714ca21d493465d7aecc2b5439033a3e637a4ead564de8942c6e5a9326695ac2bb5ec63077cf1c83001f8110ea6446002eb67f7e80f6cc171dd36511a5faf4631182e2ac47d88b7639602c7af7ed18342d3d57d2ffdf17beb4b627380f27ff84eb83964df929e4338a6859c77a15392584b9c8356af45ea3952f7c605cd1a87f58bc70b9de4a902b26a78a5478e4dd1e674331934493e04efeaa8b117b2dfc7b6b5f0e463cfdfb9bc0686e44f7af44616108c92472491276c11212dc9fe9865b172de1dca7812929b6f08f9a9ec5d6ad3f608e8df5dc52be587101dd6771503523cea9ef332dc542ece67f8feb50e8e811e35806062eefd1c262392997c0a5ee1a0e6c8fe94d6a43526ca402a9013d400e495078ac0eeb01c58104959d9aad3f09502431e3b0b15ddf09dff027ae614adcce2ba5ceba2899b3fd99695c2d6d242b6b76a9bd39d5c2c250688b09b03532f4c578d38c2e8c37702d5031e07c20da21080d54ef9f7ff729fbd4dfb3be847c9834cf42d62435240ef69ea832db59e35a0787549f2184ec0049f283f7024a63cc38317cd315cdad491f889f8b8f47d6e3a6145752ef2579052b8514e1a99ff4d577e95d345ef5ed2e00ca51d37c4582b6107c31634cace163940b2c135f1f82c8de34eb376da5d9958d3fb9824d32c8ea8048493977b3ceb0a31a2e185db2d27da971cfde0d9b0aec0de7356b456a69889e30dc89ef77d2b753ccdb5b02d47428afab0d4cc3c8a19f60fd3a8fcd8157d4d6d2e8289e621efadd1ebed05965fa6779e98d8a813ab5232901596bacf2a1969029d2ea7f723ba5163cdf44f9a07d7e48e92cacf11dab03ccd6fba98a6b8a6cabce19a603ee1f6a2d9dbd19e6d5573fb364ada903085f7768ac2a27e3ccf024c76cc6e5c941f33e812ac92c31de96e1f2a114e54c5a8b28e19b3e759c9ff631b6329f33db6d7e804eecdc948b5d899db0c931e7ae5b024037c1ac0ba0a9942339eaa69b3d3fce741b660dd722deb7cdf06a09c67cf9d20c60f61fcfe59e116c38f70d5036da8e32076c313d8ef6a5d2e550083cfbd924f6c1c6a6b65048584896acb9acc212a636053618187aa36f56e393853bccfcf9cf3a7d1629b87da999320a60aa6d55026d3dbebe4fb8194e4be5e78696f58ac7ea954f82c4209ca98746c76e164d300de4142d45ba261789cb4cd3e736508b06fbd3a573ff93ccfde3371e47b52d2e9683a037250826413a0edcc529153c3c859d324bec9fd5ad5b177c86bd360b7160d6705d29dd21c0c8aba24243c1966968c0f649e3a251fb20407c5fa7dbd0301cfcfff9ecb618e6f5d807712557ee30481492b3bcc8f39d477d89659cf27d6db69a76581ad44494083d7d296b21ff69e21065a67d55239b546d8d14d2f1f2fc3030a933f4277efe666dff0552547f60f7ab9d6b99e0b9fa9278b18b7399610f5fee82ab26cd185455b7fe0e2c87c9063767859b40804fb022f9a2b0376b80490c97cc1be5a1b7e68b1294a5b8f72fb16d4743b81c9087e58aae9c1f6b3e71914be62fbc33c6b6acef65049094183aa18d056aca16b9c0c0d70a1cb6cea2ca628ea1008e1339d97453829f4055045e4b404d82caf9fc8e7387edb0a33c664ca8882e80d02e8a5ab38e347a68f9c4da9b5c1bee32a883e93c73f93c679ad932af368fb4196e8b78dccffca87e06cb83c1414fb5aa7420027210a0eb011298c19902b6730050fece06c108b0e6032b3ba4ef1415563ccfb904885a8a5d1900304fbcf798a99bcfd5aa1a84a5c8b71c2ef987cc4c114463a029ccf69aa14ef66f477639f9fb35668d3eeff429fb72265eccfabffe72ba4650cb80fc803e85061accf5c57577702b75b21864ab94d8e2d513e11a8515b22083d1e56138c78e2c3b3841c12a001d1859fe130a035205ab74242a294f7e0d606d13baa6e15d29547a96410e76496f1b25cde9ddaeee85b23de39d82faba85bd3b8f4a85fca425137f24a851268a07f8c907be1c89f797447667160cbb3318391762ed0a5d8922cb3db8a13ee8ed94cac008890356eb5ea12038750f5643310d4190830397957db50a1f245fea2ea693007822fed3f2ac6c4c0da45b219b386f5abb1cf51bb9d0ac64ba8ee523529b89a8dca539892504e014ba6a03065e68e5379923e6c2c1c2b05c90bfeca0bbd2088eb7f8ba2628ce50c888f4afaaf83d75f2b3e463c478f6d1f6d5ef96cee90da2aaa26ebd0a10b2f1d2a6585b4a2201f0f52a8ef0f41dec1c95105514c623869c0b2fa16a29e3f6b02989d85bb5d93695a7f20f20c259a9ded6ba33763fda558478e25c78eb1aab08bc9a6379259910c48a3a4142febfe4993db6dd62cf43541468f9caa1ec6ecfa22cd8653e5700770345478392f1274473625354d8f430b84936291b1a0c9fbf7ed262640fec8d73a2832d5f542d9f2f03f9e2560b85863366e58e59541dffe5dfc78335369aafc37a0415d44c6c3b429c3cd47df6cc7fd486a3d96584b01ce04fe8da711e2a13b613b0f018fa682350648fecb7d51f900ce364a2e8ffeffa586c5907d026ef884571ef39cbf2a597df3a6e20826c165767f8732cb7fc6335f44a863b468b581827d7e159113c47894558c884b3692e0648d17cdfa7205e04cc185c3b0aafef56797418e5b7f65249c24fe6120c658c0b5cbcda99dbefb283a2727ae380fc8c0b17eab67a5ad080cb772154ef5430f238c6cb24eed303db4248a2952b3b0e012de2d4d24dbf63d6755b6f0406705e74ad72fd221a49a34426b644003cd970b4da0b02579433a6e61288cfd6db68378ecf6ad846c831c9d75bbe4718b8e1f0b2a59be1fbe9e927398460c9750fcab821f04ae5b5311868bf255acc3ff4dde2b67b1c805849351e69a83f73f0303552f5850c01ee307927738756571ad1970dc84740c5765a4247dd1390f612a51796719317e146d178b4a9a0a2a22ef6d046ab625c4e363f4fbe16cbb4fb3d8df9a478935cf7f77acfd38c87d4180b67e89a5366fee2bde38a645b705413854775a69ddc773626309e77a0382aedb64be3b2258061aec5847344103008fc5a93611d9b16268153d7d37860ea6f9f11dd2c7738a74ae5e112badb23ec676e951b03d8f0049c94f5833adc5b79a6990e874f18fb26482ae633b8b6a8852c9cc98c163b220b89c4e3917ef7b4e15287171406eb51d9a46d1974fbae504e363087f8d9229ef2dde60fe48f3fadbb5ce246f1b4628b1e64b18219d43ff4380285a95aaee63fd1051649b4c45629f09294da321afe7f1546a63905506e2fb0c44cb7efe8202226b18cf04b473ae95a219290bb566ffa15c62a07e0ce4c7e28ebd4f61290811405987ef58003fe73d38db0804577d1451c9aaad016e34486cbf8f071de5ebc8e903a71c2ac1d7368eda36565e330cbc7f1097ffd7dbbc289edadd93139e3db2e43f18c6c1c83369dcbd309f82d605e0572d4539cc37cc9c9a1ae98ad1f0aaf47f398354134c0b28e3b3b602ff4bbf522d2262757d98a7f1d28af75146b92b0d514c7385f334b60302738d3869f58a8dc3bc08c0b0da987e99eea9904ef735e5b89ebdf650cca7c02587e1ed9acdefff7a9e05966cf3b892fe82c8042ca46507b26fcc9fcc4e1012190bacd80b1ffcf7512609db1c3ec931558dcab61153f61d72ec4c47d4c4dcd4f0a25751792bab8d1355eb079a84b5bb9dbbb4e32ee7ef44e0c379dc3eff2746038c93d0a2ecc35d495f62c5cc5a15cf71a5f377080f0395d994066fe0747f46dc8be3ce00347f2d6edb5938aaf4ddcbd37a767d7b6ab54cc83b3ea10be89a36751a45c285057f109f12d5c5dd9b6f98621295297e8280e22a2e079006e9e9aea384daaac6c4359aed88940ba52c578f9d4cf041dde0e71ab16a76a9822f062301c5c9cb37ae0d65ac3c4bfff7af8cfd124422194a969e9bd29fd46cb49f7295fa983ae322ce04e935407b134fb9b847eadabbdbfdd12051b6c5a2ccfe5ae107c4d8fcd9bedd36c2b820fec58103366f2c089b5e3ac7f7eb38b9e8813f72062be0c5a1841608bd6810e9eedca2fbfd0a01b734c40c6cf41c88df1234bd6d5582ebcf06ed447f2fb5b29a6c5298db9cc0d3806470c8fd72ce01a80b2e7420b20b549856d088e89110882bd9128675e804b4731b333b001661ef1d7bdf261288984081d3ffac7ee72992dd1dbc42a4235071c943385060a6a7918a0ff632613c69fa089d77194306583fc3eea575f77196c3d5a7cd051055042b7697c2e4478f125e6072056a0fb6728baa48abf7afe2e35b0e2bafe615c54b62ae65ac36d9934103616d9ba6dcde05ce11b0867e8f06ad05c0f65e5e64080de2dd3b5c49a5c81ca80730a1e71c78c08799850eb8d44d98aa662e7c5646022aa0364cbc6e12505761dae6446cbb0ffd2bd529e2bc63c17de58d5182c5350ffa0f2696afdfef0b4463c86b0d9ff4c40146797b227425cbb4f7b0221c2fe382770e55d5a8e625f977d0f8525cd41b63566a0b6b973332566649b4ac7c2454c2f4d7f1c51949d90cb59b15bf51a617cd4b6d3d8e6bb1b59f24b9d88f054d96ede18228e96b76079a0b4c7ca02e0a193a29ad2562931370b89a2b82ec3c6447200f603fb6a517ce4970537c0936f369fcc8a78467de2e1e41ae4e69c48666723bf7bf44efecbd8d82b9c798ce9ef09cc26a37c785e4979157c7eda85a44d70ba63c3293e42e88b0cac2c24d028ea53e3157b6ccbb57893af55db73e0db805409807aa227ae961c347a6d1dac3a317fc854b2178e49bc614108860f5fa75cd00b47da3694ab6b94caca25c7580dc5ade78d48a2975e3a73b833929014c62100bcb3ba464277800e02b0f60e1c8a69481682a8ce799f57486aba8a4825c57741cfba5db5affa31993c76435aa8c630665eb96812ff99b9070095fb2b7d647c41ea7f50e46b86215ff2a27a1bf6a3b085ec21bae2809f95035033fc47aca5c463b3079a452658f13ef20a213281de6e17e983539abb765ced811ae2ea2d56dca7f00c7b0e7d0381d84c142c38a72d69e6b6fedc325c3bbd27ee9a3cd14a128709b80fd21f614aad506c2f51276494c4b6b841ef18df150c8ae216ba75c10f0020838c0df2c2f844ef98a20dbf44612ddd53b305bcaf8f1f74bdba8ee63469b7fa6e8113592d8f13747e040db3bb2fa928a0472144139892e1eb9fa0b6acdb31eca4f23aa6335012535b459e373f4fb0f8ebb068fb0c02cb25a329556e36c9b4450df102dec9bb57fafa29f1050fafd94bba5aa4687c77325b877030f64b76eebd2a11ba4a1d873eabcca66ace7e1b3facdd5c7d0fb612bc486bee9b31e158a81e197aba759fed04bc511b9aef3db6693c2659a4a65a1f9653266a39c0a0fa08d76568c86f208faf6a8633b630fe5d0d4e6e61cea43628101b376a1c191f055134c4488b16d0bf565024070d730cb8b58b98fa793fa79edf7680340aaacc93dc9c0fd2967a377226c0f8eb4abe3be68c6410638f09566153a3555d3817c700cf53a9601ccbae4f21fab9070217ea499db34d14b9015c0cd5e9f7e49267e88570626e042c2fc6c441656f1ebb84481797009d8badbe51c0b5bf6d419e0748f7a5018a78d2f4c9626aa23d60c8c73a7e65e03f41a0ffe57e63ebec4559340126f7dbf23f60f668ed275b1893970eab45d253dd8800d7add3aa28886712037eb3c558ff97ee919a31b9c0afafb7a3dfd03576248663eaebb7a5e7cbcecc390b12fbe014f5ec407120b059371b54ee8742752877a63804e188fa7aa339f491aadf2714d194b26d2a4f3322f3dcd67f15e5619b118f8ac4beb42283af099e7ef44e0592f9851ee07c45da013943c33ebaf52d6fb593cdd3cce57fcda59b1c09d9ecb8800ecc5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
