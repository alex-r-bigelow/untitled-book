<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b5373970f2058abbd6e1fdf3f9f0ad0cadc4c266f8b964066d9d586ada58e0d7002ca72fb5ebc1e9a59a221bea49b381ab1a0229f36d99e56de81ac3084707c3023236148c024ea330cb118be5464d4219533c8e8595cfa6e07daf10922794af9555ef48a31497ebeda1d95749ff20de78136720b2486e95555693a261a778728217c3918822b5b722dc83210a5a4a8019bdca7c3060ccee527d99f790cc6148a9d73bf54ec374178c064167380e4f95fb805ca684d3c1a9146308dd7947460db8c6b63dc06ae4da8f0c70c6b261e1ce6654aaaa599554df2c115234c8e2f63254653539f68be278976cc5f5456865f576bd946c80e9e9ba305ecefa476bf9e155e7af041bd7843f58da510703cb831b287ef16a3a9c6b1a14abc326dc3695eb1734b3b622859f6d3faefc68a8c4806c5f31a595d5dceabf05d81b39c6ca74e0308d1e2dcf3bf154111aa5235829f92515089272723170e57c2882c95c672ae1d1292150c282266c6453a501fa798c0ac0d66dbfc31f9169fe5967c16a9dc77524aae982129266fc5c318356c021fe376a832287a8a9e65f45f3034176f5bb66284f4f0869d326970dbb37cd04a4ada5c7df8c87ff44ace06441af1f9f080f79e15cf088d25596606eb23bc7a27e8026b3aaa1d86f9898f5fa621864be0ed382adbb92b32a2010607afbb7bdf099d1da350a0104c3a13b431e3b28ae0cd2a0140fd808ae4bbb9169dd051915d70d64d9d4a369563b7dc4526cc930f962aa10f8cd1cc25e7fa4524182222b754185c3558e3ffd81f6c6740d5bdc1e45b4981782e3e74925ba3c50dddeaf41b635bbeff7003b8f9ca4fb0834bc1198daf1c699af4d42641592b0fa1521b78bf5de11ceea29562778ff7ede6f32ef7a8bd194906f701ecf28f4235ac75c978fad58c242d45f6257374cb3b77c250779195f2726b76de9700f20fe0268d946224dc6379f395c052b501d17ad359d071aaca53be6bd4fe8e4e4f51eac67586ce6e50596077f1f4372306cf034608f6327bf8acd9bf3abc18bc6a3cd46a035c5e75e34f8ac85a17a7007d2255aec7cbef999f03c78a608d1af67f8a4c732dc76bd22b670ee8733bb99f61b7cf6a6ae07536a68211fff384466970db6e1224bb318e152eb87103fc245313f77a08aa3059a2728ddaec2a79e06f73fa832f2fb732ae3372f5c910186fbd7396b5759b3624042440f038db4ed75b2604fc0303104936de9b90f7af49b54ea5c8a1d7eea3b71472eb0ab67b5f7e6fa94ec78c45049e1e07d8cb8645457f790194eba290ea8c14168e2796fa154a49b77d5328de528ef55163d8901e4c8646ce1ceeed230480a64876567660926ac99b51a2e4490ba356fcf7c365a0a3b0ed9d2201fbe83d353209e8f22ac433d625b5b55e1dde5e7852356b5f23ea54bc9a11481c9474e7792fbbe2f4bf3766805cafd9ae72660922473aff69646a9e286ad8f8e61cbdb6c62c0f248bfd718834dc6be196d405271561a88c21b6d9eea25f91e9a3e0be2c8899f8852bf1073297d5e2a63c2a5130d9b96e687245a26fe4ae2735dd702acc6b44ec1f630afcc7b743a3ab23a7f5b37714c109be4fab87af7637ce8385a7068edcf476fdc80123cb4fa55cb0befe65e88a88ea8c8d07bf0ff9d5c97a07cba54deb5456973c2f7d81db09e60751331d92257753654b5d55b31c17437841183037059a23780c830e9943b7c35514fd7d215fef4670e4a32cd8ba1e0f5e08d77c04075308096120e4d1b631701e8429c2bfd3c3538795f6d611b45a13d636ff5e42d3dad3b600e0588535064bbdbb294dbc0068f8d3b5c0814f9a64969573826ebd985c458ce892b62db40f47a1f523d8a65532bc96813f15077cee80241cfa74ccbfd551fa1ef5c3b8c55e78071b84092fd08133ae81eb0aec38a10c93783a50b3c54d1c2bc8d54d46ebc7b7bd5b9eca7d00b3f4913faec45daa9e940134557bd5b1ac04473c75106e79845cf8137f015c9544557ef6b33c71406ab703aa42483250309c4f4d7e199e153a14b50851f06995bd12900dd9c9f6a3c10b8cfcca7214b38af1c85e702b719d944f21a19983b8632d942984d01b2a77d0f319a9cde27581ad3b78e7c1399e1bc0d090379935b094cbe84481e3d38506656d1aa4ffe55eacae097e8f54878c3e8d19372e9affa0944761dd1e37b118902b8e0e7b734b439bbc04a389d6ea6ab64e95e95fdca232294798096fa27d5edc755d57509b6b580b32a613b6a04fff2d4e3e0535b79df6b392104c7cf77e5df36b5a31c1b273cf3b21a4ecfe7b73b72c88f135c18977476a7962486db066454d3505f3ee1257023d95768d21cbbcacd29ad00852ab293d6a826d6799b9a04c487030ddff4036ef2373eab769ec6c8d19ce77a05d105988901dddd8a9f22c7509e166d2c5fb548f759b1dcc058b57c14c9ecf55635e901436dec41dbba21ef4f9c7480ef3a79effde8084239e1c4f2ad9fe5512b8566783a9a7976530d1bd5777a70b1d8ad5b9576adfb6293675963bea240969259f9567e1a04b19453c2bccf4795d15e87f0810f13db32ed22d641b1dcdfbf3fd70d68956b29320f04d65c3a19fee7aa9c74adc00ef32eece470357ca4176d9b6bc0096db321fa068ef347f27467ffe94f56c02df2355d9afa4877422ce37bc6a00a7ca69001406af22aa5c1861478bcf69fca96417ce41a2d304aa3fa2e864bd2c729de36a44775c9048baff6f9959d77bf06e0588f54d8e993e7c71d2ac51595960fde0fe2845e9f6c3b2545814dc008f858bad2360c0794eacf7630dd8e3a6bfa3a5176f56cb9817e64e191717e2d8a70942b4de4960ab7530728f122d441d6fa749d6c07522903dc1456b9d203a1f73e42614736d3706777d6dd2a3e45413d3acb53eb7c49a90b3a0b83ccc14c9090490c00b5aa62a51f954269c12e1bc92198ce710b3e58c300ec8da6b1e7f61c168db8c2033f0d0c543316f584d4892e972fcf117e987a037d9fbfbd73de17fe13cd3671c3dbdbb12fef381293621782782c1141972bd89a477ae38fc2326d603d15279d8650db927f8d61e711868be05b0ec6c3473cc90b5ce54c55ac1875627429d3c71ce95291ee17d54292f569e784ce885eef64694bfe10b0b7f12f5c235590553a39da6034cc82d626f7553a8e722833c9eb77bdb9afadb166b70611e43bfacf2e62d47c26acabbacf2a25b02f4627ec7e7e275d327c55afe4c706193865323f1d8d08c9ad2ddbb346e8f36fdd72c5ea1c82c245d648b9ec9ee5b874254aef7e6b1a97621cec28dd22c66d4241aed357c9ff49b0a81051f1e8b6db482e47407caceace7588389ad8bfea2a534e9b2031e93146a2cdb7c3e3fba82752670996a9a0fbc41d12cf2920aa72c878a34693b86a02ec76882fd3dca6ea1fae311ca982a420b063f84010e88811a705014b411c6cb619acd96643d7ed1daf59bd98a12ec3e394232f93e2c4c23ba37b944cd530e5770ec64e629f4048b5ac3fd5681aa1774a1f497c13835d9394d17b3202060dd40d611d6cdef29c0a7729757e900afe935ec0b718b980a5e3c111d478b5a3de15940c817c2c1b5672cb832b92bac309bfefc62a8d80658c5845af54b66347110804c5f0ccbff9262f5cdaaac7e6021a9faa66180c285d851626e510d8e587cee8bf968ec4b70a00bd1bb859f8b440751bca079ae3126c9a5d7b1e347b0cf1709d0ece8264c4506c5eb14265183482e4ba58da69c43f24bc644a609cafb504fa38b38091fcebd373f0cbd48b26d2d2a077f9e84aa0812056cb8cf81efe0a19976ad21a5ec90fabd2561aa00068ce673c263b89de2719819d42a912ab23298b6028507ce70e70b72fd3d37af2efa283bf9261252dc9d8e8c669b1ff14a36e75f3654d301aa3e7861cd6986c0216c1e9ae04f1f3aae50d6e2f1aa4bd1931a23c4cb046089e0c04dc31e1595169014f34feee28a18ec261e3504c9d05b62cbca0d843de2307c783a446f43de952c274aec26db65c51267ac1a82b0b4962511f2d97cc6123b991c3795235ed5fc577395ce61a7182648ac2f0033c7fd6f5dd41c780061eb160ec741c426fc46dd116b963bb524ec16d700e81806d3059244d1d4cc871ed89e312d71d99419a6f1f3bf6aeb86814a72da97734ff873211b67351ad7000562414b4d26567e85eb50c6b8f6a1536d337a84086ad575e64fc58a969b56d0e41c1564883e2b667ee9c88a8a9bc0e9828ca35a21e681a1726bb1495e11812b8ae5dd562c2c059a97f1a63a0547e475c76e019921eb493fbc15ff972095653b1e143db1b244295b84e31a68e2b3a764c7122fe8a216199117df4f7808f6d72a66a9344f5d1f67f7fc88adec560e9a50b6fad2b445957ce2a822a0d9ce2faafd1a4197d15a74a8bb1e04b3685602195c48b3830d9cc70cd0e2363af0515fa8ada84a51d6e3a595702f4c497a544dd8f304f355302e34374b683cf12bd137cfbbf0325959e11274b5fbbe1efa6f50515a6881a93b0b9772a1efc28933a48897f7163512f01e29fb3be1828d0442eddfd52a949fcc410520383ef833e9750525aaa7c8979a4b4f44a97a41c033be3ed920406a6333d0837254e198388219db63a5c9b8f76aa88a502e6729526e065382751af2e70de6443f70996f3bf756657d929f9f96507d93796d84f30d733c94baf5767a8622652dcb6bf4aa200c0c015a81c21d05cbf69dfb5779a58d1f80981d3339f9cea14b742c606bfb27eb68ba99fd9f2e9d8acaafae49c512e06cb7eefaeb7fb77481a95cc00f15e60e09bf4bf39ef58e0e8eff9f41093fbda315a8f3d5aa0483b1b8a27483bd93ffee8f08fccbd074be6ae4e207780e97bf386859c0da87aeee55327c55197e5a40bc25811d95ce60bfadbaf82ef1495321daeb32e5b236beb55496ec72a4bfa81905cde012543b7aacfb96c1549c0aac2199fa90a3c0077046c45d6005831e861d9719dc60919a3634a7fd731ccda293e61fab81011e9472b41b923aee851d0e6cfdfb9ee2c802d054cacb0e34584d96da0614613d48a92cc47521eef14966d04df53147c9a17f0fcf2c2f7770aed3e3bf4add6a644afc8326fcbc2e66c4340b2ceb20933a3559b9ecd3468d9b858e749871fe5aa745485d1ede2e2de3e9c409ca3656fc40f0b092c151709e1892c8c23af3f2b75ee156da62bf56b9df708044871fcb2a0e037209b2eb712d00fa9a2437d06b261e881a94a265b453c844f6bfc7dc6ccfa25c76b08e547795ef9be23615b602dcd8a6f2abf0bd7cd5f88f9aabe84d99e57624b59d57b0a0f0974a107a0a2fde4d8fb9fe46fe8cd1ccc9b84748ad20c1944b63166336f3d113998e75aeeb989a5e1647aa9ff716f9dccea03c6644835d3c111aa6aad7c0884e2813e520ab08b31cbd8fdc7be3c33aef613866660ac70ef041104e6c6e8ab0bc7ec9398135b3eda58764953150dc94b12455333bbbc15d092ae1b718689d4760f60ff7b9daab2f5ab10ebd7f4f6432d79f85e9470a257b2d13d2978a399eadb92c41d8cac0df32ecb99df550d7fc0f4fc38a8043c74e76ffb0e3b5494c00eca460fbb2f9b3e8974e55ce46a873a71792a59578d449dcfb120f8f6c959c082e9bdaa5d9e8b98026c6b95b05097ddd6f9207d768a0b00c295e2993eaf84eb43ae27b63ce57f252cf4300d4f0b377762d4d8ce23d3e076760940519eba1d20bc00d654bb5cdd6365a86168c5641264b769f88cc0ade0a91d2e4e21ed653c1b260bdaf17861f3ab4ad4f0b047db9a2d1fd90291080067250f8c344e327b53283803c646b32ede7e0b7f2c319a7fb3dd681b17b89e5fd2e948a129e4b7bb78a6f1409835a32725713c244ca368d693c69eec66622aaf59eed3148a7d95d362ca290421629fd60b8f81150a8339c1fbd1643fa8a518837c2f9d860a11d02c905b05589af3ebb72fc9d0391ee0052b8448c84be13f8d8baaff8dc4d6822098157530a6188faa15b1fb9f29dd233fe25005df62e5a62c0a2c6665e21d211ab19096862ccd6e95d563784579e0b5fcbd1adf1b2651d9a9ff0c233c5c237471664e57f9823210ad86f613a0a39a1db6935fb80eab5588448863ddebf51c32ca0a1f009218a5425efbf65b65b467001528cd5e135e499415d999ff8befaeff2869076f198729b01b4912fee775b2779c236e614aa365eeace142235519dfe8a333dc3c3cf0a3fa9e9a6355a36f9214d92e2b8d05bdaa34d86d8c0d23f6008f75af38625fe787e184c8d83582b581e040089df5b7a1fb8ff9c33f0326c32602da8bb16fe8ab495e30fb65e584865254d5eb3d9e90c43d4b9d89ab168818c04803eb347f7916093bf49c0defc0415af0cb58a433915763e92939ef2867945160e38da2ee45462bfce76638415ef3af91a36fba7a2503355c8f2503dd6320abd4186a160cfa03e7b6ccb2d934e6ded5064cd55ba39640d49bd403ec090aee81af33af8587b389fb2177c3ae6fd018f384573828a5800d152b619817a15eb866976af3a5d40395383244e52c7881c8338e455005d0dff63e7ddbbbc1536799ad6d03531852902140f637847eb6745caeea23112d7dfc1ac254bfa0464f5860803d66b99ce32b1dcc5ac55f126887faa14f22aa3cd69d0d5ea8df967761a9fc8d870f68e7aba21849ac98cbb8dfda31b484186ca8bec1ce999f32f4d9a0e6cb2da3e81135fe313b2dd4f25b916521c77643f4bf0cd86e46febac5b85cd84143ed9196cc6252edf19ae2068d6799ceaeaca0b390fafec4ea913f9522cdd709077f3bcac9255085ed67945aa7de5b3e4817680e67da9e9d6798c00e095f7070fd60f2616be9f56a89baf9c2bf152130d77b0d8e512addff100ae4bf225df7c4088c45a7ec7b10baae90c748733ef5e816b13f2e2b1cca672acaa3d60088967a2826d5b96e6f47cef02d42d29c5840c4f44b41ddb4442e6e99112205a2aa16171b3bfc51b77acd38753eb09c3eaf6acfa13f27cef0f559f63892065e889e4f327893eaccbf579427850ae89d258abc8d0a37ddcc81dc3a4ee37c6b238c448b7f94233401e7f02e79ebf5de28b63907708b7b856b9f16269de85c0757e15ae50907e4786d3aaa5e11bf11541322342ec9f336bc5ac039757f3ada169601ba8e89719f19328bd3e4e10b8d07c6d14d5254155e73c447099abf4f432dd44f18d9915025969953c5d30b374214f73d00e88ff35793033b1827f48a7ec26097564f7b79c52d3b42a4050491180b6ef15792e8e0e2d31608a4d80a79b6942936fb63608e9d2f93749d7f0613d19de8932ab61545df0153986a1fb90e976695876fb82648d9f27194c0efa546ca9b72548fbb60e5309f4c3a2ad81867e8496fbd7e291423d7ed1416ae131ca45a3dbe66ef5c9520d2037066ad2bd1b482c1ca01aea5481c5241cca2450050a8dd56ec5bd2b3efea6bc0a7500cafc36b7fdc5e803e176add6347720f3dbba9e3e33f8abd9dd22b656b7a1e32fcf9d5c05efad209d97f951f3ff63b4c0be0f2a30688eac744c771761c3b179950069d9098b183c1e1d425d60f4d90e5842e129444045d3e8d21a6b2d998adc0e85d7c5ad9c0f5cb53f101e7f9ec38f3596f998f0b3c927ff28301be2d4bc5a662b06531bdfd08d5bce0b7bce2be68f94dfa3d6612ff9a3a8ae96f97bbf91fa182d22b8c7c42b155dfe3d4f8a0e50cdc6d825905fe1ddbe5bdfd3b325b1262a2dbcfa512cc95552211c811e4f930923d69110eac98c570d4bf13f5a7cce3bbffabc1c22c01ef1d35d6618d873ec1a2e69ca80d541bb42f014fe76896835bd822bfabc9b460baf907f5a6029858b7859170c85099a58899b2eb4db6e2fb618b7836021a905c88423833c2dc5dfe61bad964a2011fff0e22d8eba9b25fb99b38625fea74fceed970e0b5eb35f0fefdb71928e6d577f5b7c6daddaacb950c466ba7da6bba50ad108aba6d110d2f2504cdcd417f60bc2d7983f37c7eea9c26ab3aa2cd272e391973aa2b2691c4c21c6e7d7e13e2ae6de26f3b2d5f75016db97eb0486af0595e43852e2d3a47b8a48e70a2661347cde1bde74d0048c6010b2677004d5e235bf10591abc6cc7b18550bd97148bee7323fd5a3f01ed690843ec914e99c053067d4ba0cdf91a2053aba067f698a86853bcd7a5d49877a58a5b3bbfc3e229169b34da27d842029297e1e45c18e5d017def27709a992cd1734c03fa3721b56c6cf634481d9a1ecaa6765ea2b3b92440869d6e408a1da7cdb7b1c571066a237bd2ad39b180240970475e9501da2ea9ac45d1c06eaa85a4edf720cf5b5d2349a2f5240d2858e034e2d670a749ca5782e531635a1dac46df48c9580974d7586c558626dfa05caf55991309e9e58802fa11c39a3e6ecc61af53c94de0f2c88f7ed26a96109da5799f8d3d5b1c827d6d540ba04ff425aef939d5a7dbf73e900ee1db588142b99e612ea4abda9a5393f295d1941edb30908be97a3f445e1c9240c9babb982a31edcdd342c357f37f81134a3b3e15c35e54d1423a0a4eb76f8cd6c7f86dba3e8287be82c29f29e0f6a1b2713289659d733cc109f8472a745982a5c8338b578e94854eb3f12b9edc3e95ffef86d11dfe54083a36cc396ef81219cbf5aed7313a4b2af2ffd1432627cd71ae5b14a0f68c640e40f3fdefc6776fe3a2e6102460c5b881d216cb2638df42a104b75ae7c7c06db478c9ef4b7c34bc3f72b4193c5d05f70512b1d1da61f44fc7de424615abd6fba3da03c5ad078cb758d7c2e1f5f85a5c27685c4497763490f3f7b6bd2a59853c5ef0987fff38a20b1b48ec6fb0ec02945820ab99c1ae8d06b00a6e473a038e5685b1cb38c5d09ba51c4d94666a54cb16bd81f46b7fc1df8d61c25d541e72aabecd3b74cf522fad3edd5e87ff3e875ca33b68ef5e3eb251a47088e74344a3f260fc3a6cdf868ab94314a0e42c06c3c204e5f2bfaeae3d8d20f6025816e6c949ee672d620f75ae3e4284e9fbf3888d19a498058b03c03d74cb914e10a5ddee01e88971cd18ae07529779ec90d19a7e496882513691c537ff3ddd9357f6750bb68aef8b7ed642db91c83b7e96b41a1aa36e3b3ebd8888034dc81344ecfe724866988576cb0ba6a25fa7402e5b1c262df9f0a2ddbe28a2f9e483a57f5e73bcd664cdb0d3e1ac9e62f678553098416d80655e26470666c572100e73a38deec6c1a6999f1ba01b792dba60c97dd6ad9ded48e3c02f704bc2a303713d9bcb5c20b5327c37968722c6da358057f168b3c1e63f17c446d52dd704f672c6f852c37e54a29dfaaa68da111238f1d0ecabde4b459809c6d88edcd5be20de38ddb48662cf62544f2b3eabe30b921e109f9fc71a28fe082f7a6d26bb150651c1d44c361d492040374362d0a69898f908ef56b2667082fde2c6c0d6d9f14313f392fa92e47ac2b27d2be972b7553885ee3f34e685e088a50c3cdffaf1292f3150dafe992fc1567f6e29d287ca50ff93ac1237ea80c3877f9fe3e2326c0250f0e7eafece399c541f09687979348190bb8e1010c75d5210c10afa29e03ea2816d77b9c7b836f91a31870e059caeba0e642a4e9cdd48a261e0357e1dced455a7d82b03f656157c17d6650f62a93c3500261db635b6ae99a99b3551d16f892fb803cb6f878b99c1343d7fe4727d6a862b59d8eff2cc60be47fcc09ec755ab68b1d2a4b8861ff5ef3a8d9120113459fc404e2cfc5b81359ef32afd6c700a29d20f2b9e607d8f9e084d909df4b622104131dde4f280e940b73d90c45697ac06374056a0bc16930fec1651ed4294d9806ec5e2d76d680741e0f85a046b49c4e799c79f029a81856f687cd2f76794dfc4efa0ef4b330dace33f7b7497e89217c91a82f764e6c0c10d01e8043f77e9f47ce88d1978fab639d225e02fad3998d6a615595cb06429d61336b98846ccf3038caef15b46d35112839face1202a14229e218ead9c4b0c5f6a81b875ed848f9ccf18e9bc84cd9096e465dc9e2e0ab2aae01e47c5a7dcb512e1824eafb49e2bcf8fbbfa1139c2b862c64ce9701a8d9a8016492361a0f3985f23bc103feb1c34aaa617cabd40a7b2b7428dc6591b651847145427a0177a49c5f9c551d3a21acc77bf53175d034a933d4e30baaa7c6d9695d7f2257805824b62047228f5e58bb3a870383cb345f872dbc71857a090f858c61c06499aa0da3293c923aef24794710ed7eab8d8b849f1f924714ca39d0791ff59d3c0cf69366ad525881e6ac0a5c455c607048aa40f6039ecf7a008b964a098e3edb6306c4cd309b677dbc39cf1f5b1c04c6ccfa63d65098e7aa3c2c13d7ec36c36d3fb89ebe51c32efc9c6a990abd1bb52ddf369b92a0818983ec68d2168e45b058d26d8853660bd8e424c80f7b4e06c2b4cf9be391fcd2b45ba60133547e5ed92786c171c10ba4f3ab11f6d6dbeb3617867718e122dc5967da664d424140914f9ff2380d39e363ecd64d9b325327d0dcd421e17fe855936f3c6da66c142515189de18dda36d1596764d4fe2722bd9c1f0fd170ab6d2122f8c87684349dd114eb7b674e9b50ba053097e166ed78af34c06f25442da23edde9ffc647db610790c465f0c95ced7d987c9a59dd6825adc2ab45abfae3bb5a7123b7422dd741b70d706c43e2161f46c1eca9a83dd5ab73ad391a7194aef5577c39d541dc118b67dd3a8dba3084baa50fa6484aa8745f2955c24ca0a391d4788dc8549c73371c763f0e1f31b048e0e81aa2e6a8afddfbb61f36590511f48a8412ddc20ccf46b4ff33c0f01db08b06aacc520792baec45395c5b842b10bfe4f73e4c2eaa2cd8c2420e9f25cf3046f3f7dfcc0d98d49f6e888645fa922cb095b03866058677ef961ed54642a83af2b8fc8e29b50eb79873027fcb98dd1492afde127e0f12783d5e540b98ed5f296b1f8a86a2d73f5f7b9662047cceaf0440de19e0f163e9af0c3f49bc4d87d35ef7edc04cf82e0a9a4add82cae163880b9e1bed13c60712c7cdcb5cf1cced0378c2c5dbc67fb90932bf89a2fd92718d96f1bf9f770e630cbe254d564840170c686a5573bf429ac213a93709b4b0efa26188374da77321c89f6cf23e91c9540a88e33de356095f76e92663ecea9b43431b6484319a0b7a1e81de1abcbe787cb5386e0b0f2e3aace46bcf6e370d85607464f575e2670f924869d73e41979f8838bf189d0d72f734e8360f78ba3682ec6e48bd7673a79934c83c291ca8b9408451c3a0f0abc127deb5f437b751ebcb0f10bfad07514a9adac0dd8927f10cb37502ae7e9a779d49a03a692c35a6910d223724497a2947a10f3f890705564dbaf9bd8602caa40f4398b89d219221388fc8a585c7b8b940d34ecd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ac2508daff3ae6c7a47ca817fb7d5531"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
